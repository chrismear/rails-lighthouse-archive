From 145f0ee251507a133f64ba883390fb438d0914d4 Mon Sep 17 00:00:00 2001
From: Prem Sichanugrist <s@sikachu.com>
Date: Sun, 20 Jun 2010 23:20:36 +0700
Subject: [PATCH 1/2] Update bundled i18n gem to 0.4.1 to make sure every project will be warn about using deprecated %{..} interpolation.

This will also make sure that by changing {{..}} into %{..} won't break any Rails 2.3.x application, since it would load the vendored version if it's not satisfy the version requirement.
---
 activesupport/lib/active_support/vendor.rb         |    4 +-
 .../lib/active_support/vendor/i18n-0.3.7/i18n.rb   |  335 --------------------
 .../vendor/i18n-0.3.7/i18n/backend.rb              |   19 --
 .../i18n-0.3.7/i18n/backend/active_record.rb       |   66 ----
 .../i18n/backend/active_record/missing.rb          |   67 ----
 .../i18n/backend/active_record/store_procs.rb      |   38 ---
 .../i18n/backend/active_record/translation.rb      |   88 -----
 .../vendor/i18n-0.3.7/i18n/backend/base.rb         |  266 ----------------
 .../vendor/i18n-0.3.7/i18n/backend/cache.rb        |   76 -----
 .../vendor/i18n-0.3.7/i18n/backend/cascade.rb      |   58 ----
 .../vendor/i18n-0.3.7/i18n/backend/chain.rb        |   75 -----
 .../vendor/i18n-0.3.7/i18n/backend/cldr.rb         |  100 ------
 .../vendor/i18n-0.3.7/i18n/backend/fallbacks.rb    |   69 ----
 .../vendor/i18n-0.3.7/i18n/backend/fast.rb         |   69 ----
 .../vendor/i18n-0.3.7/i18n/backend/gettext.rb      |   75 -----
 .../vendor/i18n-0.3.7/i18n/backend/helpers.rb      |   68 ----
 .../i18n/backend/interpolation_compiler.rb         |  119 -------
 .../vendor/i18n-0.3.7/i18n/backend/links.rb        |   34 --
 .../vendor/i18n-0.3.7/i18n/backend/metadata.rb     |   73 -----
 .../i18n-0.3.7/i18n/backend/pluralization.rb       |   57 ----
 .../vendor/i18n-0.3.7/i18n/backend/simple.rb       |   22 --
 .../vendor/i18n-0.3.7/i18n/core_ext/hash/except.rb |    8 -
 .../vendor/i18n-0.3.7/i18n/core_ext/hash/slice.rb  |    8 -
 .../i18n-0.3.7/i18n/core_ext/object/meta_class.rb  |    5 -
 .../i18n-0.3.7/i18n/core_ext/string/interpolate.rb |   99 ------
 .../vendor/i18n-0.3.7/i18n/exceptions.rb           |   61 ----
 .../vendor/i18n-0.3.7/i18n/gettext.rb              |   25 --
 .../vendor/i18n-0.3.7/i18n/gettext/po_parser.rb    |  329 -------------------
 .../vendor/i18n-0.3.7/i18n/helpers.rb              |    5 -
 .../vendor/i18n-0.3.7/i18n/helpers/gettext.rb      |   65 ----
 .../vendor/i18n-0.3.7/i18n/locale.rb               |    6 -
 .../vendor/i18n-0.3.7/i18n/locale/fallbacks.rb     |   98 ------
 .../vendor/i18n-0.3.7/i18n/locale/tag.rb           |   28 --
 .../vendor/i18n-0.3.7/i18n/locale/tag/parents.rb   |   24 --
 .../vendor/i18n-0.3.7/i18n/locale/tag/rfc4646.rb   |   76 -----
 .../vendor/i18n-0.3.7/i18n/locale/tag/simple.rb    |   41 ---
 .../vendor/i18n-0.3.7/i18n/version.rb              |    3 -
 .../vendor/i18n-0.4.1/CHANGELOG.textile            |  135 ++++++++
 .../active_support/vendor/i18n-0.4.1/MIT-LICENSE   |   20 ++
 .../vendor/i18n-0.4.1/README.textile               |   93 ++++++
 .../lib/active_support/vendor/i18n-0.4.1/Rakefile  |   24 ++
 .../vendor/i18n-0.4.1/benchmark/example.yml        |  148 +++++++++
 .../vendor/i18n-0.4.1/benchmark/run.rb             |  116 +++++++
 .../active_support/vendor/i18n-0.4.1/i18n.gemspec  |   20 ++
 .../lib/active_support/vendor/i18n-0.4.1/init.rb   |    1 +
 .../active_support/vendor/i18n-0.4.1/lib/i18n.rb   |  322 +++++++++++++++++++
 .../vendor/i18n-0.4.1/lib/i18n/backend.rb          |   20 ++
 .../i18n-0.4.1/lib/i18n/backend/active_record.rb   |   61 ++++
 .../lib/i18n/backend/active_record/missing.rb      |   65 ++++
 .../lib/i18n/backend/active_record/store_procs.rb  |   38 +++
 .../lib/i18n/backend/active_record/translation.rb  |   93 ++++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/base.rb     |  237 ++++++++++++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/cache.rb    |   77 +++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/cascade.rb  |   57 ++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/chain.rb    |   77 +++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/cldr.rb     |  100 ++++++
 .../i18n-0.4.1/lib/i18n/backend/fallbacks.rb       |   69 ++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/flatten.rb  |  113 +++++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/gettext.rb  |   75 +++++
 .../lib/i18n/backend/interpolation_compiler.rb     |  123 +++++++
 .../i18n-0.4.1/lib/i18n/backend/key_value.rb       |  102 ++++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/memoize.rb  |   48 +++
 .../vendor/i18n-0.4.1/lib/i18n/backend/metadata.rb |   65 ++++
 .../i18n-0.4.1/lib/i18n/backend/pluralization.rb   |   57 ++++
 .../vendor/i18n-0.4.1/lib/i18n/backend/simple.rb   |   87 +++++
 .../i18n-0.4.1/lib/i18n/backend/transliterator.rb  |   98 ++++++
 .../vendor/i18n-0.4.1/lib/i18n/config.rb           |   84 +++++
 .../vendor/i18n-0.4.1/lib/i18n/core_ext/hash.rb    |   29 ++
 .../lib/i18n/core_ext/string/interpolate.rb        |   98 ++++++
 .../vendor/i18n-0.4.1/lib/i18n/exceptions.rb       |   61 ++++
 .../vendor/i18n-0.4.1/lib/i18n/gettext.rb          |   27 ++
 .../vendor/i18n-0.4.1/lib/i18n/gettext/helpers.rb  |   65 ++++
 .../i18n-0.4.1/lib/i18n/gettext/po_parser.rb       |  329 +++++++++++++++++++
 .../vendor/i18n-0.4.1/lib/i18n/locale.rb           |    6 +
 .../vendor/i18n-0.4.1/lib/i18n/locale/fallbacks.rb |   98 ++++++
 .../vendor/i18n-0.4.1/lib/i18n/locale/tag.rb       |   28 ++
 .../i18n-0.4.1/lib/i18n/locale/tag/parents.rb      |   24 ++
 .../i18n-0.4.1/lib/i18n/locale/tag/rfc4646.rb      |   76 +++++
 .../i18n-0.4.1/lib/i18n/locale/tag/simple.rb       |   41 +++
 .../vendor/i18n-0.4.1/lib/i18n/version.rb          |    3 +
 .../active_support/vendor/i18n-0.4.1/test/all.rb   |    8 +
 .../active_support/vendor/i18n-0.4.1/test/api.rb   |   18 +
 .../i18n-0.4.1/test/api/active_record_test.rb      |   30 ++
 .../i18n-0.4.1/test/api/all_features_test.rb       |   57 ++++
 .../vendor/i18n-0.4.1/test/api/cascade_test.rb     |   31 ++
 .../vendor/i18n-0.4.1/test/api/chain_test.rb       |   27 ++
 .../vendor/i18n-0.4.1/test/api/fallbacks_test.rb   |   33 ++
 .../vendor/i18n-0.4.1/test/api/key_value_test.rb   |   31 ++
 .../vendor/i18n-0.4.1/test/api/memoize_test.rb     |   62 ++++
 .../i18n-0.4.1/test/api/pluralization_test.rb      |   33 ++
 .../vendor/i18n-0.4.1/test/api/simple_test.rb      |   22 ++
 .../vendor/i18n-0.4.1/test/api/tests/basics.rb     |   24 ++
 .../vendor/i18n-0.4.1/test/api/tests/defaults.rb   |   40 +++
 .../i18n-0.4.1/test/api/tests/interpolation.rb     |  108 +++++++
 .../vendor/i18n-0.4.1/test/api/tests/link.rb       |   56 ++++
 .../i18n-0.4.1/test/api/tests/localization/date.rb |   84 +++++
 .../test/api/tests/localization/date_time.rb       |   77 +++++
 .../test/api/tests/localization/procs.rb           |  117 +++++++
 .../i18n-0.4.1/test/api/tests/localization/time.rb |   76 +++++
 .../vendor/i18n-0.4.1/test/api/tests/lookup.rb     |   70 ++++
 .../i18n-0.4.1/test/api/tests/pluralization.rb     |   35 ++
 .../vendor/i18n-0.4.1/test/api/tests/procs.rb      |   55 ++++
 .../test/backend/active_record/missing_test.rb     |   51 +++
 .../i18n-0.4.1/test/backend/active_record_test.rb  |   57 ++++
 .../vendor/i18n-0.4.1/test/backend/cache_test.rb   |   70 ++++
 .../vendor/i18n-0.4.1/test/backend/cascade_test.rb |   72 +++++
 .../vendor/i18n-0.4.1/test/backend/chain_test.rb   |   63 ++++
 .../vendor/i18n-0.4.1/test/backend/cldr_test.rb    |  150 +++++++++
 .../i18n-0.4.1/test/backend/exceptions_test.rb     |   25 ++
 .../i18n-0.4.1/test/backend/fallbacks_test.rb      |  104 ++++++
 .../test/backend/interpolation_compiler_test.rb    |  105 ++++++
 .../i18n-0.4.1/test/backend/key_value_test.rb      |   50 +++
 .../vendor/i18n-0.4.1/test/backend/memoize_test.rb |   15 +
 .../i18n-0.4.1/test/backend/metadata_test.rb       |   69 ++++
 .../i18n-0.4.1/test/backend/pluralization_test.rb  |   46 +++
 .../vendor/i18n-0.4.1/test/backend/simple_test.rb  |   81 +++++
 .../i18n-0.4.1/test/backend/transliterator_test.rb |   83 +++++
 .../vendor/i18n-0.4.1/test/core_ext/hash_test.rb   |   33 ++
 .../test/core_ext/string/interpolate_test.rb       |  100 ++++++
 .../vendor/i18n-0.4.1/test/gettext/api_test.rb     |  207 ++++++++++++
 .../vendor/i18n-0.4.1/test/gettext/backend_test.rb |   90 ++++++
 .../vendor/i18n-0.4.1/test/i18n_exceptions_test.rb |   97 ++++++
 .../vendor/i18n-0.4.1/test/i18n_load_path_test.rb  |   23 ++
 .../vendor/i18n-0.4.1/test/i18n_test.rb            |  244 ++++++++++++++
 .../i18n-0.4.1/test/locale/fallbacks_test.rb       |  126 ++++++++
 .../i18n-0.4.1/test/locale/tag/rfc4646_test.rb     |  143 +++++++++
 .../i18n-0.4.1/test/locale/tag/simple_test.rb      |   33 ++
 .../test/test_data/locales/cldr/de/calendars.yml   |  152 +++++++++
 .../test/test_data/locales/cldr/de/currencies.yml  |    8 +
 .../test/test_data/locales/cldr/de/numbers.yml     |   31 ++
 .../vendor/i18n-0.4.1/test/test_data/locales/de.po |   72 +++++
 .../vendor/i18n-0.4.1/test/test_data/locales/en.rb |    3 +
 .../i18n-0.4.1/test/test_data/locales/en.yml       |    3 +
 .../i18n-0.4.1/test/test_data/locales/plurals.rb   |  113 +++++++
 .../vendor/i18n-0.4.1/test/test_helper.rb          |   85 +++++
 .../i18n-0.4.1/test/test_setup_requirements.rb     |   71 ++++
 136 files changed, 7281 insertions(+), 2657 deletions(-)
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/missing.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/store_procs.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/translation.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/base.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cache.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cascade.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/chain.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cldr.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fallbacks.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fast.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/gettext.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/helpers.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/interpolation_compiler.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/links.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/metadata.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/pluralization.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/simple.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/except.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/slice.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/object/meta_class.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/string/interpolate.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/exceptions.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext/po_parser.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers/gettext.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/fallbacks.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/parents.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/rfc4646.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/simple.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/version.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/CHANGELOG.textile
 create mode 100755 activesupport/lib/active_support/vendor/i18n-0.4.1/MIT-LICENSE
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/README.textile
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/Rakefile
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/example.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/run.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/i18n.gemspec
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/init.rb
 create mode 100755 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/missing.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/store_procs.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/translation.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/base.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cache.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cascade.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/chain.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cldr.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/fallbacks.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/flatten.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/gettext.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/interpolation_compiler.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/key_value.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/memoize.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/metadata.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/pluralization.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/simple.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/transliterator.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/config.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/hash.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/string/interpolate.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/exceptions.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/helpers.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/po_parser.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/fallbacks.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/parents.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/rfc4646.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/simple.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/version.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/all.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/active_record_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/all_features_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/cascade_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/chain_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/fallbacks_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/key_value_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/memoize_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/pluralization_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/simple_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/basics.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/defaults.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/interpolation.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/link.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date_time.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/procs.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/time.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/lookup.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/pluralization.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/procs.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record/missing_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cache_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cascade_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/chain_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cldr_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/exceptions_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/fallbacks_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/interpolation_compiler_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/key_value_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/memoize_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/metadata_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/pluralization_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/simple_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/transliterator_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/hash_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/string/interpolate_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/api_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/backend_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_exceptions_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_load_path_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/fallbacks_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/rfc4646_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/simple_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/calendars.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/currencies.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/numbers.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/de.po
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/plurals.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_helper.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_setup_requirements.rb

diff --git a/activesupport/lib/active_support/vendor.rb b/activesupport/lib/active_support/vendor.rb
index 0194102..62d81fe 100644
--- a/activesupport/lib/active_support/vendor.rb
+++ b/activesupport/lib/active_support/vendor.rb
@@ -21,9 +21,9 @@ rescue Gem::LoadError
 end
 
 begin
-  gem 'i18n', '>= 0.3.3'
+  gem 'i18n', '>= 0.4.1'
 rescue Gem::LoadError
-  $:.unshift "#{File.dirname(__FILE__)}/vendor/i18n-0.3.7"
+  $:.unshift "#{File.dirname(__FILE__)}/vendor/i18n-0.4.1"
 end
 require 'i18n'
 
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n.rb
deleted file mode 100644
index 7edde69..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n.rb
+++ /dev/null
@@ -1,335 +0,0 @@
-# encoding: utf-8
-
-# Authors::   Sven Fuchs (http://www.artweb-design.de),
-#             Joshua Harvey (http://www.workingwithrails.com/person/759-joshua-harvey),
-#             Stephan Soller (http://www.arkanis-development.de/),
-#             Saimon Moore (http://saimonmoore.net),
-#             Matt Aimonetti (http://railsontherun.com/)
-# Copyright:: Copyright (c) 2008 The Ruby i18n Team
-# License::   MIT
-require 'i18n/exceptions'
-require 'i18n/core_ext/string/interpolate'
-
-module I18n
-  autoload :Backend, 'i18n/backend'
-  autoload :Helpers, 'i18n/helpers'
-  autoload :Locale,  'i18n/locale'
-
-  class Config
-    # The only configuration value that is not global and scoped to thread is :locale.
-    # It defaults to the default_locale.
-    def locale
-      @locale ||= default_locale
-    end
-
-    # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
-    def locale=(locale)
-      @locale = locale.to_sym rescue nil
-    end
-
-    # Returns the current backend. Defaults to +Backend::Simple+.
-    def backend
-      @@backend ||= Backend::Simple.new
-    end
-
-    # Sets the current backend. Used to set a custom backend.
-    def backend=(backend)
-      @@backend = backend
-    end
-
-    # Returns the current default locale. Defaults to :'en'
-    def default_locale
-      @@default_locale ||= :en
-    end
-
-    # Sets the current default locale. Used to set a custom default locale.
-    def default_locale=(locale)
-      @@default_locale = locale.to_sym rescue nil
-    end
-
-    # Returns an array of locales for which translations are available.
-    # Unless you explicitely set the these through I18n.available_locales=
-    # the call will be delegated to the backend and memoized on the I18n module.
-    def available_locales
-      @@available_locales ||= backend.available_locales
-    end
-
-    # Sets the available locales.
-    def available_locales=(locales)
-      @@available_locales = locales
-    end
-
-    # Returns the current default scope separator. Defaults to '.'
-    def default_separator
-      @@default_separator ||= '.'
-    end
-
-    # Sets the current default scope separator.
-    def default_separator=(separator)
-      @@default_separator = separator
-    end
-
-    # Return the current exception handler. Defaults to :default_exception_handler.
-    def exception_handler
-      @@exception_handler ||= :default_exception_handler
-    end
-
-    # Sets the exception handler.
-    def exception_handler=(exception_handler)
-      @@exception_handler = exception_handler
-    end
-
-    # Allow clients to register paths providing translation data sources. The
-    # backend defines acceptable sources.
-    #
-    # E.g. the provided SimpleBackend accepts a list of paths to translation
-    # files which are either named *.rb and contain plain Ruby Hashes or are
-    # named *.yml and contain YAML data. So for the SimpleBackend clients may
-    # register translation files like this:
-    #   I18n.load_path << 'path/to/locale/en.yml'
-    def load_path
-      @@load_path ||= []
-    end
-
-    # Sets the load path instance. Custom implementations are expected to
-    # behave like a Ruby Array.
-    def load_path=(load_path)
-      @@load_path = load_path
-    end
-  end
-
-  class << self
-
-    # Gets I18n configuration object.
-    def config
-      Thread.current[:i18n_config] ||= I18n::Config.new
-    end
-
-    # Sets I18n configuration object.
-    def config=(value)
-      Thread.current[:i18n_config] = value
-    end
-
-    # Write methods which delegates to the configuration object
-    %w(locale backend default_locale available_locales default_separator
-      exception_handler load_path).each do |method|
-      module_eval <<-DELEGATORS, __FILE__, __LINE__ + 1
-        def #{method}
-          config.#{method}
-        end
-
-        def #{method}=(value)
-          config.#{method} = (value)
-        end
-      DELEGATORS
-    end
-
-    # Tells the backend to reload translations. Used in situations like the
-    # Rails development environment. Backends can implement whatever strategy
-    # is useful.
-    def reload!
-      config.backend.reload!
-    end
-
-    # Translates, pluralizes and interpolates a given key using a given locale,
-    # scope, and default, as well as interpolation values.
-    #
-    # *LOOKUP*
-    #
-    # Translation data is organized as a nested hash using the upper-level keys
-    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
-    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
-    #
-    # Translations can be looked up at any level of this hash using the key argument
-    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
-    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
-    #
-    # Key can be either a single key or a dot-separated key (both Strings and Symbols
-    # work). <em>E.g.</em>, the short format can be looked up using both:
-    #   I18n.t 'date.formats.short'
-    #   I18n.t :'date.formats.short'
-    #
-    # Scope can be either a single key, a dot-separated key or an array of keys
-    # or dot-separated keys. Keys and scopes can be combined freely. So these
-    # examples will all look up the same short date format:
-    #   I18n.t 'date.formats.short'
-    #   I18n.t 'formats.short', :scope => 'date'
-    #   I18n.t 'short', :scope => 'date.formats'
-    #   I18n.t 'short', :scope => %w(date formats)
-    #
-    # *INTERPOLATION*
-    #
-    # Translations can contain interpolation variables which will be replaced by
-    # values passed to #translate as part of the options hash, with the keys matching
-    # the interpolation variable names.
-    #
-    # <em>E.g.</em>, with a translation <tt>:foo => "foo {{bar}}"</tt> the option
-    # value for the key +bar+ will be interpolated into the translation:
-    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
-    #
-    # *PLURALIZATION*
-    #
-    # Translation data can contain pluralized translations. Pluralized translations
-    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
-    #
-    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
-    # pluralization rules. Other algorithms can be supported by custom backends.
-    #
-    # This returns the singular version of a pluralized translation:
-    #   I18n.t :foo, :count => 1 # => 'Foo'
-    #
-    # These both return the plural version of a pluralized translation:
-    #   I18n.t :foo, :count => 0 # => 'Foos'
-    #   I18n.t :foo, :count => 2 # => 'Foos'
-    #
-    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
-    # <em>E.g.</em>, with the translation
-    # <tt>:foo => ['{{count}} foo', '{{count}} foos']</tt>, count will
-    # be interpolated to the pluralized translation:
-    #   I18n.t :foo, :count => 1 # => '1 foo'
-    #
-    # *DEFAULTS*
-    #
-    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
-    #   I18n.t :foo, :default => 'default'
-    #
-    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
-    # translation for <tt>:foo</tt> was found:
-    #   I18n.t :foo, :default => :bar
-    #
-    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
-    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
-    #   I18n.t :foo, :default => [:bar, 'default']
-    #
-    # *BULK LOOKUP*
-    #
-    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
-    #   I18n.t [:foo, :bar]
-    #
-    # Can be used with dot-separated nested keys:
-    #   I18n.t [:'baz.foo', :'baz.bar']
-    #
-    # Which is the same as using a scope option:
-    #   I18n.t [:foo, :bar], :scope => :baz
-    #
-    # *LAMBDAS*
-    #
-    # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
-    # called and passed the key and options.
-    #
-    # E.g. assuming the key <tt>:salutation</tt> resolves to:
-    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. {{options[:name]}}" : "Mrs. {{options[:name]}}" }
-    #
-    # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
-    #
-    # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
-    # a cache layer is put in front of I18n.translate it will generate a cache key
-    # from the argument values passed to #translate. Therefor your lambdas should
-    # always return the same translations/values per unique combination of argument
-    # values.
-    def translate(*args)
-      options = args.pop if args.last.is_a?(Hash)
-      key     = args.shift
-      locale  = options && options.delete(:locale) || config.locale
-      raises  = options && options.delete(:raise)
-      config.backend.translate(locale, key, options || {})
-    rescue I18n::ArgumentError => exception
-      raise exception if raises
-      handle_exception(exception, locale, key, options)
-    end
-    alias :t :translate
-
-    def translate!(key, options = {})
-      translate(key, options.merge( :raise => true ))
-    end
-    alias :t! :translate!
-
-    # Localizes certain objects, such as dates and numbers to local formatting.
-    def localize(object, options = {})
-      locale = options.delete(:locale) || config.locale
-      format = options.delete(:format) || :default
-      config.backend.localize(locale, object, format, options)
-    end
-    alias :l :localize
-
-    # Merges the given locale, key and scope into a single array of keys.
-    # Splits keys that contain dots into multiple keys. Makes sure all
-    # keys are Symbols.
-    def normalize_keys(locale, key, scope, separator = nil)
-      separator ||= I18n.default_separator
-      normalize_key(locale, separator) +
-        normalize_key(scope, separator) +
-        normalize_key(key, separator)
-    end
-
-  # making these private until Ruby 1.9.2 can send to protected methods again
-  # see http://redmine.ruby-lang.org/repositories/revision/ruby-19?rev=24280
-  private
-
-    # Handles exceptions raised in the backend. All exceptions except for
-    # MissingTranslationData exceptions are re-raised. When a MissingTranslationData
-    # was caught and the option :raise is not set the handler returns an error
-    # message string containing the key/scope.
-    def default_exception_handler(exception, locale, key, options)
-      return exception.message if MissingTranslationData === exception
-      raise exception
-    end
-
-    # Any exceptions thrown in translate will be sent to the @@exception_handler
-    # which can be a Symbol, a Proc or any other Object.
-    #
-    # If exception_handler is a Symbol then it will simply be sent to I18n as
-    # a method call. A Proc will simply be called. In any other case the
-    # method #call will be called on the exception_handler object.
-    #
-    # Examples:
-    #
-    #   I18n.exception_handler = :default_exception_handler             # this is the default
-    #   I18n.default_exception_handler(exception, locale, key, options) # will be called like this
-    #
-    #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
-    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
-    #
-    #  I18n.exception_handler = I18nExceptionHandler.new                # an object
-    #  I18n.exception_handler.call(exception, locale, key, options)     # will be called like this
-    def handle_exception(exception, locale, key, options)
-      case config.exception_handler
-      when Symbol
-        send(config.exception_handler, exception, locale, key, options)
-      else
-        config.exception_handler.call(exception, locale, key, options)
-      end
-    end
-
-    # Deprecated. Will raise a warning in future versions and then finally be
-    # removed. Use I18n.normalize_keys instead.
-    def normalize_translation_keys(locale, key, scope, separator = nil)
-      normalize_keys(locale, key, scope, separator)
-    end
-
-    def normalize_key(key, separator)
-      normalized_key_cache(separator)[key] ||=
-        case key
-        when Array
-          key.map { |k| normalize_key(k, separator) }.flatten
-        when nil
-          []
-        else
-          key = key.to_s
-          if key == ''
-            []
-          elsif key.include?(separator)
-            keys = key.split(separator) - ['']
-            keys.map { |k| k.to_sym }
-          else
-            [key.to_sym]
-          end
-        end
-    end
-
-    def normalized_key_cache(separator)
-      @normalized_key_cache ||= Hash.new { |h,k| h[k] = {} }
-      @normalized_key_cache[separator]
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend.rb
deleted file mode 100644
index 964af24..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend.rb
+++ /dev/null
@@ -1,19 +0,0 @@
-module I18n
-  module Backend
-    autoload :ActiveRecord,          'i18n/backend/active_record'
-    autoload :Base,                  'i18n/backend/base'
-    autoload :Cache,                 'i18n/backend/cache'
-    autoload :Cascade,               'i18n/backend/cascade'
-    autoload :Chain,                 'i18n/backend/chain'
-    autoload :Cldr,                  'i18n/backend/cldr'
-    autoload :Fallbacks,             'i18n/backend/fallbacks'
-    autoload :Fast,                  'i18n/backend/fast'
-    autoload :Gettext,               'i18n/backend/gettext'
-    autoload :Helpers,               'i18n/backend/helpers'
-    autoload :Links,                 'i18n/backend/links'
-    autoload :InterpolationCompiler, 'i18n/backend/interpolation_compiler'
-    autoload :Metadata,              'i18n/backend/metadata'
-    autoload :Pluralization,         'i18n/backend/pluralization'
-    autoload :Simple,                'i18n/backend/simple'
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record.rb
deleted file mode 100644
index 19e1777..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record.rb
+++ /dev/null
@@ -1,66 +0,0 @@
-require 'i18n/backend/base'
-require 'i18n/backend/active_record/translation'
-
-module I18n
-  module Backend
-    class ActiveRecord
-      autoload :Missing,     'i18n/backend/active_record/missing'
-      autoload :StoreProcs,  'i18n/backend/active_record/store_procs'
-      autoload :Translation, 'i18n/backend/active_record/translation'
-
-      include Base, Links
-
-      def reload!
-      end
-
-      def store_translations(locale, data, options = {})
-        separator = options[:separator] || I18n.default_separator
-        wind_keys(data, separator).each do |key, value|
-          store_link(locale, key, value) if value.is_a?(Symbol)
-          Translation.locale(locale).lookup(expand_keys(key, separator), separator).delete_all
-          Translation.create(:locale => locale.to_s, :key => key.to_s, :value => value)
-        end
-      end
-
-      def available_locales
-        begin
-          Translation.available_locales
-        rescue ::ActiveRecord::StatementInvalid
-          []
-        end
-      end
-
-      protected
-
-        def lookup(locale, key, scope = [], options = {})
-          return unless key
-
-          separator = options[:separator] || I18n.default_separator
-
-          key = resolve_link(locale, key)
-          key = (Array(scope) + Array(key)).join(separator)
-          result = Translation.locale(locale).lookup(key, separator).all
-
-          if result.empty?
-            return nil
-          elsif result.first.key == key
-            return result.first.value
-          else
-            chop_range = (key.size + separator.size)..-1
-            result = result.inject({}) do |hash, r|
-              hash[r.key.slice(chop_range)] = r.value
-              hash
-            end
-            deep_symbolize_keys(unwind_keys(result, separator))
-          end
-        end
-
-        # For a key :'foo.bar.baz' return ['foo', 'foo.bar', 'foo.bar.baz']
-        def expand_keys(key, separator = I18n.default_separator)
-          key.to_s.split(separator).inject([]) do |keys, key|
-            keys << [keys.last, key].compact.join(separator)
-          end
-        end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/missing.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/missing.rb
deleted file mode 100644
index ad56df7..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/missing.rb
+++ /dev/null
@@ -1,67 +0,0 @@
-#  This extension stores translation stub records for missing translations to
-#  the database.
-#
-#  This is useful if you have a web based translation tool. It will populate
-#  the database with untranslated keys as the application is being used. A
-#  translator can then go through these and add missing translations.
-#
-#  Example usage:
-#
-#     I18n::Backend::Chain.send(:include, I18n::Backend::ActiveRecord::Missing)
-#     I18n.backend = I18nChainBackend.new(I18n::Backend::ActiveRecord.new, I18n::Backend::Simple.new)
-#
-#  Stub records for pluralizations will also be created for each key defined
-#  in i18n.plural.keys.
-#
-#  For example:
-#
-#    # en.yml
-#    en:
-#      i18n:
-#        plural:
-#          keys: [:zero, :one, :other]
-#
-#    # pl.yml
-#    pl:
-#      i18n:
-#        plural:
-#          keys: [:zero, :one, :few, :other]
-#
-#  It will also persist interpolation keys in Translation#interpolations so
-#  translators will be able to review and use them.
-module I18n
-  module Backend
-    class ActiveRecord
-      module Missing
-        def store_default_translations(locale, key, options = {})
-          count, scope, default, separator = options.values_at(:count, *Base::RESERVED_KEYS)
-          separator ||= I18n.default_separator
-
-          keys = I18n.normalize_keys(locale, key, scope, separator)[1..-1]
-          key = keys.join(separator || I18n.default_separator)
-
-          unless ActiveRecord::Translation.locale(locale).lookup(key, separator).exists?
-            interpolations = options.reject { |name, value| Base::RESERVED_KEYS.include?(name) }.keys
-            keys = count ? I18n.t('i18n.plural.keys', :locale => locale).map { |k| [key, k].join(separator) } : [key]
-            keys.each { |key| store_default_translation(locale, key, interpolations) }
-          end
-        end
-
-        def store_default_translation(locale, key, interpolations)
-          translation = ActiveRecord::Translation.new :locale => locale.to_s, :key => key
-          translation.interpolations = interpolations
-          translation.save
-        end
-
-        def translate(locale, key, options = {})
-          super
-
-          rescue I18n::MissingTranslationData => e
-            self.store_default_translations(locale, key, options)
-
-            raise e
-        end
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/store_procs.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/store_procs.rb
deleted file mode 100644
index 652b1aa..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/store_procs.rb
+++ /dev/null
@@ -1,38 +0,0 @@
-# This module is intended to be mixed into the ActiveRecord backend to allow
-# storing Ruby Procs as translation values in the database.
-#
-#   I18n.backend = I18n::Backend::ActiveRecord.new
-#   I18n::Backend::ActiveRecord::Translation.send(:include, I18n::Backend::ActiveRecord::StoreProcs)
-#
-# The StoreProcs module requires the ParseTree and ruby2ruby gems and therefor
-# was extracted from the original backend.
-#
-# ParseTree is not compatible with Ruby 1.9.
-
-begin
-  require 'ruby2ruby'
-  require 'parse_tree'
-  require 'parse_tree_extensions'
-rescue LoadError => e
-  puts "can't use StoreProcs because: #{e.message}"
-end
-
-module I18n
-  module Backend
-    class ActiveRecord
-      module StoreProcs
-        def value=(v)
-          case v
-          when Proc
-            write_attribute(:value, v.to_ruby)
-            write_attribute(:is_proc, true)
-          else
-            write_attribute(:value, v)
-          end
-        end
-
-        Translation.send(:include, self) if method(:to_s).respond_to?(:to_ruby)
-      end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/translation.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/translation.rb
deleted file mode 100644
index f3d3556..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/active_record/translation.rb
+++ /dev/null
@@ -1,88 +0,0 @@
-require 'active_record'
-
-module I18n
-  module Backend
-    # ActiveRecord model used to store actual translations to the database.
-    #
-    # This model expects a table like the following to be already set up in
-    # your the database:
-    #
-    #   create_table :translations do |t|
-    #     t.string :locale
-    #     t.string :key
-    #     t.text   :value
-    #     t.text   :interpolations
-    #     t.boolean :is_proc, :default => false
-    #   end
-    #
-    # This model supports to named scopes :locale and :lookup. The :locale
-    # scope simply adds a condition for a given locale:
-    #
-    #   I18n::Backend::ActiveRecord::Translation.locale(:en).all
-    #   # => all translation records that belong to the :en locale
-    #
-    # The :lookup scope adds a condition for looking up all translations
-    # that either start with the given keys (joined by an optionally given
-    # separator or I18n.default_separator) or that exactly have this key.
-    #
-    #   # with translations present for :"foo.bar" and :"foo.baz"
-    #   I18n::Backend::ActiveRecord::Translation.lookup(:foo)
-    #   # => an array with both translation records :"foo.bar" and :"foo.baz"
-    #
-    #   I18n::Backend::ActiveRecord::Translation.lookup([:foo, :bar])
-    #   I18n::Backend::ActiveRecord::Translation.lookup(:"foo.bar")
-    #   # => an array with the translation record :"foo.bar"
-    #
-    # When the StoreProcs module was mixed into this model then Procs will
-    # be stored to the database as Ruby code and evaluated when :value is
-    # called.
-    #
-    #   Translation = I18n::Backend::ActiveRecord::Translation
-    #   Translation.create \
-    #     :locale => 'en'
-    #     :key    => 'foo'
-    #     :value  => lambda { |key, options| 'FOO' }
-    #   Translation.find_by_locale_and_key('en', 'foo').value
-    #   # => 'FOO'
-    class ActiveRecord
-      class Translation < ::ActiveRecord::Base
-        set_table_name 'translations'
-        attr_protected :is_proc, :interpolations
-
-        serialize :value
-        serialize :interpolations, Array
-
-        scope_method = ::ActiveRecord::VERSION::MAJOR == 2 ? :named_scope : :scope
-
-        send scope_method, :locale, lambda { |locale|
-          { :conditions => { :locale => locale.to_s } }
-        }
-
-        send scope_method, :lookup, lambda { |keys, *separator|
-          column_name = connection.quote_column_name('key')
-          keys        = Array(keys).map! { |key| key.to_s }
-          separator   = separator.first || I18n.default_separator
-          namespace   = "#{keys.last}#{separator}%"
-          { :conditions => ["#{column_name} IN (?) OR #{column_name} LIKE ?", keys, namespace] }
-        }
-
-        def self.available_locales
-          Translation.find(:all, :select => 'DISTINCT locale').map { |t| t.locale.to_sym }
-        end
-
-        def interpolates?(key)
-          self.interpolations.include?(key) if self.interpolations
-        end
-
-        def value
-          if is_proc
-            Kernel.eval(read_attribute(:value))
-          else
-            value = read_attribute(:value)
-            value == 'f' ? false : value
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/base.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/base.rb
deleted file mode 100644
index a569271..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/base.rb
+++ /dev/null
@@ -1,266 +0,0 @@
-# encoding: utf-8
-
-require 'yaml'
-require 'i18n/core_ext/hash/except'
-
-module I18n
-  module Backend
-    module Base
-      include I18n::Backend::Helpers
-
-      RESERVED_KEYS = [:scope, :default, :separator, :resolve]
-      INTERPOLATION_SYNTAX_PATTERN = /(\\)?\{\{([^\}]+)\}\}/
-
-      # Accepts a list of paths to translation files. Loads translations from
-      # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
-      # for details.
-      def load_translations(*filenames)
-        filenames.each { |filename| load_file(filename) }
-      end
-
-      # Stores translations for the given locale in memory.
-      # This uses a deep merge for the translations hash, so existing
-      # translations will be overwritten by new ones only at the deepest
-      # level of the hash.
-      def store_translations(locale, data, options = {})
-        merge_translations(locale, data, options)
-      end
-
-      def translate(locale, key, options = {})
-        raise InvalidLocale.new(locale) unless locale
-        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
-
-        if options.empty?
-          entry = resolve(locale, key, lookup(locale, key), options)
-          raise(I18n::MissingTranslationData.new(locale, key, options)) if entry.nil?
-        else
-          count, scope, default = options.values_at(:count, :scope, :default)
-          values = options.reject { |name, value| RESERVED_KEYS.include?(name) }
-
-          entry = lookup(locale, key, scope, options)
-          entry = entry.nil? && default ? default(locale, key, default, options) : resolve(locale, key, entry, options)
-          raise(I18n::MissingTranslationData.new(locale, key, options)) if entry.nil?
-
-          entry = pluralize(locale, entry, count)    if count
-          entry = interpolate(locale, entry, values) if values
-        end
-
-        entry
-      end
-
-      # Acts the same as +strftime+, but uses a localized version of the
-      # format string. Takes a key from the date/time formats translations as
-      # a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
-      def localize(locale, object, format = :default, options = {})
-        raise ArgumentError, "Object must be a Date, DateTime or Time object. #{object.inspect} given." unless object.respond_to?(:strftime)
-
-        if Symbol === format
-          key = format
-          type = object.respond_to?(:sec) ? 'time' : 'date'
-          format = I18n.t(:"#{type}.formats.#{key}", :locale => locale, :raise => true)
-        end
-
-        # format = resolve(locale, object, format, options)
-        format = format.to_s.gsub(/%[aAbBp]/) do |match|
-          case match
-          when '%a' then I18n.t(:"date.abbr_day_names",                  :locale => locale, :format => format)[object.wday]
-          when '%A' then I18n.t(:"date.day_names",                       :locale => locale, :format => format)[object.wday]
-          when '%b' then I18n.t(:"date.abbr_month_names",                :locale => locale, :format => format)[object.mon]
-          when '%B' then I18n.t(:"date.month_names",                     :locale => locale, :format => format)[object.mon]
-          when '%p' then I18n.t(:"time.#{object.hour < 12 ? :am : :pm}", :locale => locale, :format => format) if object.respond_to? :hour
-          end
-        end
-
-        object.strftime(format)
-      end
-
-      def initialized?
-        @initialized ||= false
-      end
-
-      # Returns an array of locales for which translations are available
-      # ignoring the reserved translation meta data key :i18n.
-      def available_locales
-        init_translations unless initialized?
-        translations.inject([]) do |locales, (locale, data)|
-          locales << locale unless (data.keys - [:i18n]).empty?
-          locales
-        end
-      end
-
-      def reload!
-        @initialized = false
-        @translations = nil
-      end
-
-      protected
-        def init_translations
-          load_translations(*I18n.load_path.flatten)
-          @initialized = true
-        end
-
-        def translations
-          @translations ||= {}
-        end
-
-        # Looks up a translation from the translations hash. Returns nil if
-        # eiher key is nil, or locale, scope or key do not exist as a key in the
-        # nested translations hash. Splits keys or scopes containing dots
-        # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
-        # <tt>%w(currency format)</tt>.
-        def lookup(locale, key, scope = [], options = {})
-          return unless key
-          init_translations unless initialized?
-          keys = I18n.normalize_keys(locale, key, scope, options[:separator])
-          keys.inject(translations) do |result, key|
-            key = key.to_sym
-            return nil unless result.is_a?(Hash) && result.has_key?(key)
-            result = result[key]
-            result = resolve(locale, key, result, options) if result.is_a?(Symbol)
-            String === result ? result.dup : result
-          end
-        end
-
-        # Evaluates defaults.
-        # If given subject is an Array, it walks the array and returns the
-        # first translation that can be resolved. Otherwise it tries to resolve
-        # the translation directly.
-        def default(locale, object, subject, options = {})
-          options = options.dup.reject { |key, value| key == :default }
-          case subject
-          when Array
-            subject.each do |item|
-              result = resolve(locale, object, item, options) and return result
-            end and nil
-          else
-            resolve(locale, object, subject, options)
-          end
-        end
-
-        # Resolves a translation.
-        # If the given subject is a Symbol, it will be translated with the
-        # given options. If it is a Proc then it will be evaluated. All other
-        # subjects will be returned directly.
-        def resolve(locale, object, subject, options = nil)
-          return subject if options[:resolve] == false
-          case subject
-          when Symbol
-            I18n.translate(subject, (options || {}).merge(:locale => locale, :raise => true))
-          when Proc
-            resolve(locale, object, subject.call(object, options), options = {})
-          else
-            subject
-          end
-        rescue MissingTranslationData
-          nil
-        end
-
-        # Picks a translation from an array according to English pluralization
-        # rules. It will pick the first translation if count is not equal to 1
-        # and the second translation if it is equal to 1. Other backends can
-        # implement more flexible or complex pluralization rules.
-        def pluralize(locale, entry, count)
-          return entry unless entry.is_a?(Hash) and count
-
-          key = :zero if count == 0 && entry.has_key?(:zero)
-          key ||= count == 1 ? :one : :other
-          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
-          entry[key]
-        end
-
-        # Interpolates values into a given string.
-        #
-        #   interpolate "file {{file}} opened by \\{{user}}", :file => 'test.txt', :user => 'Mr. X'
-        #   # => "file test.txt opened by {{user}}"
-        #
-        # Note that you have to double escape the <tt>\\</tt> when you want to escape
-        # the <tt>{{...}}</tt> key in a string (once for the string and once for the
-        # interpolation).
-        def interpolate(locale, string, values = {})
-          return string unless string.is_a?(::String) && !values.empty?
-
-          preserve_encoding(string) do
-            s = string.gsub(INTERPOLATION_SYNTAX_PATTERN) do
-              escaped, key = $1, $2.to_sym
-              if escaped
-                "{{#{key}}}"
-              elsif RESERVED_KEYS.include?(key)
-                raise ReservedInterpolationKey.new(key, string)
-              else
-                "%{#{key}}"
-              end
-            end
-
-            values.each do |key, value|
-              value = value.call(values) if interpolate_lambda?(value, s, key)
-              value = value.to_s unless value.is_a?(::String)
-              values[key] = value
-            end
-
-            s % values
-          end
-
-        rescue KeyError => e
-          raise MissingInterpolationArgument.new(values, string)
-        end
-
-        def preserve_encoding(string)
-          if string.respond_to?(:encoding)
-            encoding = string.encoding
-            result = yield
-            result.force_encoding(encoding) if result.respond_to?(:force_encoding)
-            result
-          else
-            yield
-          end
-        end
-
-        # returns true when the given value responds to :call and the key is
-        # an interpolation placeholder in the given string
-        def interpolate_lambda?(object, string, key)
-          object.respond_to?(:call) && string =~ /%\{#{key}\}|%\<#{key}>.*?\d*\.?\d*[bBdiouxXeEfgGcps]\}/
-        end
-
-        # Loads a single translations file by delegating to #load_rb or
-        # #load_yml depending on the file extension and directly merges the
-        # data to the existing translations. Raises I18n::UnknownFileType
-        # for all other file extensions.
-        def load_file(filename)
-          type = File.extname(filename).tr('.', '').downcase
-          raise UnknownFileType.new(type, filename) unless respond_to?(:"load_#{type}")
-          data = send(:"load_#{type}", filename) # TODO raise a meaningful exception if this does not yield a Hash
-          data.each { |locale, d| merge_translations(locale, d) }
-        end
-
-        # Loads a plain Ruby translations file. eval'ing the file must yield
-        # a Hash containing translation data with locales as toplevel keys.
-        def load_rb(filename)
-          eval(IO.read(filename), binding, filename)
-        end
-
-        # Loads a YAML translations file. The data must have locales as
-        # toplevel keys.
-        def load_yml(filename)
-          YAML::load(IO.read(filename))
-        end
-
-        # Deep merges the given translations hash with the existing translations
-        # for the given locale
-        def merge_translations(locale, data, options = {})
-          locale = locale.to_sym
-          translations[locale] ||= {}
-          separator = options[:separator] || I18n.default_separator
-          data = unwind_keys(data, separator)
-          data = deep_symbolize_keys(data)
-
-          # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
-          merger = proc do |key, v1, v2|
-            # TODO should probably be:
-            # raise TypeError.new("can't merge #{v1.inspect} and #{v2.inspect}") unless Hash === v1 && Hash === v2
-            Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : (v2 || v1)
-          end
-          translations[locale].merge!(data, &merger)
-        end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cache.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cache.rb
deleted file mode 100644
index 86a0b27..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cache.rb
+++ /dev/null
@@ -1,76 +0,0 @@
-# encoding: utf-8
-
-# This module allows you to easily cache all responses from the backend - thus
-# speeding up the I18n aspects of your application quite a bit.
-#
-# To enable caching you can simply include the Cache module to the Simple
-# backend - or whatever other backend you are using:
-#
-#  I18n::Backend::Simple.send(:include, I18n::Backend::Cache)
-#
-# You will also need to set a cache store implementation that you want to use:
-#
-#  I18n.cache_store = ActiveSupport::Cache.lookup_store(:memory_store)
-#
-# You can use any cache implementation you want that provides the same API as
-# ActiveSupport::Cache (only the methods #fetch and #write are being used).
-#
-# The cache_key implementation assumes that you only pass values to
-# I18n.translate that return a valid key from #hash (see
-# http://www.ruby-doc.org/core/classes/Object.html#M000337).
-module I18n
-  class << self
-    @@cache_store = nil
-    @@cache_namespace = nil
-
-    def cache_store
-      @@cache_store
-    end
-
-    def cache_store=(store)
-      @@cache_store = store
-    end
-
-    def cache_namespace
-      @@cache_namespace
-    end
-
-    def cache_namespace=(namespace)
-      @@cache_namespace = namespace
-    end
-
-    def perform_caching?
-      !cache_store.nil?
-    end
-  end
-
-  module Backend
-    module Cache
-      def translate(*args)
-        I18n.perform_caching? ? fetch(*args) { super } : super
-      end
-
-      protected
-
-        def fetch(*args, &block)
-          result = I18n.cache_store.fetch(cache_key(*args), &block)
-          raise result if result.is_a?(Exception)
-          result = result.dup if result.frozen? rescue result
-          result
-        rescue MissingTranslationData => exception
-          I18n.cache_store.write(cache_key(*args), exception)
-          raise exception
-        end
-
-        def cache_key(*args)
-          # This assumes that only simple, native Ruby values are passed to I18n.translate.
-          # Also, in Ruby < 1.8.7 {}.hash != {}.hash
-          # (see http://paulbarry.com/articles/2009/09/14/why-rails-3-will-require-ruby-1-8-7)
-          # If args.inspect does not work for you for some reason, patches are very welcome :)
-          hash = RUBY_VERSION >= "1.8.7" ? args.hash : args.inspect
-          keys = ['i18n', I18n.cache_namespace, hash]
-          keys.compact.join('-')
-        end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cascade.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cascade.rb
deleted file mode 100644
index 9f770aa..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cascade.rb
+++ /dev/null
@@ -1,58 +0,0 @@
-# encoding: utf-8
-
-# EXPERIMENTAL
-#
-# The Cascade module adds the ability to do cascading lookups to backends that
-# are compatible to the Simple backend.
-#
-# By cascading lookups we mean that for any key that can not be found the
-# Cascade module strips one segment off the scope part of the key and then
-# tries to look up the key in that scope.
-#
-# E.g. when a lookup for the key :"foo.bar.baz" does not yield a result then
-# the segment :bar will be stripped off the scope part :"foo.bar" and the new
-# scope :foo will be used to look up the key :baz. If that does not succeed
-# then the remaining scope segment :foo will be omitted, too, and again the
-# key :baz will be looked up (now with no scope).
-#
-# To enable a cascading lookup one passes the :cascade option:
-#
-#   I18n.t(:'foo.bar.baz', :cascade => true)
-#
-# This will return the first translation found for :"foo.bar.baz", :"foo.baz"
-# or :baz in this order.
-#
-# The cascading lookup takes precedence over resolving any given defaults.
-# I.e. defaults will kick in after the cascading lookups haven't succeeded.
-#
-# This behavior is useful for libraries like ActiveRecord validations where
-# the library wants to give users a bunch of more or less fine-grained options
-# of scopes for a particular key.
-#
-# Thanks to Clemens Kofler for the initial idea and implementation! See
-# http://github.com/clemens/i18n-cascading-backend
-
-module I18n
-  module Backend
-    module Cascade
-      def lookup(locale, key, scope = [], options = {})
-        return unless key
-        return super unless cascade = options[:cascade]
-
-        separator = options[:separator] || I18n.default_separator
-        skip_root = cascade.has_key?(:skip_root) ? cascade[:skip_root] : true
-        step      = cascade[:step]
-
-        keys   = I18n.normalize_keys(nil, key, nil, separator)
-        offset = options[:cascade][:offset] || keys.length
-        scope  = I18n.normalize_keys(nil, nil, scope, separator) + keys
-        key    = scope.slice!(-offset, offset).join(separator)
-
-        begin
-          result = super
-          return result unless result.nil?
-        end while !scope.empty? && scope.slice!(-step, step) && (!scope.empty? || !skip_root)
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/chain.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/chain.rb
deleted file mode 100644
index 7ab1f99..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/chain.rb
+++ /dev/null
@@ -1,75 +0,0 @@
-# encoding: utf-8
-
-module I18n
-  module Backend
-    # Backend that chains multiple other backends and checks each of them when
-    # a translation needs to be looked up. This is useful when you want to use
-    # standard translations with a Simple backend but store custom application
-    # translations in a database or other backends.
-    #
-    # To use the Chain backend instantiate it and set it to the I18n module.
-    # You can add chained backends through the initializer or backends
-    # accessor:
-    #
-    #   # preserves the existing Simple backend set to I18n.backend
-    #   I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
-    #
-    # The implementation assumes that all backends added to the Chain implement
-    # a lookup method with the same API as Simple backend does.
-    class Chain < Simple
-      attr_accessor :backends
-
-      def initialize(*backends)
-        self.backends = backends
-      end
-
-      def reload!
-        backends.each { |backend| backend.reload! }
-      end
-
-      def store_translations(locale, data, options = {})
-        backends.first.store_translations(locale, data, options = {})
-      end
-
-      def available_locales
-        backends.map { |backend| backend.available_locales }.flatten.uniq
-      end
-
-      def translate(locale, key, options = {})
-        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
-
-        default = options.delete(:default)
-        namespace = {}
-        backends.each do |backend|
-          begin
-            options.update(:default => default) if default and backend == backends.last
-            translation = backend.translate(locale, key, options)
-            if namespace_lookup?(translation, options)
-              namespace.update(translation)
-            elsif !translation.nil?
-              return translation
-            end
-          rescue MissingTranslationData
-          end
-        end
-        return namespace unless namespace.empty?
-        raise(I18n::MissingTranslationData.new(locale, key, options))
-      end
-
-      def localize(locale, object, format = :default, options = {})
-        backends.each do |backend|
-          begin
-            result = backend.localize(locale, object, format, options) and return result
-          rescue MissingTranslationData
-          end
-        end
-        raise(I18n::MissingTranslationData.new(locale, format, options))
-      end
-
-      protected
-        def namespace_lookup?(result, options)
-          result.is_a?(Hash) and not options.has_key?(:count)
-        end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cldr.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cldr.rb
deleted file mode 100644
index d702f22..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/cldr.rb
+++ /dev/null
@@ -1,100 +0,0 @@
-# encoding: utf-8
-require 'cldr'
-
-module I18n
-  module Backend
-    module Cldr
-      include ::Cldr::Format
-
-      def localize(locale, object, format = :default, options = {})
-        options[:as] ||= detect_type(object, options)
-        send(:"format_#{options[:as]}", locale, object, format, options)
-      end
-
-      def format_decimal(locale, object, format = :default, options = {})
-        formatter(locale, :decimal, format).apply(object, options)
-      end
-
-      def format_integer(locale, object, format = :default, options = {})
-        format_object(number, options.merge(:precision => 0))
-      end
-
-      def format_currency(locale, object, format = :default, options = {})
-        options.merge!(:currency => lookup_currency(locale, options[:currency], object)) if options[:currency].is_a?(Symbol)
-        formatter(locale, :currency, format).apply(object, options)
-      end
-
-      def format_percent(locale, object, format = :default, options = {})
-        formatter(locale, :percent, format).apply(object, options)
-      end
-
-      def format_date(locale, object, format = :default, options = {})
-        formatter(locale, :date, format).apply(object, options)
-      end
-
-      def format_time(locale, object, format = :default, options = {})
-        formatter(locale, :time, format).apply(object, options)
-      end
-
-      def format_datetime(locale, object, format = :default, options = {})
-        key  = :"calendars.gregorian.formats.datetime.#{format}.pattern"
-        date = I18n.l(object, :format => options[:date_format] || format, :locale => locale, :as => :date)
-        time = I18n.l(object, :format => options[:time_format] || format, :locale => locale, :as => :time)
-        I18n.t(key, :date => date, :time => time, :locale => locale, :raise => true)
-      end
-
-      protected
-
-        def detect_type(object, options)
-          options.has_key?(:currency) ? :currency : case object
-          when ::Numeric
-            :decimal
-          when ::Date, ::DateTime, ::Time
-            object.class.name.downcase.to_sym
-          else
-            raise_unspecified_format_type!
-          end
-        end
-
-        def formatter(locale, type, format)
-          (@formatters ||= {})[:"#{locale}.#{type}.#{format}"] ||= begin
-            format = lookup_format(locale, type, format)
-            data   = lookup_format_data(locale, type)
-            ::Cldr::Format.const_get(type.to_s.camelize).new(format, data)
-          end
-        end
-
-        def lookup_format(locale, type, format)
-          key = case type
-          when :date, :time, :datetime
-            :"calendars.gregorian.formats.#{type}.#{format}.pattern"
-          else
-            :"numbers.formats.#{type}.patterns.#{format || :default}"
-          end
-          I18n.t(key, :locale => locale, :raise => true)
-        end
-
-        def lookup_format_data(locale, type)
-          key = case type
-          when :date, :time, :datetime
-            :'calendars.gregorian'
-          else
-            :'numbers.symbols'
-          end
-          I18n.t(key, :locale => locale, :raise => true)
-        end
-
-        def lookup_currency(locale, currency, count)
-          I18n.t(:"currencies.#{currency}", :locale => locale, :count => count)
-        end
-
-        def raise_unspecified_format_type!
-          raise ArgumentError.new("You have to specify a format type, e.g. :as => :number.")
-        end
-
-        def raise_unspecified_currency!
-          raise ArgumentError.new("You have to specify a currency, e.g. :currency => 'EUR'.")
-        end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fallbacks.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fallbacks.rb
deleted file mode 100644
index 1e014be..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fallbacks.rb
+++ /dev/null
@@ -1,69 +0,0 @@
-# encoding: utf-8
-
-# I18n locale fallbacks are useful when you want your application to use
-# translations from other locales when translations for the current locale are
-# missing. E.g. you might want to use :en translations when translations in
-# your applications main locale :de are missing.
-#
-# To enable locale fallbacks you can simply include the Fallbacks module to
-# the Simple backend - or whatever other backend you are using:
-#
-#   I18n::Backend::Simple.send(:include, I18n::Backend::Fallbacks)
-module I18n
-  @@fallbacks = nil
-
-  class << self
-    # Returns the current fallbacks implementation. Defaults to +I18n::Locale::Fallbacks+.
-    def fallbacks
-      @@fallbacks ||= I18n::Locale::Fallbacks.new
-    end
-
-    # Sets the current fallbacks implementation. Use this to set a different fallbacks implementation.
-    def fallbacks=(fallbacks)
-      @@fallbacks = fallbacks
-    end
-  end
-
-  module Backend
-    module Fallbacks
-      # Overwrites the Base backend translate method so that it will try each
-      # locale given by I18n.fallbacks for the given locale. E.g. for the
-      # locale :"de-DE" it might try the locales :"de-DE", :de and :en
-      # (depends on the fallbacks implementation) until it finds a result with
-      # the given options. If it does not find any result for any of the
-      # locales it will then raise a MissingTranslationData exception as
-      # usual.
-      #
-      # The default option takes precedence over fallback locales
-      # only when it's not a String. When default contains String it
-      # is evaluated after fallback locales.
-      def translate(locale, key, options = {})
-        default = extract_string_default!(options) if options[:default]
-
-        I18n.fallbacks[locale].each do |fallback|
-          begin
-            result = super(fallback, key, options)
-            return result unless result.nil?
-          rescue I18n::MissingTranslationData
-          end
-        end
-
-        return super(locale, nil, options.merge(:default => default)) if default
-        raise(I18n::MissingTranslationData.new(locale, key, options))
-      end
-
-      def extract_string_default!(options)
-        defaults = Array(options[:default])
-        if index = find_first_string_default(defaults)
-          options[:default] = defaults[0, index]
-          defaults[index]
-        end
-      end
-
-      def find_first_string_default(defaults)
-        defaults.each_index { |ix| return ix if String === defaults[ix] }
-        nil
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fast.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fast.rb
deleted file mode 100644
index 9656e59..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/fast.rb
+++ /dev/null
@@ -1,69 +0,0 @@
-# encoding: utf-8
-
-# The Fast module contains optimizations that can tremendously speed up the
-# lookup process on the Simple backend. It works by flattening the nested
-# translation hash to a flat hash (e.g. { :a => { :b => 'c' } } becomes
-# { :'a.b' => 'c' }).
-#
-# To enable these optimizations you can simply include the Fast module to
-# the Simple backend:
-#
-#   I18n::Backend::Simple.send(:include, I18n::Backend::Fast)
-module I18n
-  module Backend
-    module Fast
-      include Links
-
-      def reset_flattened_translations!
-        @flattened_translations = nil
-      end
-
-      def flattened_translations
-        @flattened_translations ||= flatten_translations(translations)
-      end
-
-      def merge_translations(locale, data, options = {})
-        super
-        reset_flattened_translations!
-      end
-
-      def init_translations
-        super
-        reset_flattened_translations!
-      end
-
-      protected
-        def flatten_translations(translations)
-          # don't flatten locale roots
-          translations.inject({}) do |result, (locale, translations)|
-            result[locale] = wind_keys(translations, nil, true)
-            result[locale].each do |key, value|
-              store_link(locale, key, value) if value.is_a?(Symbol)
-            end
-            result
-          end
-        end
-
-        def lookup(locale, key, scope = nil, options = {})
-          return unless key
-          init_translations unless initialized?
-
-          return nil unless flattened_translations.has_key?(locale.to_sym)
-
-          separator = options[:separator]
-          if separator && I18n.default_separator != separator
-            key   = cleanup_non_standard_separator(key, separator)
-            scope = Array(scope).map{|k| cleanup_non_standard_separator(k, separator)} if scope
-          end
-          
-          key = resolve_link(locale, key)
-          key = (Array(scope) + [key]).join(I18n.default_separator) if scope
-          flattened_translations[locale.to_sym][key.to_sym]
-        end
-
-        def cleanup_non_standard_separator(key, user_separator)
-          escape_default_separator(key).tr(user_separator, I18n.default_separator)
-        end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/gettext.rb
deleted file mode 100644
index 7f8ad22..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/gettext.rb
+++ /dev/null
@@ -1,75 +0,0 @@
-# encoding: utf-8
-
-require 'i18n/gettext'
-require 'i18n/gettext/po_parser'
-
-# Experimental support for using Gettext po files to store translations.
-#
-# To use this you can simply include the module to the Simple backend - or
-# whatever other backend you are using.
-#
-#   I18n::Backend::Simple.send(:include, I18n::Backend::Gettext)
-#
-# Now you should be able to include your Gettext translation (*.po) files to
-# the I18n.load_path so they're loaded to the backend and you can use them as
-# usual:
-#
-#  I18n.load_path += Dir["path/to/locales/*.po"]
-#
-# Following the Gettext convention this implementation expects that your
-# translation files are named by their locales. E.g. the file en.po would
-# contain the translations for the English locale.
-module I18n
-  module Backend
-    module Gettext
-      class PoData < Hash
-        def set_comment(msgid_or_sym, comment)
-          # ignore
-        end
-      end
-
-      protected
-        def load_po(filename)
-          locale = ::File.basename(filename, '.po').to_sym
-          data = normalize(locale, parse(filename))
-          { locale => data }
-        end
-
-        def parse(filename)
-          GetText::PoParser.new.parse(::File.read(filename), PoData.new)
-        end
-
-        def normalize(locale, data)
-          data.inject({}) do |result, (key, value)|
-            unless key.nil? || key.empty?
-              key, value = normalize_pluralization(locale, key, value) if key.index("\000")
-
-              parts = key.split('|').reverse
-              normalized = parts.inject({}) do |normalized, part|
-                normalized = { part => normalized.empty? ? value : normalized }
-              end
-
-              # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
-              merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
-              result.merge!(normalized, &merger)
-            end
-            result
-          end
-        end
-
-        def normalize_pluralization(locale, key, value)
-          # FIXME po_parser includes \000 chars that can not be turned into Symbols
-          key = key.gsub("\000", I18n::Gettext::PLURAL_SEPARATOR).split(I18n::Gettext::PLURAL_SEPARATOR).first
-
-          keys = I18n::Gettext.plural_keys(locale)
-          values = value.split("\000")
-          raise "invalid number of plurals: #{values.size}, keys: #{keys.inspect}" if values.size != keys.size
-
-          result = {}
-          values.each_with_index { |value, ix| result[keys[ix]] = value }
-          [key, result]
-        end
-
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/helpers.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/helpers.rb
deleted file mode 100644
index db773f2..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/helpers.rb
+++ /dev/null
@@ -1,68 +0,0 @@
-module I18n
-  module Backend
-    module Helpers
-      SEPARATOR_ESCAPE_CHAR = "\001"
-
-      # Return a new hash with all keys and nested keys converted to symbols.
-      def deep_symbolize_keys(hash)
-        hash.inject({}) { |result, (key, value)|
-          value = deep_symbolize_keys(value) if value.is_a?(Hash)
-          result[(key.to_sym rescue key) || key] = value
-          result
-        }
-      end
-
-      # Flatten keys for nested Hashes by chaining up keys using the separator
-      #   >> { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}.wind
-      #   => { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }
-      def wind_keys(hash, separator = nil, subtree = false, prev_key = nil, result = {}, orig_hash=hash)
-        separator ||= I18n.default_separator
-
-        hash.each_pair do |key, value|
-          key = escape_default_separator(key, separator)
-          curr_key = [prev_key, key].compact.join(separator).to_sym
-
-          if value.is_a?(Hash)
-            result[curr_key] = value if subtree
-            wind_keys(value, separator, subtree, curr_key, result, orig_hash)
-          else
-            result[unescape_default_separator(curr_key)] = value
-          end
-        end
-
-        result
-      end
-
-      def escape_default_separator(key, separator=nil)
-        key.to_s.tr(separator || I18n.default_separator, SEPARATOR_ESCAPE_CHAR)
-      end
-      
-      def unescape_default_separator(key, separator=nil)
-        key.to_s.tr(SEPARATOR_ESCAPE_CHAR, separator || I18n.default_separator).to_sym
-      end
-
-      # Expand keys chained by the the given separator through nested Hashes
-      #   >> { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }.unwind
-      #   => { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}
-      def unwind_keys(hash, separator = ".")
-        result = {}
-        hash.each do |key, value|
-          keys = key.to_s.split(separator)
-          curr = result
-          curr = curr[keys.shift] ||= {} while keys.size > 1
-          curr[keys.shift] = value
-        end
-        result
-      end
-
-      # # Flatten the given array once
-      # def flatten_once(array)
-      #   result = []
-      #   for element in array # a little faster than each
-      #     result.push(*element)
-      #   end
-      #   result
-      # end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/interpolation_compiler.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/interpolation_compiler.rb
deleted file mode 100644
index 702afdb..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/interpolation_compiler.rb
+++ /dev/null
@@ -1,119 +0,0 @@
-# encoding: utf-8
-
-# The InterpolationCompiler module contains optimizations that can tremendously
-# speed up the interpolation process on the Simple backend.
-#
-# It works by defining a pre-compiled method on stored translation Strings that
-# already bring all the knowledge about contained interpolation variables etc.
-# so that the actual recurring interpolation will be very fast.
-#
-# To enable pre-compiled interpolations you can simply include the
-# InterpolationCompiler module to the Simple backend:
-#
-#   I18n::Backend::Simple.send(:include, I18n::Backend::InterpolationCompiler)
-module I18n
-  module Backend
-    module InterpolationCompiler
-      module Compiler
-        extend self
-
-        TOKENIZER                    = /(\\\{\{[^\}]+\}\}|\{\{[^\}]+\}\})/
-        INTERPOLATION_SYNTAX_PATTERN = /(\\)?(\{\{([^\}]+)\}\})/
-
-        def compile_if_an_interpolation(string)
-          if interpolated_str?(string)
-            string.instance_eval <<-RUBY_EVAL, __FILE__, __LINE__
-              def i18n_interpolate(v = {})
-                "#{compiled_interpolation_body(string)}"
-              end
-            RUBY_EVAL
-          end
-
-          string
-        end
-
-        def interpolated_str?(str)
-          str.kind_of?(::String) && str =~ INTERPOLATION_SYNTAX_PATTERN
-        end
-
-        protected
-        # tokenize("foo {{bar}} baz \\{{buz}}") # => ["foo ", "{{bar}}", " baz ", "\\{{buz}}"]
-        def tokenize(str)
-          str.split(TOKENIZER)
-        end
-
-        def compiled_interpolation_body(str)
-          tokenize(str).map do |token|
-            (matchdata = token.match(INTERPOLATION_SYNTAX_PATTERN)) ? handle_interpolation_token(token, matchdata) : escape_plain_str(token)
-          end.join
-        end
-
-        def handle_interpolation_token(interpolation, matchdata)
-          escaped, pattern, key = matchdata.values_at(1, 2, 3)
-          escaped ? pattern : compile_interpolation_token(key.to_sym)
-        end
-
-        def compile_interpolation_token(key)
-          "\#{#{interpolate_or_raise_missing(key)}}"
-        end
-
-        def interpolate_or_raise_missing(key)
-          escaped_key = escape_key_sym(key)
-          Base::RESERVED_KEYS.include?(key) ? reserved_key(escaped_key) : interpolate_key(escaped_key)
-        end
-
-        def interpolate_key(key)
-          [direct_key(key), nil_key(key), missing_key(key)].join('||')
-        end
-
-        def direct_key(key)
-          "((t = v[#{key}]) && t.respond_to?(:call) ? t.call : t)"
-        end
-
-        def nil_key(key)
-          "(v.has_key?(#{key}) && '')"
-        end
-
-        def missing_key(key)
-          "raise(MissingInterpolationArgument.new(#{key}, self))"
-        end
-
-        def reserved_key(key)
-          "raise(ReservedInterpolationKey.new(#{key}, self))"
-        end
-
-        def escape_plain_str(str)
-          str.gsub(/"|\\|#/) {|x| "\\#{x}"}
-        end
-
-        def escape_key_sym(key)
-          # rely on Ruby to do all the hard work :)
-          key.to_sym.inspect
-        end
-      end
-
-      def interpolate(locale, string, values)
-        if string.respond_to?(:i18n_interpolate)
-          string.i18n_interpolate(values)
-        elsif values
-          super
-        else
-          string
-        end
-      end
-
-      def merge_translations(locale, data, options = {})
-        compile_all_strings_in(data)
-        super
-      end
-
-      protected
-      def compile_all_strings_in(data)
-        data.each_value do |value|
-          Compiler.compile_if_an_interpolation(value)
-          compile_all_strings_in(value) if value.kind_of?(Hash)
-        end
-      end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/links.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/links.rb
deleted file mode 100644
index 5f99bc8..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/links.rb
+++ /dev/null
@@ -1,34 +0,0 @@
-module I18n
-  module Backend
-    module Links
-      protected
-        def links(locale)
-          @links ||= {}
-          @links[locale.to_sym] ||= {}
-        end
-
-        def store_link(locale, key, link)
-          links(locale)[key.to_s] = link.to_s
-        end
-
-        def resolve_link(locale, key)
-          key   = key.to_s
-          links = self.links(locale)
-
-          if links.key?(key)
-            links[key]
-          elsif link = find_link(locale, key)
-            store_link(locale, key, key.gsub(*link))
-          else
-            key
-          end
-        end
-
-        def find_link(locale, key)
-          links(locale).each do |from, to|
-            return [from, to] if key[0, from.length] == from
-          end && nil
-        end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/metadata.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/metadata.rb
deleted file mode 100644
index 3ebb8af..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/metadata.rb
+++ /dev/null
@@ -1,73 +0,0 @@
-# I18n translation metadata is useful when you want to access information
-# about how a translation was looked up, pluralized or interpolated in
-# your application.
-#
-#   msg = I18n.t(:message, :default => 'Hi!', :scope => :foo)
-#   msg.translation_metadata
-#   # => { :key => :message, :scope => :foo, :default => 'Hi!' }
-#
-# If a :count option was passed to #translate it will be set to the metadata.
-# Likewise, if any interpolation variables were passed they will also be set.
-#
-# To enable translation metadata you can simply include the Metadata module
-# into the Simple backend class - or whatever other backend you are using:
-#
-#   I18n::Backend::Simple.send(:include, I18n::Backend::Metadata)
-
-require 'i18n/core_ext/object/meta_class'
-
-module I18n
-  module Backend
-    module Metadata
-      class << self
-        def included(base)
-          Object.class_eval do
-            def translation_metadata
-              @translation_metadata ||= {}
-            end
-
-            def translation_metadata=(translation_metadata)
-              @translation_metadata = translation_metadata
-            end
-          end
-        end
-      end
-
-      def translate(locale, key, options = {})
-        metadata = {
-          :locale    => locale,
-          :key       => key,
-          :scope     => options[:scope],
-          :default   => options[:default],
-          :separator => options[:separator],
-          :values    => options.reject { |name, value| Base::RESERVED_KEYS.include?(name) }
-        }
-        with_metadata(metadata) { super }
-      end
-
-      def interpolate(locale, string, values = {})
-        with_metadata(:original => string) do
-          preserve_translation_metadata(string) { super }
-        end if string
-      end
-
-      def pluralize(locale, entry, count)
-        with_metadata(:count => count) { super }
-      end
-
-      protected
-
-        def with_metadata(metadata, &block)
-          result = yield
-          result.translation_metadata = result.translation_metadata.merge(metadata) if result
-          result
-        end
-
-        def preserve_translation_metadata(object, &block)
-          result = yield
-          result.translation_metadata = object.translation_metadata if result
-          result
-        end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/pluralization.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/pluralization.rb
deleted file mode 100644
index 33a2aff..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/pluralization.rb
+++ /dev/null
@@ -1,57 +0,0 @@
-# encoding: utf-8
-
-# I18n locale fallbacks are useful when you want your application to use
-# translations from other locales when translations for the current locale are
-# missing. E.g. you might want to use :en translations when translations in
-# your applications main locale :de are missing.
-#
-# To enable locale specific pluralizations you can simply include the
-# Pluralization module to the Simple backend - or whatever other backend you
-# are using.
-#
-#   I18n::Backend::Simple.send(:include, I18n::Backend::Pluralization)
-#
-# You also need to make sure to provide pluralization algorithms to the
-# backend, i.e. include them to your I18n.load_path accordingly.
-module I18n
-  module Backend
-    module Pluralization
-      # Overwrites the Base backend translate method so that it will check the
-      # translation meta data space (:i18n) for a locale specific pluralization
-      # rule and use it to pluralize the given entry. I.e. the library expects
-      # pluralization rules to be stored at I18n.t(:'i18n.plural.rule')
-      #
-      # Pluralization rules are expected to respond to #call(entry, count) and
-      # return a pluralization key. Valid keys depend on the translation data
-      # hash (entry) but it is generally recommended to follow CLDR's style,
-      # i.e., return one of the keys :zero, :one, :few, :many, :other.
-      #
-      # The :zero key is always picked directly when count equals 0 AND the
-      # translation data has the key :zero. This way translators are free to
-      # either pick a special :zero translation even for languages where the
-      # pluralizer does not return a :zero key.
-      def pluralize(locale, entry, count)
-        return entry unless entry.is_a?(Hash) and count
-
-        pluralizer = pluralizer(locale)
-        if pluralizer.respond_to?(:call)
-          key = count == 0 && entry.has_key?(:zero) ? :zero : pluralizer.call(count)
-          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
-          entry[key]
-        else
-          super
-        end
-      end
-
-      protected
-
-        def pluralizers
-          @pluralizers ||= {}
-        end
-
-        def pluralizer(locale)
-          pluralizers[locale] ||= I18n.t(:'i18n.plural.rule', :locale => locale, :resolve => false)
-        end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/simple.rb
deleted file mode 100644
index 1454a10..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/simple.rb
+++ /dev/null
@@ -1,22 +0,0 @@
-# encoding: utf-8
-
-# Stub class for the Simple backend. The actual implementation is provided by
-# the backend Base class. This makes it easier to extend the Simple backend's
-# behaviour by including modules. E.g.:
-#
-# module I18n::Backend::Pluralization
-#   def pluralize(*args)
-#     # extended pluralization logic
-#     super
-#   end
-# end
-#
-# I18n::Backend::Simple.send(:include, I18n::Backend::Pluralization)
-
-module I18n
-  module Backend
-    class Simple
-      include Base
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/except.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/except.rb
deleted file mode 100644
index a228148..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/except.rb
+++ /dev/null
@@ -1,8 +0,0 @@
-# from facets (http://facets.rubyforge.org)
-require 'i18n/core_ext/hash/slice'
-
-class Hash
-  def except(*less_keys)
-    slice(*keys - less_keys)
-  end
-end unless Hash.method_defined?(:except)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/slice.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/slice.rb
deleted file mode 100644
index 90e5168..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/hash/slice.rb
+++ /dev/null
@@ -1,8 +0,0 @@
-# from facets (http://facets.rubyforge.org)
-class Hash
-  def slice(*keep_keys)
-    h = {}
-    keep_keys.each { |key| h[key] = fetch(key) }
-    h
-  end
-end unless Hash.new.respond_to?(:slice)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/object/meta_class.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/object/meta_class.rb
deleted file mode 100644
index e6d51f7..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/object/meta_class.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-Object.class_eval do
-  def meta_class
-    class << self; self; end
-  end
-end unless Object.method_defined?(:meta_class)
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/string/interpolate.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/string/interpolate.rb
deleted file mode 100644
index 94b1a36..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/core_ext/string/interpolate.rb
+++ /dev/null
@@ -1,99 +0,0 @@
-# encoding: utf-8
-
-=begin
-  heavily based on Masao Mutoh's gettext String interpolation extension
-  http://github.com/mutoh/gettext/blob/f6566738b981fe0952548c421042ad1e0cdfb31e/lib/gettext/core_ext/string.rb
-  Copyright (C) 2005-2009 Masao Mutoh
-  You may redistribute it and/or modify it under the same license terms as Ruby.
-=end
-
-if RUBY_VERSION < '1.9'
-
-  # KeyError is raised by String#% when the string contains a named placeholder
-  # that is not contained in the given arguments hash. Ruby 1.9 includes and
-  # raises this exception natively. We define it to mimic Ruby 1.9's behaviour
-  # in Ruby 1.8.x
-
-  class KeyError < IndexError
-    def initialize(message = nil)
-      super(message || "key not found")
-    end
-  end unless defined?(KeyError)
-
-  # Extension for String class. This feature is included in Ruby 1.9 or later but not occur TypeError.
-  #
-  # String#% method which accept "named argument". The translator can know
-  # the meaning of the msgids using "named argument" instead of %s/%d style.
-
-  class String
-    # For older ruby versions, such as ruby-1.8.5
-    alias :bytesize :size unless instance_methods.find {|m| m.to_s == 'bytesize'}
-    alias :interpolate_without_ruby_19_syntax :% # :nodoc:
-
-    INTERPOLATION_PATTERN = Regexp.union(
-      /%\{(\w+)\}/,                               # matches placeholders like "%{foo}"
-      /%<(\w+)>(.*?\d*\.?\d*[bBdiouxXeEfgGcps])/  # matches placeholders like "%<foo>.d"
-    )
-
-    INTERPOLATION_PATTERN_WITH_ESCAPE = Regexp.union(
-      /%%/,
-      INTERPOLATION_PATTERN
-    )
-
-    # % uses self (i.e. the String) as a format specification and returns the
-    # result of applying it to the given arguments. In other words it interpolates
-    # the given arguments to the string according to the formats the string
-    # defines.
-    #
-    # There are three ways to use it:
-    #
-    # * Using a single argument or Array of arguments.
-    #
-    #   This is the default behaviour of the String class. See Kernel#sprintf for
-    #   more details about the format string.
-    #
-    #   Example:
-    #
-    #     "%d %s" % [1, "message"]
-    #     # => "1 message"
-    #
-    # * Using a Hash as an argument and unformatted, named placeholders.
-    #
-    #   When you pass a Hash as an argument and specify placeholders with %{foo}
-    #   it will interpret the hash values as named arguments.
-    #
-    #   Example:
-    #
-    #     "%{firstname}, %{lastname}" % {:firstname => "Masao", :lastname => "Mutoh"}
-    #     # => "Masao Mutoh"
-    #
-    # * Using a Hash as an argument and formatted, named placeholders.
-    #
-    #   When you pass a Hash as an argument and specify placeholders with %<foo>d
-    #   it will interpret the hash values as named arguments and format the value
-    #   according to the formatting instruction appended to the closing >.
-    #
-    #   Example:
-    #
-    #     "%<integer>d, %<float>.1f" % { :integer => 10, :float => 43.4 }
-    #     # => "10, 43.3"
-    def %(args)
-      if args.kind_of?(Hash)
-        dup.gsub(INTERPOLATION_PATTERN_WITH_ESCAPE) do |match|
-          if match == '%%'
-            '%'
-          else
-            key = ($1 || $2).to_sym
-            raise KeyError unless args.has_key?(key)
-            $3 ? sprintf("%#{$3}", args[key]) : args[key]
-          end
-        end
-      elsif self =~ INTERPOLATION_PATTERN
-        raise ArgumentError.new('one hash required')
-      else
-        result = gsub(/%([{<])/, '%%\1')
-        result.send :'interpolate_without_ruby_19_syntax', args
-      end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/exceptions.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/exceptions.rb
deleted file mode 100644
index 766a171..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/exceptions.rb
+++ /dev/null
@@ -1,61 +0,0 @@
-# encoding: utf-8
-
-class KeyError < IndexError
-  def initialize(message = nil)
-    super(message || "key not found")
-  end
-end unless defined?(KeyError)
-
-module I18n
-  class ArgumentError < ::ArgumentError; end
-
-  class InvalidLocale < ArgumentError
-    attr_reader :locale
-    def initialize(locale)
-      @locale = locale
-      super "#{locale.inspect} is not a valid locale"
-    end
-  end
-
-  class MissingTranslationData < ArgumentError
-    attr_reader :locale, :key, :options
-    def initialize(locale, key, opts = nil)
-      @key, @locale, @options = key, locale, opts || {}
-      keys = I18n.normalize_keys(locale, key, options[:scope])
-      keys << 'no key' if keys.size < 2
-      super "translation missing: #{keys.join(', ')}"
-    end
-  end
-
-  class InvalidPluralizationData < ArgumentError
-    attr_reader :entry, :count
-    def initialize(entry, count)
-      @entry, @count = entry, count
-      super "translation data #{entry.inspect} can not be used with :count => #{count}"
-    end
-  end
-
-  class MissingInterpolationArgument < ArgumentError
-    attr_reader :values, :string
-    def initialize(values, string)
-      @values, @string = values, string
-      super "missing interpolation argument in #{string.inspect} (#{values.inspect} given)"
-    end
-  end
-
-  class ReservedInterpolationKey < ArgumentError
-    attr_reader :key, :string
-    def initialize(key, string)
-      @key, @string = key, string
-      super "reserved key #{key.inspect} used in #{string.inspect}"
-    end
-  end
-
-  class UnknownFileType < ArgumentError
-    attr_reader :type, :filename
-    def initialize(type, filename)
-      @type, @filename = type, filename
-      super "can not load translations from #{filename}, the file type #{type} is not known"
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext.rb
deleted file mode 100644
index b8dec6e..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext.rb
+++ /dev/null
@@ -1,25 +0,0 @@
-# encoding: utf-8
-
-module I18n
-  module Gettext
-    PLURAL_SEPARATOR  = "\001"
-    CONTEXT_SEPARATOR = "\004"
-
-    @@plural_keys = { :en => [:one, :other] }
-
-    class << self
-      # returns an array of plural keys for the given locale so that we can
-      # convert from gettext's integer-index based style
-      # TODO move this information to the pluralization module
-      def plural_keys(locale)
-        @@plural_keys[locale] || @@plural_keys[:en]
-      end
-
-      def extract_scope(msgid, separator)
-        scope = msgid.to_s.split(separator)
-        msgid = scope.pop
-        [scope, msgid]
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext/po_parser.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext/po_parser.rb
deleted file mode 100644
index 547df6a..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/gettext/po_parser.rb
+++ /dev/null
@@ -1,329 +0,0 @@
-=begin
-  poparser.rb - Generate a .mo
-
-  Copyright (C) 2003-2009 Masao Mutoh <mutoh at highway.ne.jp>
-
-  You may redistribute it and/or modify it under the same
-  license terms as Ruby.
-=end
-
-#MODIFIED
-# removed include GetText etc
-# added stub translation method _(x)
-require 'racc/parser'
-
-module GetText
-
-  class PoParser < Racc::Parser
-
-    def _(x)
-      x
-    end
-
-module_eval <<'..end src/poparser.ry modeval..id7a99570e05', 'src/poparser.ry', 108
-  def unescape(orig)
-    ret = orig.gsub(/\\n/, "\n")
-    ret.gsub!(/\\t/, "\t")
-    ret.gsub!(/\\r/, "\r")
-    ret.gsub!(/\\"/, "\"")
-    ret
-  end
-  
-  def parse(str, data, ignore_fuzzy = true)
-    @comments = []
-    @data = data
-    @fuzzy = false
-    @msgctxt = ""
-    $ignore_fuzzy = ignore_fuzzy
-
-    str.strip!
-    @q = []
-    until str.empty? do
-      case str
-      when /\A\s+/
-	str = $'
-      when /\Amsgctxt/
-	@q.push [:MSGCTXT, $&]
-	str = $'
-      when /\Amsgid_plural/
-	@q.push [:MSGID_PLURAL, $&]
-	str = $'
-      when /\Amsgid/
-	@q.push [:MSGID, $&]
-	str = $'
-      when /\Amsgstr/
-	@q.push [:MSGSTR, $&]
-	str = $'
-      when /\A\[(\d+)\]/
-	@q.push [:PLURAL_NUM, $1]
-	str = $'
-      when /\A\#~(.*)/
-	$stderr.print _("Warning: obsolete msgid exists.\n")
-	$stderr.print "         #{$&}\n"
-	@q.push [:COMMENT, $&]
-	str = $'
-      when /\A\#(.*)/
-	@q.push [:COMMENT, $&]
-	str = $'      
-      when /\A\"(.*)\"/
-	@q.push [:STRING, $1]
-	str = $'
-      else
-	#c = str[0,1]
-	#@q.push [:STRING, c]
-	str = str[1..-1]
-      end
-    end 
-    @q.push [false, '$end']
-    if $DEBUG
-      @q.each do |a,b|
-      puts "[#{a}, #{b}]"
-      end
-    end
-    @yydebug = true if $DEBUG
-    do_parse
-
-    if @comments.size > 0
-      @data.set_comment(:last, @comments.join("\n"))
-    end
-    @data
-  end
-  
-  def next_token
-    @q.shift
-  end
-
-  def on_message(msgid, msgstr)
-    if msgstr.size > 0
-      @data[msgid] = msgstr
-      @data.set_comment(msgid, @comments.join("\n"))
-    end
-    @comments.clear
-    @msgctxt = ""
-  end
-      
-  def on_comment(comment)
-    @fuzzy = true if (/fuzzy/ =~ comment)
-    @comments << comment
-  end 
-
-
-..end src/poparser.ry modeval..id7a99570e05
-
-##### racc 1.4.5 generates ###
-
-racc_reduce_table = [
- 0, 0, :racc_error,
- 0, 10, :_reduce_none,
- 2, 10, :_reduce_none,
- 2, 10, :_reduce_none,
- 2, 10, :_reduce_none,
- 2, 12, :_reduce_5,
- 1, 13, :_reduce_none,
- 1, 13, :_reduce_none,
- 4, 15, :_reduce_8,
- 5, 16, :_reduce_9,
- 2, 17, :_reduce_10,
- 1, 17, :_reduce_none,
- 3, 18, :_reduce_12,
- 1, 11, :_reduce_13,
- 2, 14, :_reduce_14,
- 1, 14, :_reduce_15 ]
-
-racc_reduce_n = 16
-
-racc_shift_n = 26
-
-racc_action_table = [
-     3,    13,     5,     7,     9,    15,    16,    17,    20,    17,
-    13,    17,    13,    13,    11,    17,    23,    20,    13,    17 ]
-
-racc_action_check = [
-     1,    16,     1,     1,     1,    12,    12,    12,    18,    18,
-     7,    14,    15,     9,     3,    19,    20,    21,    23,    25 ]
-
-racc_action_pointer = [
-   nil,     0,   nil,    14,   nil,   nil,   nil,     3,   nil,     6,
-   nil,   nil,     0,   nil,     4,     5,    -6,   nil,     2,     8,
-     8,    11,   nil,    11,   nil,    12 ]
-
-racc_action_default = [
-    -1,   -16,    -2,   -16,    -3,   -13,    -4,   -16,    -6,   -16,
-    -7,    26,   -16,   -15,    -5,   -16,   -16,   -14,   -16,    -8,
-   -16,    -9,   -11,   -16,   -10,   -12 ]
-
-racc_goto_table = [
-    12,    22,    14,     4,    24,     6,     2,     8,    18,    19,
-    10,    21,     1,   nil,   nil,   nil,    25 ]
-
-racc_goto_check = [
-     5,     9,     5,     3,     9,     4,     2,     6,     5,     5,
-     7,     8,     1,   nil,   nil,   nil,     5 ]
-
-racc_goto_pointer = [
-   nil,    12,     5,     2,     4,    -7,     6,     9,    -7,   -17 ]
-
-racc_goto_default = [
-   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil ]
-
-racc_token_table = {
- false => 0,
- Object.new => 1,
- :COMMENT => 2,
- :MSGID => 3,
- :MSGCTXT => 4,
- :MSGID_PLURAL => 5,
- :MSGSTR => 6,
- :STRING => 7,
- :PLURAL_NUM => 8 }
-
-racc_use_result_var = true
-
-racc_nt_base = 9
-
-Racc_arg = [
- racc_action_table,
- racc_action_check,
- racc_action_default,
- racc_action_pointer,
- racc_goto_table,
- racc_goto_check,
- racc_goto_default,
- racc_goto_pointer,
- racc_nt_base,
- racc_reduce_table,
- racc_token_table,
- racc_shift_n,
- racc_reduce_n,
- racc_use_result_var ]
-
-Racc_token_to_s_table = [
-'$end',
-'error',
-'COMMENT',
-'MSGID',
-'MSGCTXT',
-'MSGID_PLURAL',
-'MSGSTR',
-'STRING',
-'PLURAL_NUM',
-'$start',
-'msgfmt',
-'comment',
-'msgctxt',
-'message',
-'string_list',
-'single_message',
-'plural_message',
-'msgstr_plural',
-'msgstr_plural_line']
-
-Racc_debug_parser = true
-
-##### racc system variables end #####
-
- # reduce 0 omitted
-
- # reduce 1 omitted
-
- # reduce 2 omitted
-
- # reduce 3 omitted
-
- # reduce 4 omitted
-
-module_eval <<'.,.,', 'src/poparser.ry', 25
-  def _reduce_5( val, _values, result )
-    @msgctxt = unescape(val[1]) + "\004"
-   result
-  end
-.,.,
-
- # reduce 6 omitted
-
- # reduce 7 omitted
-
-module_eval <<'.,.,', 'src/poparser.ry', 48
-  def _reduce_8( val, _values, result )
-    if @fuzzy and $ignore_fuzzy 
-      if val[1] != ""
-        $stderr.print _("Warning: fuzzy message was ignored.\n")
-        $stderr.print "         msgid '#{val[1]}'\n"
-      else
-        on_message('', unescape(val[3]))
-      end
-      @fuzzy = false
-    else
-      on_message(@msgctxt + unescape(val[1]), unescape(val[3]))
-    end
-    result = ""
-   result
-  end
-.,.,
-
-module_eval <<'.,.,', 'src/poparser.ry', 65
-  def _reduce_9( val, _values, result )
-    if @fuzzy and $ignore_fuzzy
-      if val[1] != ""
-        $stderr.print _("Warning: fuzzy message was ignored.\n")
-        $stderr.print "msgid = '#{val[1]}\n"
-      else
-        on_message('', unescape(val[3]))
-      end
-      @fuzzy = false
-    else
-      on_message(@msgctxt + unescape(val[1]) + "\000" + unescape(val[3]), unescape(val[4]))
-    end
-    result = ""
-   result
-  end
-.,.,
-
-module_eval <<'.,.,', 'src/poparser.ry', 76
-  def _reduce_10( val, _values, result )
-    if val[0].size > 0
-      result = val[0] + "\000" + val[1]
-    else
-      result = ""
-    end
-   result
-  end
-.,.,
-
- # reduce 11 omitted
-
-module_eval <<'.,.,', 'src/poparser.ry', 84
-  def _reduce_12( val, _values, result )
-    result = val[2]
-   result
-  end
-.,.,
-
-module_eval <<'.,.,', 'src/poparser.ry', 91
-  def _reduce_13( val, _values, result )
-    on_comment(val[0])
-   result
-  end
-.,.,
-
-module_eval <<'.,.,', 'src/poparser.ry', 99
-  def _reduce_14( val, _values, result )
-    result = val.delete_if{|item| item == ""}.join
-   result
-  end
-.,.,
-
-module_eval <<'.,.,', 'src/poparser.ry', 103
-  def _reduce_15( val, _values, result )
-    result = val[0]
-   result
-  end
-.,.,
-
- def _reduce_none( val, _values, result )
-  result
- end
-
-  end   # class PoParser
-
-end   # module GetText
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers.rb
deleted file mode 100644
index 8bbe02e..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-module I18n
-  module Helpers
-    autoload :Gettext, 'i18n/helpers/gettext'
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers/gettext.rb
deleted file mode 100644
index 8285805..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/helpers/gettext.rb
+++ /dev/null
@@ -1,65 +0,0 @@
-# encoding: utf-8
-require 'i18n/gettext'
-
-module I18n
-  module Helpers
-    # Implements classical Gettext style accessors. To use this include the
-    # module to the global namespace or wherever you want to use it.
-    #
-    #   include I18n::Helpers::Gettext
-    module Gettext
-      def gettext(msgid, options = {})
-        I18n.t(msgid, { :default => msgid, :separator => '|' }.merge(options))
-      end
-      alias _ gettext
-
-      def sgettext(msgid, separator = '|')
-        scope, msgid = I18n::Gettext.extract_scope(msgid, separator)
-        I18n.t(msgid, :scope => scope, :default => msgid, :separator => separator)
-      end
-      alias s_ sgettext
-
-      def pgettext(msgctxt, msgid)
-        separator = I18n::Gettext::CONTEXT_SEPARATOR
-        sgettext([msgctxt, msgid].join(separator), separator)
-      end
-      alias p_ pgettext
-
-      def ngettext(msgid, msgid_plural, n = 1)
-        nsgettext(msgid, msgid_plural, n)
-      end
-      alias n_ ngettext
-
-      # Method signatures:
-      #   nsgettext('Fruits|apple', 'apples', 2)
-      #   nsgettext(['Fruits|apple', 'apples'], 2)
-      def nsgettext(msgid, msgid_plural, n = 1, separator = '|')
-        if msgid.is_a?(Array)
-          msgid, msgid_plural, n, separator = msgid[0], msgid[1], msgid_plural, n
-          separator = '|' unless separator.is_a?(::String)
-        end
-
-        scope, msgid = I18n::Gettext.extract_scope(msgid, separator)
-        default = { :one => msgid, :other => msgid_plural }
-        I18n.t(msgid, :default => default, :count => n, :scope => scope, :separator => separator)
-      end
-      alias ns_ nsgettext
-
-      # Method signatures:
-      #   npgettext('Fruits', 'apple', 'apples', 2)
-      #   npgettext('Fruits', ['apple', 'apples'], 2)
-      def npgettext(msgctxt, msgid, msgid_plural, n = 1)
-        separator = I18n::Gettext::CONTEXT_SEPARATOR
-
-        if msgid.is_a?(Array)
-          msgid_plural, msgid, n = msgid[1], [msgctxt, msgid[0]].join(separator), msgid_plural
-        else
-          msgid = [msgctxt, msgid].join(separator)
-        end
-
-        nsgettext(msgid, msgid_plural, n, separator)
-      end
-      alias np_ npgettext
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale.rb
deleted file mode 100644
index 4f9d026..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale.rb
+++ /dev/null
@@ -1,6 +0,0 @@
-module I18n
-  module Locale
-  autoload :Fallbacks, 'i18n/locale/fallbacks'
-  autoload :Tag,       'i18n/locale/tag'
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/fallbacks.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/fallbacks.rb
deleted file mode 100644
index 11dcf8c..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/fallbacks.rb
+++ /dev/null
@@ -1,98 +0,0 @@
-# encoding: utf-8
-
-# Locale Fallbacks
-#
-# Extends the I18n module to hold a fallbacks instance which is set to an
-# instance of I18n::Locale::Fallbacks by default but can be swapped with a
-# different implementation.
-#
-# Locale fallbacks will compute a number of fallback locales for a given locale.
-# For example:
-#
-# <pre><code>
-# I18n.fallbacks[:"es-MX"] # => [:"es-MX", :es, :en] </code></pre>
-#
-# Locale fallbacks always fall back to
-#
-#   * all parent locales of a given locale (e.g. :es for :"es-MX") first,
-#   * the current default locales and all of their parents second
-#
-# The default locales are set to [I18n.default_locale] by default but can be
-# set to something else.
-#
-# One can additionally add any number of additional fallback locales manually.
-# These will be added before the default locales to the fallback chain. For
-# example:
-#
-#   # using the default locale as default fallback locale
-#
-#   I18n.default_locale = :"en-US"
-#   I18n.fallbacks = I18n::Fallbacks.new(:"de-AT" => :"de-DE")
-#   I18n.fallbacks[:"de-AT"] # => [:"de-AT", :"de-DE", :de, :"en-US", :en]
-#
-#   # using a custom locale as default fallback locale
-#
-#   I18n.fallbacks = I18n::Fallbacks.new(:"en-GB", :"de-AT" => :de, :"de-CH" => :de)
-#   I18n.fallbacks[:"de-AT"] # => [:"de-AT", :de, :"en-GB", :en]
-#   I18n.fallbacks[:"de-CH"] # => [:"de-CH", :de, :"en-GB", :en]
-#
-#   # mapping fallbacks to an existing instance
-#
-#   # people speaking Catalan also speak Spanish as spoken in Spain
-#   fallbacks = I18n.fallbacks
-#   fallbacks.map(:ca => :"es-ES")
-#   fallbacks[:ca] # => [:ca, :"es-ES", :es, :"en-US", :en]
-#
-#   # people speaking Arabian as spoken in Palestine also speak Hebrew as spoken in Israel
-#   fallbacks.map(:"ar-PS" => :"he-IL")
-#   fallbacks[:"ar-PS"] # => [:"ar-PS", :ar, :"he-IL", :he, :"en-US", :en]
-#   fallbacks[:"ar-EG"] # => [:"ar-EG", :ar, :"en-US", :en]
-#
-#   # people speaking Sami as spoken in Finnland also speak Swedish and Finnish as spoken in Finnland
-#   fallbacks.map(:sms => [:"se-FI", :"fi-FI"])
-#   fallbacks[:sms] # => [:sms, :"se-FI", :se, :"fi-FI", :fi, :"en-US", :en]
-
-module I18n
-  module Locale
-    class Fallbacks < Hash
-      def initialize(*mappings)
-        @map = {}
-        map(mappings.pop) if mappings.last.is_a?(Hash)
-        self.defaults = mappings.empty? ? [I18n.default_locale.to_sym] : mappings
-      end
-
-      def defaults=(defaults)
-        @defaults = defaults.map { |default| compute(default, false) }.flatten
-      end
-      attr_reader :defaults
-
-      def [](locale)
-        raise InvalidLocale.new(locale) if locale.nil?
-        locale = locale.to_sym
-        super || store(locale, compute(locale))
-      end
-
-      def map(mappings)
-        mappings.each do |from, to|
-          from, to = from.to_sym, Array(to)
-          to.each do |to|
-            @map[from] ||= []
-            @map[from] << to.to_sym
-          end
-        end
-      end
-
-      protected
-
-      def compute(tags, include_defaults = true)
-        result = Array(tags).collect do |tag|
-          tags = I18n::Locale::Tag.tag(tag).self_and_parents.map! { |t| t.to_sym }
-          tags.each { |tag| tags += compute(@map[tag]) if @map[tag] }
-          tags
-        end.flatten
-        result.push(*defaults) if include_defaults
-        result.uniq
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag.rb
deleted file mode 100644
index a640b44..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag.rb
+++ /dev/null
@@ -1,28 +0,0 @@
-# encoding: utf-8
-
-module I18n
-  module Locale
-    module Tag
-      autoload :Parents, 'i18n/locale/tag/parents'
-      autoload :Rfc4646, 'i18n/locale/tag/rfc4646'
-      autoload :Simple,  'i18n/locale/tag/simple'
-
-      class << self
-        # Returns the current locale tag implementation. Defaults to +I18n::Locale::Tag::Simple+.
-        def implementation
-          @@implementation ||= Simple
-        end
-
-        # Sets the current locale tag implementation. Use this to set a different locale tag implementation.
-        def implementation=(implementation)
-          @@implementation = implementation
-        end
-
-        # Factory method for locale tags. Delegates to the current locale tag implementation.
-        def tag(tag)
-          implementation.tag(tag)
-        end
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/parents.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/parents.rb
deleted file mode 100644
index a094468..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/parents.rb
+++ /dev/null
@@ -1,24 +0,0 @@
-# encoding: utf-8
-
-module I18n
-  module Locale
-    module Tag
-      module Parents
-        def parent
-          @parent ||= begin
-            segs = to_a.compact
-            segs.length > 1 ? self.class.tag(*segs[0..(segs.length-2)].join('-')) : nil
-          end
-        end
-
-        def self_and_parents
-          @self_and_parents ||= [self] + parents
-        end
-
-        def parents
-          @parents ||= ([parent] + (parent ? parent.parents : [])).compact
-        end
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/rfc4646.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/rfc4646.rb
deleted file mode 100644
index c20d35a..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/rfc4646.rb
+++ /dev/null
@@ -1,76 +0,0 @@
-# encoding: utf-8
-
-# RFC 4646/47 compliant Locale tag implementation that parses locale tags to
-# subtags such as language, script, region, variant etc.
-#
-# For more information see by http://en.wikipedia.org/wiki/IETF_language_tag
-#
-# Rfc4646::Parser does not implement grandfathered tags.
-
-module I18n
-  module Locale
-    module Tag
-      RFC4646_SUBTAGS = [ :language, :script, :region, :variant, :extension, :privateuse, :grandfathered ]
-      RFC4646_FORMATS = { :language => :downcase, :script => :capitalize, :region => :upcase, :variant => :downcase }
-
-      class Rfc4646 < Struct.new(*RFC4646_SUBTAGS)
-        class << self
-          # Parses the given tag and returns a Tag instance if it is valid.
-          # Returns false if the given tag is not valid according to RFC 4646.
-          def tag(tag)
-            matches = parser.match(tag)
-            new(*matches) if matches
-          end
-
-          def parser
-            @@parser ||= Rfc4646::Parser
-          end
-
-          def parser=(parser)
-            @@parser = parser
-          end
-        end
-
-        include Parents
-
-        RFC4646_FORMATS.each do |name, format|
-          define_method(name) { self[name].send(format) unless self[name].nil? }
-        end
-
-        def to_sym
-          to_s.to_sym
-        end
-
-        def to_s
-          @tag ||= to_a.compact.join("-")
-        end
-
-        def to_a
-          members.collect { |attr| self.send(attr) }
-        end
-
-        module Parser
-          PATTERN = %r{\A(?:
-            ([a-z]{2,3}(?:(?:-[a-z]{3}){0,3})?|[a-z]{4}|[a-z]{5,8}) # language
-            (?:-([a-z]{4}))?                                        # script
-            (?:-([a-z]{2}|\d{3}))?                                  # region
-            (?:-([0-9a-z]{5,8}|\d[0-9a-z]{3}))*                     # variant
-            (?:-([0-9a-wyz](?:-[0-9a-z]{2,8})+))*                   # extension
-            (?:-(x(?:-[0-9a-z]{1,8})+))?|                           # privateuse subtag
-            (x(?:-[0-9a-z]{1,8})+)|                                 # privateuse tag
-            /* ([a-z]{1,3}(?:-[0-9a-z]{2,8}){1,2}) */               # grandfathered
-            )\z}xi
-
-          class << self
-            def match(tag)
-              c = PATTERN.match(tag.to_s).captures
-              c[0..4] << (c[5].nil? ? c[6] : c[5])  << c[7] # TODO c[7] is grandfathered, throw a NotImplemented exception here?
-            rescue
-              false
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/simple.rb
deleted file mode 100644
index 0fddb36..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/locale/tag/simple.rb
+++ /dev/null
@@ -1,41 +0,0 @@
-# encoding: utf-8
-
-# Simple Locale tag implementation that computes subtags by simply splitting
-# the locale tag at '-' occurences.
-module I18n
-  module Locale
-    module Tag
-      class Simple
-        class << self
-          def tag(tag)
-            new(tag)
-          end
-        end
-
-        include Parents
-
-        attr_reader :tag
-
-        def initialize(*tag)
-          @tag = tag.join('-').to_sym
-        end
-
-        def subtags
-          @subtags = tag.to_s.split('-').map { |subtag| subtag.to_s }
-        end
-
-        def to_sym
-          tag
-        end
-
-        def to_s
-          tag.to_s
-        end
-
-        def to_a
-          subtags
-        end
-      end
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/version.rb b/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/version.rb
deleted file mode 100644
index 354f07b..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/version.rb
+++ /dev/null
@@ -1,3 +0,0 @@
-module I18n
-  VERSION = "0.3.7"
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/CHANGELOG.textile b/activesupport/lib/active_support/vendor/i18n-0.4.1/CHANGELOG.textile
new file mode 100644
index 0000000..2a7f4d2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/CHANGELOG.textile
@@ -0,0 +1,135 @@
+h1. Changelog
+
+h2. master
+
+h2. 0.4.0 (2010-05-27)
+
+* "The localization proc also receives the object as option":http://github.com/svenfuchs/i18n/commit/4a8cd9fa660daaa3078e24c5851353ca377d9213
+
+h2. 0.4.0.beta1 (2010-05-03)
+
+* "Renamed Fast backend to Memoize backend":http://github.com/svenfuchs/i18n/commit/f7f7dc12c00a19d3876223771e14f8671ff313cd
+
+* "Deprecate {{}} as interpolation syntax":http://github.com/svenfuchs/i18n/commit/8894ee521ef5788c415b625a6daf522af4c416e0
+
+* "Allow nil translation to be stored again":http://github.com/svenfuchs/i18n/commit/f2074f1e82d10c2e9a801c8cc2f2a0c7c30703ba
+
+h2. 0.4.0.beta (2010-04-30)
+
+* "Added a KeyValue backend":http://github.com/svenfuchs/i18n/commit/28ca5f53ade7f545f8c0804e93564d4686b416a4
+
+* "Added transliteration support":http://github.com/svenfuchs/i18n/commit/928fdb4794959e779e90f360eb01ba043672d8d5
+
+* "Create Flatten backend module to aid handling flatten translations":http://github.com/svenfuchs/i18n/commit/2ec9d6998aa8facd7b15a3ef47a96cf2471cd8a1
+
+* "Decouple the external separator (used when storing translations) from the internal separator in Fast and ActiveRecord backends":http://github.com/svenfuchs/i18n/commit/274cb4daa0ca5e3b2bd23b45eb7f9fc58f75a79d
+
+h2. 0.3.7 (2010-04-17)
+
+* "Speed up I18n.normalize_keys by caching reused normalizations and producing less garbage":http://github.com/svenfuchs/i18n/commit/819dac0fea9c29e6545801aa107e63e355728cd4
+
+h2. 0.3.6 (2010-03-23)
+
+* "Move gettext po parser to lib":http://github.com/svenfuchs/i18n/commit/b2f038663b55727ac2327e6f07a46ba5d69d600c
+
+* "Move I18n configuration to I18n.config":http://github.com/svenfuchs/i18n/commit/4a7baea86663ead8c681008c3e80a622f0546b07
+
+h2. 0.3.5 (2010-02-26)
+
+* "Delegate I18n.normalize_translation_keys to I18n.normalize_keys and deprecate 
+the former":http://github.com/svenfuchs/i18n/commit/7284b04d5f5dd9679cb68875515cdd0cdfc96fef
+
+h2. 0.3.4 (2010-02-25)
+
+* "Rename I18n.normalize_translation_keys to I18n.normalize_keys and finally make it public":http://github.com/svenfuchs/i18n/commit/20b05fe5802df6c90fb70a4e3760b2b851b791b3
+
+* "Added CLDR supoprt":http://github.com/svenfuchs/i18n/commit/860eadf671a231e7f5dffb1bb27fa318ff7a8786
+
+h2. 0.3.3 (2009-12-29)
+
+* "Use lib/i18n/version":http://github.com/svenfuchs/i18n/commit/ff426c8e7a2438b814cb303adadec292dacb752e
+
+* "Added a benchmark suite":http://github.com/svenfuchs/i18n/commit/f9b5b9b113097724638bdab96862ffa404e67e70
+
+* "Ensure links can be handled recursively":http://github.com/svenfuchs/i18n/commit/2c50bd209f3fc24fe9dfa694c81be64340f09b7d
+
+* "Make sure we can lookup false values as translation data":http://github.com/svenfuchs/i18n/commit/561c82ba4b8921d03bfdf56cb2d0c2f287629001
+
+* "Added Fast backend module":http://github.com/svenfuchs/i18n/commit/bd2f09f0a251ca793b0e8ecc7e32177a2f091c23
+
+* "Added InterpolationCompiler backend module":http://github.com/svenfuchs/i18n/commit/91810887d1abfb28996a9183bc9004678290d28b
+
+h2. 0.3.2 (2009-12-12)
+
+* "Added Cascade backend":http://github.com/svenfuchs/i18n/commit/8009aef293e9ef8564c9005090d8380feabcaf6f
+
+h2. 0.3.1 (2009-12-11)
+
+* "Add PoParser to gemspec":http://github.com/svenfuchs/i18n/commit/d6b2763f39c932f66adb039b96882a472f883c51
+* "Enable custom separators for ActiveRecord backend":http://github.com/svenfuchs/i18n/commit/9341d3fcfc951cc31807ba672d2b5d90909ef3e5
+* "Pass interpolation values to interpolation procs":http://github.com/svenfuchs/i18n/commit/39c2ed8fbad645671cd5520ce7ad0aeefe2b0cca
+* "Fix that ngettext supports keys with dots":http://github.com/svenfuchs/i18n/commit/7362a43c34364d500de8899cfcca6bf1a5e6d1c8
+
+h2. 0.3.0 (2009-11-30)
+
+* "Gettext backend and helpers":http://github.com/svenfuchs/i18n/commit/35a1740d2f10b808548af352006950da4017e374
+* "Metadata module":http://github.com/svenfuchs/i18n/commit/2677208555179b36fcbe958c0e8bc642cf5bc020
+* "Basic ActiveRecord backend":http://github.com/svenfuchs/i18n/commit/786632d0b42de423ecf0969622efc87f1691e2a2
+* "Set encoding to UTF8 for all files":http://github.com/svenfuchs/i18n/commit/9be3d4a311b5bf583eec5d39986176cc40c112f2
+* "Chain backend":http://github.com/svenfuchs/i18n/commit/08259ffb88b3005403648d77bc1cbca0b92f3cf5
+* "Backend/cache implementation":http://github.com/svenfuchs/i18n/commit/e7bf15351cd2e27f5972eb40e65a5dd6f4a0feed
+* "Pluralization module":http://github.com/svenfuchs/i18n/commit/9ca4c9ed52d4706566a6abeb2d78722dcc5d4764
+* "add and adapt Globalize2 fallback implementation":http://github.com/svenfuchs/i18n/commit/1b37a303b27d6222b17162804b06323e5628768f
+* "move Simple backend implementation to a Base backend class and extend Simple from Base.":http://github.com/svenfuchs/i18n/commit/32ddc80a04e6aa247f6d6613bde7f78c73396cb4
+
+h2. 0.2.0 (2009-07-12)
+
+* "Allow using Ruby 1.9 syntax for string interpolation (API addition)":http://github.com/svenfuchs/i18n/commit/c6e0b06d512f2af57199a843a1d8a40241b32861
+* "Allow configuring the default scope separator, allow to pass a custom scope separator(API addition)":http://github.com/svenfuchs/i18n/commit/5b75bfbc348061adc11e3790187a187275bfd471 (e.g. I18n.t(:'foo|bar', :separator => '|') 
+* "Pass :format option to #translate for #localize more useful lambda support":http://github.com/svenfuchs/i18n/commit/e277711b3c844fe7589b8d3f9af0f7d1b969a273
+* "Refactor Simple backend #resolve to #default and #resolve for more consistency. Now allows to pass lambdas as defaults and re-resolve Symbols":http://github.com/svenfuchs/i18n/commit/8c4ce3d923ce5fa73e973fe28217e18165549aba
+* "Add lambda support to #translate (API addition)":http://github.com/svenfuchs/i18n/commit/c90e62d8f7d3d5b78f34cfe328d871b58884f115
+* "Add lambda support to #localize (API addition)":http://github.com/svenfuchs/i18n/commit/9d390afcf33f3f469bb95e6888147152f6cc7442
+
+h2. 0.1.3 (2009-02-27)
+
+* "Remove unnecessary string encoding handling in the i18n simple backend which made the backend break on Ruby 1.9":http://github.com/svenfuchs/i18n/commit/4c3a970783861a94f2e89f46714fb3434e4f4f8d
+
+h2. 0.1.2 (2009-01-09)
+
+* "added #available_locales (returns an array of locales for which translations are available)":http://github.com/svenfuchs/i18n/commit/411f8fe7c8f3f89e9b6b921fa62ed66cb92f3af4
+* "flatten load_path before using it so that a nested array of paths won't throw up":http://github.com/svenfuchs/i18n/commit/d473a068a2b90aba98135deb225d6eb6d8104d70
+
+h2. 0.1.1 (2008-11-20)
+
+* "Use :'en' as a default locale (in favor of :'en-US')":http://github.com/svenfuchs/i18n/commit/c4b10b246aecf7da78cb2568dd0d2ab7e6b8a230
+* "Add #reload! to Simple backend":http://github.com/svenfuchs/i18n/commit/36dd2bd9973b9e1559728749a9daafa44693e964
+
+h2. 0.1.0 (2008-10-25)
+
+* "Fix Simple backend to distinguish false from nil values":http://github.com/svenfuchs/i18n/commit/39d9a47da14b5f3ba126af48923af8c30e135166
+* "Add #load_path to public api, add initialize to simple backend and remove #load_translations from public api":http://github.com/svenfuchs/i18n/commit/c4c5649e6bc8f020f1aaf5a5470bde048e22c82d
+* "Speed up Backend::Simple#interpolate":http://github.com/svenfuchs/i18n/commit/9e1ac6bf8833304e036323ec9932b9f33c468a35
+* "Remove #populate and #store_translations from public API":http://github.com/svenfuchs/i18n/commit/f4e514a80be7feb509f66824ee311905e2940900
+* "Use :other instead of :many as a plural key":http://github.com/svenfuchs/i18n/commit/0f8f20a2552bf6a2aa758d8fdd62a7154e4a1bf6
+* "Use a class instead of a module for Simple backend":http://github.com/svenfuchs/i18n/commit/08f051aa61320c17debde24a83268bc74e33b995
+* "Make Simple backend #interpolate deal with non-ASCII string encodings":http://github.com/svenfuchs/i18n/commit/d84a3f3f55543c084d5dc5d1fed613b8df148789
+* "Fix default arrays of non-existant keys returning the default array":http://github.com/svenfuchs/i18n/commit/6c04ca86c87f97dc78f07c2a4023644e5ba8b839
+
+h2. Initial implementation (June/July 2008)
+
+Initial implementation by "Sven Fuchs":http://www.workingwithrails.com/person/9963-sven-fuchs based on previous discussion/consensus of the rails-i18n team (alphabetical order) and many others:
+
+* "Matt Aimonetti":http://railsontherun.com
+* "Sven Fuchs":http://www.workingwithrails.com/person/9963-sven-fuchs
+* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
+* "Saimon Moore":http://saimonmoore.net
+* "Stephan Soller":http://www.arkanis-development.de
+
+h2. More information
+
+* "Homepage":http://rails-i18n.org
+* "Wiki":http://rails-i18n.org/wiki
+* "Mailinglist":http://groups.google.com/group/rails-i18n
+* "About the project/history":http://www.artweb-design.de/2008/7/18/finally-ruby-on-rails-gets-internationalized
+* "Initial API Intro":http://www.artweb-design.de/2008/7/18/the-ruby-on-rails-i18n-core-api
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/MIT-LICENSE b/activesupport/lib/active_support/vendor/i18n-0.4.1/MIT-LICENSE
new file mode 100755
index 0000000..ed8e9ee
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/MIT-LICENSE
@@ -0,0 +1,20 @@
+Copyright (c) 2008 The Ruby I18n team
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/README.textile b/activesupport/lib/active_support/vendor/i18n-0.4.1/README.textile
new file mode 100644
index 0000000..3fe0585
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/README.textile
@@ -0,0 +1,93 @@
+h1. Ruby I18n
+
+Ruby Internationalization and localization solution.
+
+Features:
+
+* translation and localization
+* interpolation of values to translations (Ruby 1.9 compatible syntax)
+* pluralization (CLDR compatible)
+* customizable transliteration to ASCII
+* flexible defaults
+* bulk lookup
+* lambdas as translation data
+* custom key/scope separator
+* custom exception handlers
+* extensible architecture with a swappable backend
+
+Pluggable features:
+
+* Cache
+* Pluralization: lambda pluralizers stored as translation data
+* Locale fallbacks, RFC4647 compliant (optionally: RFC4646 locale validation)
+* Gettext support
+* Translation metadata
+
+Alternative backends:
+
+* Chain
+* ActiveRecord (optionally: ActiveRecord::Missing and ActiveRecord::StoreProcs)
+* KeyValue (uses active_support/json and cannot store procs)
+
+For more information and lots of resources see: "http://rails-i18n.org/wiki":http://rails-i18n.org/wiki
+
+h2. Installation
+
+gem install i18n
+
+h3. Installation on Rails < 2.3.5 (deprecated)
+
+Up to version 2.3.4 Rails will not accept i18n gems > 0.1.3. There is an unpacked
+gem inside of active_support/lib/vendor which gets loaded unless gem 'i18n', '~> 0.1.3'.
+This requirement is relaxed in "6da03653":http://github.com/rails/rails/commit/6da03653
+
+The new i18n gem can be loaded from vendor/plugins like this:
+
+  def reload_i18n!
+    raise "Move to i18n version 0.2.0 or greater" if Rails.version > "2.3.4"
+
+    $:.grep(/i18n/).each { |path| $:.delete(path) }
+    I18n::Backend.send :remove_const, "Simple"
+    $: << Rails.root.join('vendor', 'plugins', 'i18n', 'lib').to_s
+  end
+
+Then you can `reload_i18n!` inside an i18n initializer.
+
+h2. Tests
+
+You can run tests both with
+
+* `rake test` or just `rake`
+* run any test file directly, e.g. `ruby test/api/simple_test.rb`
+* run all tests with `ruby test/all.rb`
+
+The structure of the test suite is a bit unusual as it uses modules to reuse
+particular tests in different test cases.
+
+The reason for this is that we need to enforce the I18n API across various
+combinations of extensions. E.g. the Simple backend alone needs to support
+the same API as any combination of feature and/or optimization modules included
+to the Simple backend. We test this by reusing the same API defition (implemented
+as test methods) in test cases with different setups.
+
+You can find the test cases that enforce the API in test/api. And you can find
+the API definition test methods in test/api/tests.
+
+All other test cases (e.g. as defined in test/backend, test/core\_ext) etc.
+follow the usual test setup and should be easy to grok.
+
+h2. Authors
+
+* "Sven Fuchs":http://www.artweb-design.de
+* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
+* "Stephan Soller":http://www.arkanis-development.de
+* "Saimon Moore":http://saimonmoore.net
+* "Matt Aimonetti":http://railsontherun.com
+
+h2. Contributors
+
+http://github.com/svenfuchs/i18n/contributors
+
+h2. License
+
+MIT License. See the included MIT-LICENSE file.
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/Rakefile b/activesupport/lib/active_support/vendor/i18n-0.4.1/Rakefile
new file mode 100644
index 0000000..e68ada5
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/Rakefile
@@ -0,0 +1,24 @@
+require 'rake/testtask'
+require "rake/gempackagetask"
+require "rake/clean"
+
+task :default => [:test]
+
+CLEAN << "pkg" << "doc" << "coverage" << ".yardoc"
+
+Rake::TestTask.new(:test) do |t|
+  t.pattern = "#{File.dirname(__FILE__)}/test/all.rb"
+  t.verbose = true
+end
+Rake::Task['test'].comment = "Run all i18n tests"
+
+Rake::GemPackageTask.new(eval(File.read("i18n.gemspec"))) { |pkg| }
+
+begin
+  require "yard"
+  YARD::Rake::YardocTask.new do |t|
+    t.options = ["--output-dir=doc"]
+    t.options << "--files" << ["CHANGELOG.textile", "contributors.txt", "MIT-LICENSE"].join(",")
+  end
+rescue LoadError
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/example.yml b/activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/example.yml
new file mode 100644
index 0000000..da5f9fe
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/example.yml
@@ -0,0 +1,148 @@
+en:
+  first: "First"
+
+  activemodel:
+    errors:
+      messages: :"activerecord.errors.messages"
+
+  activerecord:
+    errors:
+      messages:
+        inclusion: "is not included in the list"
+        exclusion: "is reserved"
+        invalid: "is invalid"
+        confirmation: "doesn't match confirmation"
+        accepted: "must be accepted"
+        empty: "can't be empty"
+        blank: "can't be blank"
+        too_long: "is too long (maximum is %{count} characters)"
+        too_short: "is too short (minimum is %{count} characters)"
+        wrong_length: "is the wrong length (should be %{count} characters)"
+        taken: "has already been taken"
+        not_a_number: "is not a number"
+        greater_than: "must be greater than %{count}"
+        greater_than_or_equal_to: "must be greater than or equal to %{count}"
+        equal_to: "must be equal to %{count}"
+        less_than: "must be less than %{count}"
+        less_than_or_equal_to: "must be less than or equal to %{count}"
+        odd: "must be odd"
+        even: "must be even"
+        record_invalid: "Validation failed: %{errors}"
+
+      models:
+        user:
+          blank: "This is a custom blank message for %{model}: %{attribute}"
+          attributes:
+            login:
+              blank: "This is a custom blank message for User login"
+
+    models:
+      user: "Dude"
+
+    attributes:
+      admins:
+        user:
+          login: "Handle"
+
+  date:
+    formats:
+      # Use the strftime parameters for formats.
+      # When no format has been given, it uses default.
+      # You can provide other formats here if you like!
+      default: "%Y-%m-%d"
+      short: "%b %d"
+      long: "%B %d, %Y"
+
+    day_names: [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]
+    abbr_day_names: [Sun, Mon, Tue, Wed, Thu, Fri, Sat]
+
+    # Don't forget the nil at the beginning; there's no such thing as a 0th month
+    month_names: [~, January, February, March, April, May, June, July, August, September, October, November, December]
+    abbr_month_names: [~, Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]
+    # Used in date_select and datime_select.
+    order: [ :year, :month, :day ]
+
+  time:
+    formats:
+      default: "%a, %d %b %Y %H:%M:%S %z"
+      short: "%d %b %H:%M"
+      long: "%B %d, %Y %H:%M"
+    am: "am"
+    pm: "pm"
+
+  support:
+    array:
+      words_connector: ", "
+      two_words_connector: " and "
+      last_word_connector: ", and "
+
+  activemodel:
+    errors:
+      messages:
+        inclusion: "is not included in the list"
+        exclusion: "is reserved"
+        invalid: "is invalid"
+        confirmation: "doesn't match confirmation"
+        accepted: "must be accepted"
+        empty: "can't be empty"
+        blank: "can't be blank"
+        too_long: "is too long (maximum is %{count} characters)"
+        too_short: "is too short (minimum is %{count} characters)"
+        wrong_length: "is the wrong length (should be %{count} characters)"
+        taken: "has already been taken"
+        not_a_number: "is not a number"
+        greater_than: "must be greater than %{count}"
+        greater_than_or_equal_to: "must be greater than or equal to %{count}"
+        equal_to: "must be equal to %{count}"
+        less_than: "must be less than %{count}"
+        less_than_or_equal_to: "must be less than or equal to %{count}"
+        odd: "must be odd"
+        even: "must be even"
+        record_invalid: "Validation failed: %{errors}"
+
+      models:
+        user:
+          blank: "This is a custom blank message for %{model}: %{attribute}"
+          attributes:
+            login:
+              blank: "This is a custom blank message for User login"
+
+    models:
+      user: "Dude"
+
+    attributes:
+      user:
+        login: "Handle"
+
+  model_data:
+    date:
+      formats:
+        # Use the strftime parameters for formats.
+        # When no format has been given, it uses default.
+        # You can provide other formats here if you like!
+        default: "%Y-%m-%d"
+        short: "%b %d"
+        long: "%B %d, %Y"
+
+      day_names: [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]
+      abbr_day_names: [Sun, Mon, Tue, Wed, Thu, Fri, Sat]
+
+      # Don't forget the nil at the beginning; there's no such thing as a 0th month
+      month_names: [~, January, February, March, April, May, June, July, August, September, October, November, December]
+      abbr_month_names: [~, Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]
+      # Used in date_select and datime_select.
+      order: [ :year, :month, :day ]
+
+    time:
+      formats:
+        default: "%a, %d %b %Y %H:%M:%S %z"
+        short: "%d %b %H:%M"
+        long: "%B %d, %Y %H:%M"
+      am: "am"
+      pm: "pm"
+
+    support:
+      array:
+        words_connector: ", "
+        two_words_connector: " and "
+        last_word_connector: ", and "
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/run.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/run.rb
new file mode 100644
index 0000000..c5a1987
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/benchmark/run.rb
@@ -0,0 +1,116 @@
+#! /usr/bin/ruby
+$:.unshift File.expand_path('../../lib', __FILE__)
+
+require 'i18n'
+require 'benchmark'
+require 'yaml'
+
+DATA_STORES = ARGV.delete("-ds")
+N = (ARGV.shift || 1000).to_i
+YAML_HASH = YAML.load_file(File.expand_path("example.yml", File.dirname(__FILE__)))
+
+module Backends
+  Simple = I18n::Backend::Simple.new
+
+  Interpolation = Class.new(I18n::Backend::Simple) do
+    include I18n::Backend::InterpolationCompiler
+  end.new
+
+  if DATA_STORES
+    require 'rubygems'
+    require File.expand_path('../../test/test_setup_requirements', __FILE__)
+
+    setup_active_record
+    ActiveRecord = I18n::Backend::ActiveRecord.new if defined?(::ActiveRecord)
+
+    setup_rufus_tokyo
+    TokyoCabinet = I18n::Backend::KeyValue.new(Rufus::Tokyo::Cabinet.new("*"), true) if defined?(::Rufus::Tokyo)
+  end
+end
+
+ORDER = %w(Simple Interpolation ActiveRecord TokyoCabinet)
+ORDER.map!(&:to_sym) if RUBY_VERSION > '1.9'
+
+module Benchmark
+  WIDTH = 20
+
+  def self.rt(label = "", n=N, &blk)
+    print label.ljust(WIDTH)
+    time, objects = measure_objects(n, &blk)
+    time = time.respond_to?(:real) ? time.real : time
+    print format("%8.2f ms  %8d objects\n", time * 1000, objects)
+  rescue Exception => e
+    print "FAILED: #{e.message}"
+  end
+
+  if ObjectSpace.respond_to?(:allocated_objects)
+    def self.measure_objects(n, &blk)
+      obj = ObjectSpace.allocated_objects
+      t = Benchmark.realtime { n.times(&blk) }
+      [t, ObjectSpace.allocated_objects - obj]
+    end
+  else
+    def self.measure_objects(n, &blk)
+      [Benchmark.measure { n.times(&blk) }, 0]
+    end
+  end
+end
+
+benchmarker = lambda do |backend_name|
+  I18n.backend = Backends.const_get(backend_name)
+  puts "=> #{backend_name}\n\n"
+
+  Benchmark.rt "store", 1 do
+    I18n.backend.store_translations *(YAML_HASH.to_a.first)
+  end
+
+  I18n.backend.translate :en, :first
+
+  Benchmark.rt "available_locales" do
+    I18n.backend.available_locales
+  end
+
+  Benchmark.rt "t (depth=3)" do
+    I18n.backend.translate :en, :"activerecord.models.user"
+  end
+
+  Benchmark.rt "t (depth=5)" do
+    I18n.backend.translate :en, :"activerecord.attributes.admins.user.login"
+  end
+
+  Benchmark.rt "t (depth=7)" do
+    I18n.backend.translate :en, :"activerecord.errors.models.user.attributes.login.blank"
+  end
+
+  Benchmark.rt "t w/ default" do
+    I18n.backend.translate :en, :"activerecord.models.another", :default => "Another"
+  end
+
+  Benchmark.rt "t w/ interpolation" do
+    I18n.backend.translate :en, :"activerecord.errors.models.user.blank", :model => "User", :attribute => "name"
+  end
+
+  Benchmark.rt "t w/ link" do
+    I18n.backend.translate :en, :"activemodel.errors.messages.blank"
+  end
+
+  Benchmark.rt "t subtree" do
+    I18n.backend.translate :en, :"activerecord.errors.messages"
+  end
+
+  puts
+end
+
+# Run!
+puts
+puts "Running benchmarks with N = #{N}\n\n"
+(ORDER & Backends.constants).each(&benchmarker)
+
+Backends.constants.each do |backend_name|
+ backend = Backends.const_get(backend_name)
+ backend.reload!
+ backend.extend I18n::Backend::Memoize
+end
+
+puts "Running memoized benchmarks with N = #{N}\n\n"
+(ORDER & Backends.constants).each(&benchmarker)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/i18n.gemspec b/activesupport/lib/active_support/vendor/i18n-0.4.1/i18n.gemspec
new file mode 100644
index 0000000..4a90913
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/i18n.gemspec
@@ -0,0 +1,20 @@
+# encoding: utf-8
+
+$: << File.expand_path('../lib', __FILE__)
+require 'i18n/version'
+
+Gem::Specification.new do |s|
+  s.name         = "i18n"
+  s.version      = I18n::VERSION
+  s.authors      = ["Sven Fuchs", "Joshua Harvey", "Matt Aimonetti", "Stephan Soller", "Saimon Moore"]
+  s.email        = "rails-i18n@googlegroups.com"
+  s.homepage     = "http://github.com/svenfuchs/i18n"
+  s.summary      = "New wave Internationalization support for Ruby"
+  s.description  = "New wave Internationalization support for Ruby."
+
+  s.files        = `git ls-files {app,lib}`.split("\n") + %w(README.textile MIT-LICENSE CHANGELOG.textile)
+  s.platform     = Gem::Platform::RUBY
+  s.require_path = 'lib'
+  s.rubyforge_project = '[none]'
+  s.required_rubygems_version = '>= 1.3.6'
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/init.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/init.rb
new file mode 100644
index 0000000..9776acc
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/init.rb
@@ -0,0 +1 @@
+require 'i18n'
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n.rb
new file mode 100755
index 0000000..346681e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n.rb
@@ -0,0 +1,322 @@
+# encoding: utf-8
+
+# Authors::   Sven Fuchs (http://www.artweb-design.de),
+#             Joshua Harvey (http://www.workingwithrails.com/person/759-joshua-harvey),
+#             Stephan Soller (http://www.arkanis-development.de/),
+#             Saimon Moore (http://saimonmoore.net),
+#             Matt Aimonetti (http://railsontherun.com/)
+# Copyright:: Copyright (c) 2008 The Ruby i18n Team
+# License::   MIT
+require 'i18n/exceptions'
+require 'i18n/core_ext/string/interpolate'
+
+module I18n
+  autoload :Backend, 'i18n/backend'
+  autoload :Config,  'i18n/config'
+  autoload :Gettext, 'i18n/gettext'
+  autoload :Locale,  'i18n/locale'
+
+  class << self
+    # Gets I18n configuration object.
+    def config
+      Thread.current[:i18n_config] ||= I18n::Config.new
+    end
+
+    # Sets I18n configuration object.
+    def config=(value)
+      Thread.current[:i18n_config] = value
+    end
+
+    # Write methods which delegates to the configuration object
+    %w(locale backend default_locale available_locales default_separator
+      exception_handler load_path).each do |method|
+      module_eval <<-DELEGATORS, __FILE__, __LINE__ + 1
+        def #{method}
+          config.#{method}
+        end
+
+        def #{method}=(value)
+          config.#{method} = (value)
+        end
+      DELEGATORS
+    end
+
+    # Tells the backend to reload translations. Used in situations like the
+    # Rails development environment. Backends can implement whatever strategy
+    # is useful.
+    def reload!
+      config.backend.reload!
+    end
+
+    # Translates, pluralizes and interpolates a given key using a given locale,
+    # scope, and default, as well as interpolation values.
+    #
+    # *LOOKUP*
+    #
+    # Translation data is organized as a nested hash using the upper-level keys
+    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
+    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
+    #
+    # Translations can be looked up at any level of this hash using the key argument
+    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
+    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
+    #
+    # Key can be either a single key or a dot-separated key (both Strings and Symbols
+    # work). <em>E.g.</em>, the short format can be looked up using both:
+    #   I18n.t 'date.formats.short'
+    #   I18n.t :'date.formats.short'
+    #
+    # Scope can be either a single key, a dot-separated key or an array of keys
+    # or dot-separated keys. Keys and scopes can be combined freely. So these
+    # examples will all look up the same short date format:
+    #   I18n.t 'date.formats.short'
+    #   I18n.t 'formats.short', :scope => 'date'
+    #   I18n.t 'short', :scope => 'date.formats'
+    #   I18n.t 'short', :scope => %w(date formats)
+    #
+    # *INTERPOLATION*
+    #
+    # Translations can contain interpolation variables which will be replaced by
+    # values passed to #translate as part of the options hash, with the keys matching
+    # the interpolation variable names.
+    #
+    # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
+    # value for the key +bar+ will be interpolated into the translation:
+    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
+    #
+    # *PLURALIZATION*
+    #
+    # Translation data can contain pluralized translations. Pluralized translations
+    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
+    #
+    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
+    # pluralization rules. Other algorithms can be supported by custom backends.
+    #
+    # This returns the singular version of a pluralized translation:
+    #   I18n.t :foo, :count => 1 # => 'Foo'
+    #
+    # These both return the plural version of a pluralized translation:
+    #   I18n.t :foo, :count => 0 # => 'Foos'
+    #   I18n.t :foo, :count => 2 # => 'Foos'
+    #
+    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
+    # <em>E.g.</em>, with the translation
+    # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
+    # be interpolated to the pluralized translation:
+    #   I18n.t :foo, :count => 1 # => '1 foo'
+    #
+    # *DEFAULTS*
+    #
+    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
+    #   I18n.t :foo, :default => 'default'
+    #
+    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
+    # translation for <tt>:foo</tt> was found:
+    #   I18n.t :foo, :default => :bar
+    #
+    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
+    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
+    #   I18n.t :foo, :default => [:bar, 'default']
+    #
+    # *BULK LOOKUP*
+    #
+    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
+    #   I18n.t [:foo, :bar]
+    #
+    # Can be used with dot-separated nested keys:
+    #   I18n.t [:'baz.foo', :'baz.bar']
+    #
+    # Which is the same as using a scope option:
+    #   I18n.t [:foo, :bar], :scope => :baz
+    #
+    # *LAMBDAS*
+    #
+    # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
+    # called and passed the key and options.
+    #
+    # E.g. assuming the key <tt>:salutation</tt> resolves to:
+    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{options[:name]}" : "Mrs. %{options[:name]}" }
+    #
+    # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
+    #
+    # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
+    # a cache layer is put in front of I18n.translate it will generate a cache key
+    # from the argument values passed to #translate. Therefor your lambdas should
+    # always return the same translations/values per unique combination of argument
+    # values.
+    def translate(*args)
+      options = args.pop if args.last.is_a?(Hash)
+      key     = args.shift
+      locale  = options && options.delete(:locale) || config.locale
+      raises  = options && options.delete(:raise)
+      config.backend.translate(locale, key, options || {})
+    rescue I18n::ArgumentError => exception
+      raise exception if raises
+      handle_exception(exception, locale, key, options)
+    end
+    alias :t :translate
+
+    def translate!(key, options = {})
+      translate(key, options.merge( :raise => true ))
+    end
+    alias :t! :translate!
+
+    # Transliterates UTF-8 characters to ASCII. By default this method will
+    # transliterate only Latin strings to an ASCII approximation:
+    #
+    #    I18n.transliterate("Ærøskøbing")
+    #    # => "AEroskobing"
+    #
+    #    I18n.transliterate("日本語")
+    #    # => "???"
+    #
+    # It's also possible to add support for per-locale transliterations. I18n
+    # expects transliteration rules to be stored at
+    # <tt>i18n.transliterate.rule</tt>.
+    #
+    # Transliteration rules can either be a Hash or a Proc. Procs must accept a
+    # single string argument. Hash rules inherit the default transliteration
+    # rules, while Procs do not.
+    #
+    # *Examples*
+    #
+    # Setting a Hash in <locale>.yml:
+    #
+    #    i18n:
+    #      transliterate:
+    #        rule:
+    #          ü: "ue"
+    #          ö: "oe"
+    #
+    # Setting a Hash using Ruby:
+    #
+    #     store_translations(:de, :i18n => {
+    #       :transliterate => {
+    #         :rule => {
+    #           "ü" => "ue",
+    #           "ö" => "oe"
+    #         }
+    #       }
+    #     )
+    #
+    # Setting a Proc:
+    #
+    #     translit = lambda {|string| MyTransliterator.transliterate(string) }
+    #     store_translations(:xx, :i18n => {:transliterate => {:rule => translit})
+    #
+    # Transliterating strings:
+    #
+    #     I18n.locale = :en
+    #     I18n.transliterate("Jürgen") # => "Jurgen"
+    #     I18n.locale = :de
+    #     I18n.transliterate("Jürgen") # => "Juergen"
+    #     I18n.transliterate("Jürgen", :locale => :en) # => "Jurgen"
+    #     I18n.transliterate("Jürgen", :locale => :de) # => "Juergen"
+    def transliterate(*args)
+      options      = args.pop if args.last.is_a?(Hash)
+      key          = args.shift
+      locale       = options && options.delete(:locale) || config.locale
+      raises       = options && options.delete(:raise)
+      replacement  = options && options.delete(:replacement)
+      config.backend.transliterate(locale, key, replacement)
+    rescue I18n::ArgumentError => exception
+      raise exception if raises
+      handle_exception(exception, locale, key, options)
+    end
+
+    # Localizes certain objects, such as dates and numbers to local formatting.
+    def localize(object, options = {})
+      locale = options.delete(:locale) || config.locale
+      format = options.delete(:format) || :default
+      config.backend.localize(locale, object, format, options)
+    end
+    alias :l :localize
+
+    # Executes block with given I18n.locale set.
+    def with_locale(tmp_locale = nil)
+      if tmp_locale
+        current_locale = self.locale
+        self.locale    = tmp_locale
+      end
+      yield
+    ensure
+      self.locale = current_locale if tmp_locale
+    end
+
+
+    # Merges the given locale, key and scope into a single array of keys.
+    # Splits keys that contain dots into multiple keys. Makes sure all
+    # keys are Symbols.
+    def normalize_keys(locale, key, scope, separator = nil)
+      separator ||= I18n.default_separator
+
+      keys = []
+      keys.concat normalize_key(locale, separator)
+      keys.concat normalize_key(scope, separator)
+      keys.concat normalize_key(key, separator)
+      keys
+    end
+
+  # making these private until Ruby 1.9.2 can send to protected methods again
+  # see http://redmine.ruby-lang.org/repositories/revision/ruby-19?rev=24280
+  private
+
+    # Handles exceptions raised in the backend. All exceptions except for
+    # MissingTranslationData exceptions are re-raised. When a MissingTranslationData
+    # was caught and the option :raise is not set the handler returns an error
+    # message string containing the key/scope.
+    def default_exception_handler(exception, locale, key, options)
+      return exception.message if MissingTranslationData === exception
+      raise exception
+    end
+
+    # Any exceptions thrown in translate will be sent to the @@exception_handler
+    # which can be a Symbol, a Proc or any other Object.
+    #
+    # If exception_handler is a Symbol then it will simply be sent to I18n as
+    # a method call. A Proc will simply be called. In any other case the
+    # method #call will be called on the exception_handler object.
+    #
+    # Examples:
+    #
+    #   I18n.exception_handler = :default_exception_handler             # this is the default
+    #   I18n.default_exception_handler(exception, locale, key, options) # will be called like this
+    #
+    #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
+    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
+    #
+    #  I18n.exception_handler = I18nExceptionHandler.new                # an object
+    #  I18n.exception_handler.call(exception, locale, key, options)     # will be called like this
+    def handle_exception(exception, locale, key, options)
+      case config.exception_handler
+      when Symbol
+        send(config.exception_handler, exception, locale, key, options)
+      else
+        config.exception_handler.call(exception, locale, key, options)
+      end
+    end
+
+    # Deprecated. Will raise a warning in future versions and then finally be
+    # removed. Use I18n.normalize_keys instead.
+    def normalize_translation_keys(locale, key, scope, separator = nil)
+      normalize_keys(locale, key, scope, separator)
+    end
+
+    def normalize_key(key, separator)
+      normalized_key_cache[separator][key] ||=
+        case key
+        when Array
+          key.map { |k| normalize_key(k, separator) }.flatten
+        else
+          keys = key.to_s.split(separator)
+          keys.delete('')
+          keys.map!{ |k| k.to_sym }
+          keys
+        end
+    end
+
+    def normalized_key_cache
+      @normalized_key_cache ||= Hash.new { |h,k| h[k] = {} }
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend.rb
new file mode 100644
index 0000000..fe65fb4
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend.rb
@@ -0,0 +1,20 @@
+module I18n
+  module Backend
+    autoload :ActiveRecord,          'i18n/backend/active_record'
+    autoload :Base,                  'i18n/backend/base'
+    autoload :InterpolationCompiler, 'i18n/backend/interpolation_compiler'
+    autoload :Cache,                 'i18n/backend/cache'
+    autoload :Cascade,               'i18n/backend/cascade'
+    autoload :Chain,                 'i18n/backend/chain'
+    autoload :Cldr,                  'i18n/backend/cldr'
+    autoload :Fallbacks,             'i18n/backend/fallbacks'
+    autoload :Flatten,               'i18n/backend/flatten'
+    autoload :Gettext,               'i18n/backend/gettext'
+    autoload :KeyValue,              'i18n/backend/key_value'
+    autoload :Memoize,               'i18n/backend/memoize'
+    autoload :Metadata,              'i18n/backend/metadata'
+    autoload :Pluralization,         'i18n/backend/pluralization'
+    autoload :Simple,                'i18n/backend/simple'
+    autoload :Transliterator,        'i18n/backend/transliterator'
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record.rb
new file mode 100644
index 0000000..b60f138
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record.rb
@@ -0,0 +1,61 @@
+require 'i18n/backend/base'
+require 'i18n/backend/active_record/translation'
+
+module I18n
+  module Backend
+    class ActiveRecord
+      autoload :Missing,     'i18n/backend/active_record/missing'
+      autoload :StoreProcs,  'i18n/backend/active_record/store_procs'
+      autoload :Translation, 'i18n/backend/active_record/translation'
+
+      module Implementation
+        include Base, Flatten
+
+        def available_locales
+          begin
+            Translation.available_locales
+          rescue ::ActiveRecord::StatementInvalid
+            []
+          end
+        end
+
+        def store_translations(locale, data, options = {})
+          escape = options.fetch(:escape, true)
+          flatten_translations(locale, data, escape, false).each do |key, value|
+            Translation.locale(locale).lookup(expand_keys(key)).delete_all
+            Translation.create(:locale => locale.to_s, :key => key.to_s, :value => value)
+          end
+        end
+
+      protected
+
+        def lookup(locale, key, scope = [], options = {})
+          key = normalize_flat_keys(locale, key, scope, options[:separator])
+          result = Translation.locale(locale).lookup(key).all
+
+          if result.empty?
+            nil
+          elsif result.first.key == key
+            result.first.value
+          else
+            chop_range = (key.size + FLATTEN_SEPARATOR.size)..-1
+            result = result.inject({}) do |hash, r|
+              hash[r.key.slice(chop_range)] = r.value
+              hash
+            end
+            result.deep_symbolize_keys
+          end
+        end
+
+        # For a key :'foo.bar.baz' return ['foo', 'foo.bar', 'foo.bar.baz']
+        def expand_keys(key)
+          key.to_s.split(FLATTEN_SEPARATOR).inject([]) do |keys, key|
+            keys << [keys.last, key].compact.join(FLATTEN_SEPARATOR)
+          end
+        end
+      end
+
+      include Implementation
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/missing.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/missing.rb
new file mode 100644
index 0000000..0eafcb2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/missing.rb
@@ -0,0 +1,65 @@
+#  This extension stores translation stub records for missing translations to
+#  the database.
+#
+#  This is useful if you have a web based translation tool. It will populate
+#  the database with untranslated keys as the application is being used. A
+#  translator can then go through these and add missing translations.
+#
+#  Example usage:
+#
+#     I18n::Backend::Chain.send(:include, I18n::Backend::ActiveRecord::Missing)
+#     I18n.backend = I18nChainBackend.new(I18n::Backend::ActiveRecord.new, I18n::Backend::Simple.new)
+#
+#  Stub records for pluralizations will also be created for each key defined
+#  in i18n.plural.keys.
+#
+#  For example:
+#
+#    # en.yml
+#    en:
+#      i18n:
+#        plural:
+#          keys: [:zero, :one, :other]
+#
+#    # pl.yml
+#    pl:
+#      i18n:
+#        plural:
+#          keys: [:zero, :one, :few, :other]
+#
+#  It will also persist interpolation keys in Translation#interpolations so
+#  translators will be able to review and use them.
+module I18n
+  module Backend
+    class ActiveRecord
+      module Missing
+        def store_default_translations(locale, key, options = {})
+          count, scope, default, separator = options.values_at(:count, *Base::RESERVED_KEYS)
+          separator ||= I18n.default_separator
+
+          keys = I18n.normalize_keys(locale, key, scope, separator)[1..-1]
+          key = keys.join(separator || I18n.default_separator)
+
+          unless ActiveRecord::Translation.locale(locale).lookup(key).exists?
+            interpolations = options.reject { |name, value| Base::RESERVED_KEYS.include?(name) }.keys
+            keys = count ? I18n.t('i18n.plural.keys', :locale => locale).map { |k| [key, k].join(separator) } : [key]
+            keys.each { |key| store_default_translation(locale, key, interpolations) }
+          end
+        end
+
+        def store_default_translation(locale, key, interpolations)
+          translation = ActiveRecord::Translation.new :locale => locale.to_s, :key => key
+          translation.interpolations = interpolations
+          translation.save
+        end
+
+        def translate(locale, key, options = {})
+          super
+        rescue I18n::MissingTranslationData => e
+          self.store_default_translations(locale, key, options)
+          raise e
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/store_procs.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/store_procs.rb
new file mode 100644
index 0000000..652b1aa
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/store_procs.rb
@@ -0,0 +1,38 @@
+# This module is intended to be mixed into the ActiveRecord backend to allow
+# storing Ruby Procs as translation values in the database.
+#
+#   I18n.backend = I18n::Backend::ActiveRecord.new
+#   I18n::Backend::ActiveRecord::Translation.send(:include, I18n::Backend::ActiveRecord::StoreProcs)
+#
+# The StoreProcs module requires the ParseTree and ruby2ruby gems and therefor
+# was extracted from the original backend.
+#
+# ParseTree is not compatible with Ruby 1.9.
+
+begin
+  require 'ruby2ruby'
+  require 'parse_tree'
+  require 'parse_tree_extensions'
+rescue LoadError => e
+  puts "can't use StoreProcs because: #{e.message}"
+end
+
+module I18n
+  module Backend
+    class ActiveRecord
+      module StoreProcs
+        def value=(v)
+          case v
+          when Proc
+            write_attribute(:value, v.to_ruby)
+            write_attribute(:is_proc, true)
+          else
+            write_attribute(:value, v)
+          end
+        end
+
+        Translation.send(:include, self) if method(:to_s).respond_to?(:to_ruby)
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/translation.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/translation.rb
new file mode 100644
index 0000000..9e38297
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/active_record/translation.rb
@@ -0,0 +1,93 @@
+require 'active_record'
+
+module I18n
+  module Backend
+    # ActiveRecord model used to store actual translations to the database.
+    #
+    # This model expects a table like the following to be already set up in
+    # your the database:
+    #
+    #   create_table :translations do |t|
+    #     t.string :locale
+    #     t.string :key
+    #     t.text   :value
+    #     t.text   :interpolations
+    #     t.boolean :is_proc, :default => false
+    #   end
+    #
+    # This model supports to named scopes :locale and :lookup. The :locale
+    # scope simply adds a condition for a given locale:
+    #
+    #   I18n::Backend::ActiveRecord::Translation.locale(:en).all
+    #   # => all translation records that belong to the :en locale
+    #
+    # The :lookup scope adds a condition for looking up all translations
+    # that either start with the given keys (joined by an optionally given
+    # separator or I18n.default_separator) or that exactly have this key.
+    #
+    #   # with translations present for :"foo.bar" and :"foo.baz"
+    #   I18n::Backend::ActiveRecord::Translation.lookup(:foo)
+    #   # => an array with both translation records :"foo.bar" and :"foo.baz"
+    #
+    #   I18n::Backend::ActiveRecord::Translation.lookup([:foo, :bar])
+    #   I18n::Backend::ActiveRecord::Translation.lookup(:"foo.bar")
+    #   # => an array with the translation record :"foo.bar"
+    #
+    # When the StoreProcs module was mixed into this model then Procs will
+    # be stored to the database as Ruby code and evaluated when :value is
+    # called.
+    #
+    #   Translation = I18n::Backend::ActiveRecord::Translation
+    #   Translation.create \
+    #     :locale => 'en'
+    #     :key    => 'foo'
+    #     :value  => lambda { |key, options| 'FOO' }
+    #   Translation.find_by_locale_and_key('en', 'foo').value
+    #   # => 'FOO'
+    class ActiveRecord
+      class Translation < ::ActiveRecord::Base
+        set_table_name 'translations'
+        attr_protected :is_proc, :interpolations
+
+        serialize :value
+        serialize :interpolations, Array
+
+        scope_method = ::ActiveRecord::VERSION::MAJOR == 2 ? :named_scope : :scope
+
+        send scope_method, :locale, lambda { |locale|
+          { :conditions => { :locale => locale.to_s } }
+        }
+
+        send scope_method, :lookup, lambda { |keys, *separator|
+          column_name = connection.quote_column_name('key')
+          keys = Array(keys).map! { |key| key.to_s }
+
+          unless separator.empty?
+            warn "[DEPRECATION] Giving a separator to Translation.lookup is deprecated. " <<
+              "You can change the internal separator by overwriting FLATTEN_SEPARATOR."
+          end
+
+          namespace = "#{keys.last}#{I18n::Backend::Flatten::FLATTEN_SEPARATOR}%"
+          { :conditions => ["#{column_name} IN (?) OR #{column_name} LIKE ?", keys, namespace] }
+        }
+
+        def self.available_locales
+          Translation.find(:all, :select => 'DISTINCT locale').map { |t| t.locale.to_sym }
+        end
+
+        def interpolates?(key)
+          self.interpolations.include?(key) if self.interpolations
+        end
+
+        def value
+          if is_proc
+            Kernel.eval(read_attribute(:value))
+          else
+            value = read_attribute(:value)
+            value == 'f' ? false : value
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/base.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/base.rb
new file mode 100644
index 0000000..3272558
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/base.rb
@@ -0,0 +1,237 @@
+# encoding: utf-8
+
+require 'yaml'
+require 'i18n/core_ext/hash'
+
+module I18n
+  module Backend
+    module Base
+      include I18n::Backend::Transliterator
+
+      RESERVED_KEYS = [:scope, :default, :separator, :resolve]
+      RESERVED_KEYS_PATTERN = /%\{(#{RESERVED_KEYS.join("|")})\}/
+      DEPRECATED_INTERPOLATION_SYNTAX_PATTERN = /(\\)?\{\{([^\}]+)\}\}/
+      INTERPOLATION_SYNTAX_PATTERN = /%\{([^\}]+)\}/
+
+      # Accepts a list of paths to translation files. Loads translations from
+      # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
+      # for details.
+      def load_translations(*filenames)
+        filenames = I18n.load_path.flatten if filenames.empty?
+        filenames.each { |filename| load_file(filename) }
+      end
+
+      # This method receives a locale, a data hash and options for storing translations.
+      # Should be implemented
+      def store_translations(locale, data, options = {})
+        raise NotImplementedError
+      end
+
+      def translate(locale, key, options = {})
+        raise InvalidLocale.new(locale) unless locale
+        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
+
+        entry = key && lookup(locale, key, options[:scope], options)
+
+        if options.empty?
+          entry = resolve(locale, key, entry, options)
+        else
+          count, default = options.values_at(:count, :default)
+          values = options.except(*RESERVED_KEYS)
+          entry = entry.nil? && default ?
+            default(locale, key, default, options) : resolve(locale, key, entry, options)
+        end
+
+        raise(I18n::MissingTranslationData.new(locale, key, options)) if entry.nil?
+        entry = entry.dup if entry.is_a?(String)
+
+        entry = pluralize(locale, entry, count) if count
+        entry = interpolate(locale, entry, values) if values
+        entry
+      end
+
+      # Acts the same as +strftime+, but uses a localized version of the
+      # format string. Takes a key from the date/time formats translations as
+      # a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
+      def localize(locale, object, format = :default, options = {})
+        raise ArgumentError, "Object must be a Date, DateTime or Time object. #{object.inspect} given." unless object.respond_to?(:strftime)
+
+        if Symbol === format
+          key = format
+          type = object.respond_to?(:sec) ? 'time' : 'date'
+          format = I18n.t(:"#{type}.formats.#{key}", options.merge(:raise => true, :object => object, :locale => locale))
+        end
+
+        # format = resolve(locale, object, format, options)
+        format = format.to_s.gsub(/%[aAbBp]/) do |match|
+          case match
+          when '%a' then I18n.t(:"date.abbr_day_names",                  :locale => locale, :format => format)[object.wday]
+          when '%A' then I18n.t(:"date.day_names",                       :locale => locale, :format => format)[object.wday]
+          when '%b' then I18n.t(:"date.abbr_month_names",                :locale => locale, :format => format)[object.mon]
+          when '%B' then I18n.t(:"date.month_names",                     :locale => locale, :format => format)[object.mon]
+          when '%p' then I18n.t(:"time.#{object.hour < 12 ? :am : :pm}", :locale => locale, :format => format) if object.respond_to? :hour
+          end
+        end
+
+        object.strftime(format)
+      end
+
+      # Returns an array of locales for which translations are available
+      # ignoring the reserved translation meta data key :i18n.
+      def available_locales
+        raise NotImplementedError
+      end
+
+      def reload!
+        @skip_syntax_deprecation = false
+      end
+
+      protected
+
+        # The method which actually looks up for the translation in the store.
+        def lookup(locale, key, scope = [], options = {})
+          raise NotImplementedError
+        end
+
+        # Evaluates defaults.
+        # If given subject is an Array, it walks the array and returns the
+        # first translation that can be resolved. Otherwise it tries to resolve
+        # the translation directly.
+        def default(locale, object, subject, options = {})
+          options = options.dup.reject { |key, value| key == :default }
+          case subject
+          when Array
+            subject.each do |item|
+              result = resolve(locale, object, item, options) and return result
+            end and nil
+          else
+            resolve(locale, object, subject, options)
+          end
+        end
+
+        # Resolves a translation.
+        # If the given subject is a Symbol, it will be translated with the
+        # given options. If it is a Proc then it will be evaluated. All other
+        # subjects will be returned directly.
+        def resolve(locale, object, subject, options = nil)
+          return subject if options[:resolve] == false
+          case subject
+          when Symbol
+            I18n.translate(subject, (options || {}).merge(:locale => locale, :raise => true))
+          when Proc
+            date_or_time = options.delete(:object) || object
+            resolve(locale, object, subject.call(date_or_time, options), options = {})
+          else
+            subject
+          end
+        rescue MissingTranslationData
+          nil
+        end
+
+        # Picks a translation from an array according to English pluralization
+        # rules. It will pick the first translation if count is not equal to 1
+        # and the second translation if it is equal to 1. Other backends can
+        # implement more flexible or complex pluralization rules.
+        def pluralize(locale, entry, count)
+          return entry unless entry.is_a?(Hash) && count
+
+          key = :zero if count == 0 && entry.has_key?(:zero)
+          key ||= count == 1 ? :one : :other
+          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
+          entry[key]
+        end
+
+        # Interpolates values into a given string.
+        #
+        #   interpolate "file %{file} opened by %%{user}", :file => 'test.txt', :user => 'Mr. X'
+        #   # => "file test.txt opened by %{user}"
+        #
+        # Note that you have to double escape the <tt>\\</tt> when you want to escape
+        # the <tt>{{...}}</tt> key in a string (once for the string and once for the
+        # interpolation).
+        def interpolate(locale, string, values = {})
+          return string unless string.is_a?(::String) && !values.empty?
+          original_values = values.dup
+
+          preserve_encoding(string) do
+            string = string.gsub(DEPRECATED_INTERPOLATION_SYNTAX_PATTERN) do
+              escaped, key = $1, $2.to_sym
+              if escaped
+                "{{#{key}}}"
+              else
+                warn_syntax_deprecation!
+                "%{#{key}}"
+              end
+            end
+
+            keys = string.scan(INTERPOLATION_SYNTAX_PATTERN).flatten
+            return string if keys.empty?
+
+            values.each do |key, value|
+              if keys.include?(key.to_s)
+                value = value.call(values) if interpolate_lambda?(value, string, key)
+                value = value.to_s unless value.is_a?(::String)
+                values[key] = value
+              else
+                values.delete(key)
+              end
+            end
+
+            string % values
+          end
+        rescue KeyError => e
+          if string =~ RESERVED_KEYS_PATTERN
+            raise ReservedInterpolationKey.new($1.to_sym, string)
+          else
+            raise MissingInterpolationArgument.new(original_values, string)
+          end
+        end
+
+        def preserve_encoding(string)
+          if string.respond_to?(:encoding)
+            encoding = string.encoding
+            result = yield
+            result.force_encoding(encoding) if result.respond_to?(:force_encoding)
+            result
+          else
+            yield
+          end
+        end
+
+        # returns true when the given value responds to :call and the key is
+        # an interpolation placeholder in the given string
+        def interpolate_lambda?(object, string, key)
+          object.respond_to?(:call) && string =~ /%\{#{key}\}|%\<#{key}>.*?\d*\.?\d*[bBdiouxXeEfgGcps]\}/
+        end
+
+        # Loads a single translations file by delegating to #load_rb or
+        # #load_yml depending on the file extension and directly merges the
+        # data to the existing translations. Raises I18n::UnknownFileType
+        # for all other file extensions.
+        def load_file(filename)
+          type = File.extname(filename).tr('.', '').downcase
+          raise UnknownFileType.new(type, filename) unless respond_to?(:"load_#{type}")
+          data = send(:"load_#{type}", filename) # TODO raise a meaningful exception if this does not yield a Hash
+          data.each { |locale, d| store_translations(locale, d) }
+        end
+
+        # Loads a plain Ruby translations file. eval'ing the file must yield
+        # a Hash containing translation data with locales as toplevel keys.
+        def load_rb(filename)
+          eval(IO.read(filename), binding, filename)
+        end
+
+        # Loads a YAML translations file. The data must have locales as
+        # toplevel keys.
+        def load_yml(filename)
+          YAML::load(IO.read(filename))
+        end
+
+        def warn_syntax_deprecation! #:nodoc:
+          return if @skip_syntax_deprecation
+          warn "The {{key}} interpolation syntax in I18n messages is deprecated. Please use %{key} instead.\n#{caller.join("\n")}"
+          @skip_syntax_deprecation = true
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cache.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cache.rb
new file mode 100644
index 0000000..25e6001
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cache.rb
@@ -0,0 +1,77 @@
+# encoding: utf-8
+
+# This module allows you to easily cache all responses from the backend - thus
+# speeding up the I18n aspects of your application quite a bit.
+#
+# To enable caching you can simply include the Cache module to the Simple
+# backend - or whatever other backend you are using:
+#
+#  I18n::Backend::Simple.send(:include, I18n::Backend::Cache)
+#
+# You will also need to set a cache store implementation that you want to use:
+#
+#  I18n.cache_store = ActiveSupport::Cache.lookup_store(:memory_store)
+#
+# You can use any cache implementation you want that provides the same API as
+# ActiveSupport::Cache (only the methods #fetch and #write are being used).
+#
+# The cache_key implementation assumes that you only pass values to
+# I18n.translate that return a valid key from #hash (see
+# http://www.ruby-doc.org/core/classes/Object.html#M000337).
+module I18n
+  class << self
+    @@cache_store = nil
+    @@cache_namespace = nil
+
+    def cache_store
+      @@cache_store
+    end
+
+    def cache_store=(store)
+      @@cache_store = store
+    end
+
+    def cache_namespace
+      @@cache_namespace
+    end
+
+    def cache_namespace=(namespace)
+      @@cache_namespace = namespace
+    end
+
+    def perform_caching?
+      !cache_store.nil?
+    end
+  end
+
+  module Backend
+    # TODO Should the cache be cleared if new translations are stored?
+    module Cache
+      def translate(*args)
+        I18n.perform_caching? ? fetch(*args) { super } : super
+      end
+
+      protected
+
+        def fetch(*args, &block)
+          result = I18n.cache_store.fetch(cache_key(*args), &block)
+          raise result if result.is_a?(Exception)
+          result = result.dup if result.frozen? rescue result
+          result
+        rescue MissingTranslationData => exception
+          I18n.cache_store.write(cache_key(*args), exception)
+          raise exception
+        end
+
+        def cache_key(*args)
+          # This assumes that only simple, native Ruby values are passed to I18n.translate.
+          # Also, in Ruby < 1.8.7 {}.hash != {}.hash
+          # (see http://paulbarry.com/articles/2009/09/14/why-rails-3-will-require-ruby-1-8-7)
+          # If args.inspect does not work for you for some reason, patches are very welcome :)
+          hash = RUBY_VERSION >= "1.8.7" ? args.hash : args.inspect
+          keys = ['i18n', I18n.cache_namespace, hash]
+          keys.compact.join('-')
+        end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cascade.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cascade.rb
new file mode 100644
index 0000000..370fb48
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cascade.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+
+# EXPERIMENTAL
+#
+# The Cascade module adds the ability to do cascading lookups to backends that
+# are compatible to the Simple backend.
+#
+# By cascading lookups we mean that for any key that can not be found the
+# Cascade module strips one segment off the scope part of the key and then
+# tries to look up the key in that scope.
+#
+# E.g. when a lookup for the key :"foo.bar.baz" does not yield a result then
+# the segment :bar will be stripped off the scope part :"foo.bar" and the new
+# scope :foo will be used to look up the key :baz. If that does not succeed
+# then the remaining scope segment :foo will be omitted, too, and again the
+# key :baz will be looked up (now with no scope).
+#
+# To enable a cascading lookup one passes the :cascade option:
+#
+#   I18n.t(:'foo.bar.baz', :cascade => true)
+#
+# This will return the first translation found for :"foo.bar.baz", :"foo.baz"
+# or :baz in this order.
+#
+# The cascading lookup takes precedence over resolving any given defaults.
+# I.e. defaults will kick in after the cascading lookups haven't succeeded.
+#
+# This behavior is useful for libraries like ActiveRecord validations where
+# the library wants to give users a bunch of more or less fine-grained options
+# of scopes for a particular key.
+#
+# Thanks to Clemens Kofler for the initial idea and implementation! See
+# http://github.com/clemens/i18n-cascading-backend
+
+module I18n
+  module Backend
+    module Cascade
+      def lookup(locale, key, scope = [], options = {})
+        return super unless cascade = options[:cascade]
+
+        separator = options[:separator] || I18n.default_separator
+        skip_root = cascade.has_key?(:skip_root) ? cascade[:skip_root] : true
+        step      = cascade[:step]
+
+        keys   = I18n.normalize_keys(nil, key, nil, separator)
+        offset = options[:cascade][:offset] || keys.length
+        scope  = I18n.normalize_keys(nil, nil, scope, separator) + keys
+        key    = scope.slice!(-offset, offset).join(separator)
+
+        begin
+          result = super
+          return result unless result.nil?
+        end while !scope.empty? && scope.slice!(-step, step) && (!scope.empty? || !skip_root)
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/chain.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/chain.rb
new file mode 100644
index 0000000..f73a69f
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/chain.rb
@@ -0,0 +1,77 @@
+# encoding: utf-8
+
+module I18n
+  module Backend
+    # Backend that chains multiple other backends and checks each of them when
+    # a translation needs to be looked up. This is useful when you want to use
+    # standard translations with a Simple backend but store custom application
+    # translations in a database or other backends.
+    #
+    # To use the Chain backend instantiate it and set it to the I18n module.
+    # You can add chained backends through the initializer or backends
+    # accessor:
+    #
+    #   # preserves the existing Simple backend set to I18n.backend
+    #   I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
+    #
+    # The implementation assumes that all backends added to the Chain implement
+    # a lookup method with the same API as Simple backend does.
+    class Chain
+      include Base
+
+      attr_accessor :backends
+
+      def initialize(*backends)
+        self.backends = backends
+      end
+
+      def reload!
+        backends.each { |backend| backend.reload! }
+      end
+
+      def store_translations(locale, data, options = {})
+        backends.first.store_translations(locale, data, options = {})
+      end
+
+      def available_locales
+        backends.map { |backend| backend.available_locales }.flatten.uniq
+      end
+
+      def translate(locale, key, options = {})
+        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
+
+        default = options.delete(:default)
+        namespace = {}
+        backends.each do |backend|
+          begin
+            options.update(:default => default) if default and backend == backends.last
+            translation = backend.translate(locale, key, options)
+            if namespace_lookup?(translation, options)
+              namespace.update(translation)
+            elsif !translation.nil?
+              return translation
+            end
+          rescue MissingTranslationData
+          end
+        end
+        return namespace unless namespace.empty?
+        raise(I18n::MissingTranslationData.new(locale, key, options))
+      end
+
+      def localize(locale, object, format = :default, options = {})
+        backends.each do |backend|
+          begin
+            result = backend.localize(locale, object, format, options) and return result
+          rescue MissingTranslationData
+          end
+        end
+        raise(I18n::MissingTranslationData.new(locale, format, options))
+      end
+
+      protected
+        def namespace_lookup?(result, options)
+          result.is_a?(Hash) and not options.has_key?(:count)
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cldr.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cldr.rb
new file mode 100644
index 0000000..d702f22
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/cldr.rb
@@ -0,0 +1,100 @@
+# encoding: utf-8
+require 'cldr'
+
+module I18n
+  module Backend
+    module Cldr
+      include ::Cldr::Format
+
+      def localize(locale, object, format = :default, options = {})
+        options[:as] ||= detect_type(object, options)
+        send(:"format_#{options[:as]}", locale, object, format, options)
+      end
+
+      def format_decimal(locale, object, format = :default, options = {})
+        formatter(locale, :decimal, format).apply(object, options)
+      end
+
+      def format_integer(locale, object, format = :default, options = {})
+        format_object(number, options.merge(:precision => 0))
+      end
+
+      def format_currency(locale, object, format = :default, options = {})
+        options.merge!(:currency => lookup_currency(locale, options[:currency], object)) if options[:currency].is_a?(Symbol)
+        formatter(locale, :currency, format).apply(object, options)
+      end
+
+      def format_percent(locale, object, format = :default, options = {})
+        formatter(locale, :percent, format).apply(object, options)
+      end
+
+      def format_date(locale, object, format = :default, options = {})
+        formatter(locale, :date, format).apply(object, options)
+      end
+
+      def format_time(locale, object, format = :default, options = {})
+        formatter(locale, :time, format).apply(object, options)
+      end
+
+      def format_datetime(locale, object, format = :default, options = {})
+        key  = :"calendars.gregorian.formats.datetime.#{format}.pattern"
+        date = I18n.l(object, :format => options[:date_format] || format, :locale => locale, :as => :date)
+        time = I18n.l(object, :format => options[:time_format] || format, :locale => locale, :as => :time)
+        I18n.t(key, :date => date, :time => time, :locale => locale, :raise => true)
+      end
+
+      protected
+
+        def detect_type(object, options)
+          options.has_key?(:currency) ? :currency : case object
+          when ::Numeric
+            :decimal
+          when ::Date, ::DateTime, ::Time
+            object.class.name.downcase.to_sym
+          else
+            raise_unspecified_format_type!
+          end
+        end
+
+        def formatter(locale, type, format)
+          (@formatters ||= {})[:"#{locale}.#{type}.#{format}"] ||= begin
+            format = lookup_format(locale, type, format)
+            data   = lookup_format_data(locale, type)
+            ::Cldr::Format.const_get(type.to_s.camelize).new(format, data)
+          end
+        end
+
+        def lookup_format(locale, type, format)
+          key = case type
+          when :date, :time, :datetime
+            :"calendars.gregorian.formats.#{type}.#{format}.pattern"
+          else
+            :"numbers.formats.#{type}.patterns.#{format || :default}"
+          end
+          I18n.t(key, :locale => locale, :raise => true)
+        end
+
+        def lookup_format_data(locale, type)
+          key = case type
+          when :date, :time, :datetime
+            :'calendars.gregorian'
+          else
+            :'numbers.symbols'
+          end
+          I18n.t(key, :locale => locale, :raise => true)
+        end
+
+        def lookup_currency(locale, currency, count)
+          I18n.t(:"currencies.#{currency}", :locale => locale, :count => count)
+        end
+
+        def raise_unspecified_format_type!
+          raise ArgumentError.new("You have to specify a format type, e.g. :as => :number.")
+        end
+
+        def raise_unspecified_currency!
+          raise ArgumentError.new("You have to specify a currency, e.g. :currency => 'EUR'.")
+        end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/fallbacks.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/fallbacks.rb
new file mode 100644
index 0000000..1e014be
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/fallbacks.rb
@@ -0,0 +1,69 @@
+# encoding: utf-8
+
+# I18n locale fallbacks are useful when you want your application to use
+# translations from other locales when translations for the current locale are
+# missing. E.g. you might want to use :en translations when translations in
+# your applications main locale :de are missing.
+#
+# To enable locale fallbacks you can simply include the Fallbacks module to
+# the Simple backend - or whatever other backend you are using:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Fallbacks)
+module I18n
+  @@fallbacks = nil
+
+  class << self
+    # Returns the current fallbacks implementation. Defaults to +I18n::Locale::Fallbacks+.
+    def fallbacks
+      @@fallbacks ||= I18n::Locale::Fallbacks.new
+    end
+
+    # Sets the current fallbacks implementation. Use this to set a different fallbacks implementation.
+    def fallbacks=(fallbacks)
+      @@fallbacks = fallbacks
+    end
+  end
+
+  module Backend
+    module Fallbacks
+      # Overwrites the Base backend translate method so that it will try each
+      # locale given by I18n.fallbacks for the given locale. E.g. for the
+      # locale :"de-DE" it might try the locales :"de-DE", :de and :en
+      # (depends on the fallbacks implementation) until it finds a result with
+      # the given options. If it does not find any result for any of the
+      # locales it will then raise a MissingTranslationData exception as
+      # usual.
+      #
+      # The default option takes precedence over fallback locales
+      # only when it's not a String. When default contains String it
+      # is evaluated after fallback locales.
+      def translate(locale, key, options = {})
+        default = extract_string_default!(options) if options[:default]
+
+        I18n.fallbacks[locale].each do |fallback|
+          begin
+            result = super(fallback, key, options)
+            return result unless result.nil?
+          rescue I18n::MissingTranslationData
+          end
+        end
+
+        return super(locale, nil, options.merge(:default => default)) if default
+        raise(I18n::MissingTranslationData.new(locale, key, options))
+      end
+
+      def extract_string_default!(options)
+        defaults = Array(options[:default])
+        if index = find_first_string_default(defaults)
+          options[:default] = defaults[0, index]
+          defaults[index]
+        end
+      end
+
+      def find_first_string_default(defaults)
+        defaults.each_index { |ix| return ix if String === defaults[ix] }
+        nil
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/flatten.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/flatten.rb
new file mode 100644
index 0000000..c23f7c1
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/flatten.rb
@@ -0,0 +1,113 @@
+module I18n
+  module Backend
+    # This module contains several helpers to assist flattening translations.
+    # You may want to flatten translations for:
+    #
+    #   1) speed up lookups, as in the Memoize backend;
+    #   2) In case you want to store translations in a data store, as in ActiveRecord backend;
+    #
+    # You can check both backends above for some examples.
+    # This module also keeps all links in a hash so they can be properly resolved when flattened.
+    module Flatten
+      SEPARATOR_ESCAPE_CHAR = "\001"
+      FLATTEN_SEPARATOR = "."
+
+      # normalize_keys the flatten way. This method is significantly faster
+      # and creates way less objects than the one at I18n.normalize_keys.
+      # It also handles escaping the translation keys.
+      def self.normalize_flat_keys(locale, key, scope, separator)
+        keys = [scope, key].flatten.compact
+        separator ||= I18n.default_separator
+
+        if separator != FLATTEN_SEPARATOR
+          keys.map! do |k|
+            k.to_s.tr("#{FLATTEN_SEPARATOR}#{separator}",
+              "#{SEPARATOR_ESCAPE_CHAR}#{FLATTEN_SEPARATOR}")
+          end
+        end
+
+        keys.join(".")
+      end
+
+      # Receives a string and escape the default separator.
+      def self.escape_default_separator(key) #:nodoc:
+        key.to_s.tr(FLATTEN_SEPARATOR, SEPARATOR_ESCAPE_CHAR)
+      end
+
+      # Shortcut to I18n::Backend::Flatten.normalize_flat_keys
+      # and then resolve_links.
+      def normalize_flat_keys(locale, key, scope, separator)
+        key = I18n::Backend::Flatten.normalize_flat_keys(locale, key, scope, separator)
+        resolve_link(locale, key)
+      end
+
+      # Store flattened links.
+      def links
+        @links ||= Hash.new { |h,k| h[k] = {} }
+      end
+
+      # Flatten keys for nested Hashes by chaining up keys:
+      #
+      #   >> { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}.wind
+      #   => { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }
+      #
+      def flatten_keys(hash, escape, prev_key=nil, &block)
+        hash.each_pair do |key, value|
+          key = escape_default_separator(key) if escape
+          curr_key = [prev_key, key].compact.join(FLATTEN_SEPARATOR).to_sym
+          yield curr_key, value
+          flatten_keys(value, escape, curr_key, &block) if value.is_a?(Hash)
+        end
+      end
+
+      # Receives a hash of translations (where the key is a locale and
+      # the value is another hash) and return a hash with all
+      # translations flattened.
+      #
+      # Nested hashes are included in the flattened hash just if subtree
+      # is true and Symbols are automatically stored as links.
+      def flatten_translations(locale, data, escape, subtree)
+        hash = {}
+        flatten_keys(data, escape) do |key, value|
+          if value.is_a?(Hash)
+            hash[key] = value if subtree
+          else
+            store_link(locale, key, value) if value.is_a?(Symbol)
+            hash[key] = value
+          end
+        end
+        hash
+      end
+
+      protected
+
+        def store_link(locale, key, link)
+          links[locale.to_sym][key.to_s] = link.to_s
+        end
+
+        def resolve_link(locale, key)
+          key, locale = key.to_s, locale.to_sym
+          links = self.links[locale]
+
+          if links.key?(key)
+            links[key]
+          elsif link = find_link(locale, key)
+            store_link(locale, key, key.gsub(*link))
+          else
+            key
+          end
+        end
+
+        def find_link(locale, key) #:nodoc:
+          links[locale].each do |from, to|
+            return [from, to] if key[0, from.length] == from
+          end && nil
+        end
+
+        def escape_default_separator(key) #:nodoc:
+          I18n::Backend::Flatten.escape_default_separator(key)
+        end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/gettext.rb
new file mode 100644
index 0000000..7f8ad22
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/gettext.rb
@@ -0,0 +1,75 @@
+# encoding: utf-8
+
+require 'i18n/gettext'
+require 'i18n/gettext/po_parser'
+
+# Experimental support for using Gettext po files to store translations.
+#
+# To use this you can simply include the module to the Simple backend - or
+# whatever other backend you are using.
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Gettext)
+#
+# Now you should be able to include your Gettext translation (*.po) files to
+# the I18n.load_path so they're loaded to the backend and you can use them as
+# usual:
+#
+#  I18n.load_path += Dir["path/to/locales/*.po"]
+#
+# Following the Gettext convention this implementation expects that your
+# translation files are named by their locales. E.g. the file en.po would
+# contain the translations for the English locale.
+module I18n
+  module Backend
+    module Gettext
+      class PoData < Hash
+        def set_comment(msgid_or_sym, comment)
+          # ignore
+        end
+      end
+
+      protected
+        def load_po(filename)
+          locale = ::File.basename(filename, '.po').to_sym
+          data = normalize(locale, parse(filename))
+          { locale => data }
+        end
+
+        def parse(filename)
+          GetText::PoParser.new.parse(::File.read(filename), PoData.new)
+        end
+
+        def normalize(locale, data)
+          data.inject({}) do |result, (key, value)|
+            unless key.nil? || key.empty?
+              key, value = normalize_pluralization(locale, key, value) if key.index("\000")
+
+              parts = key.split('|').reverse
+              normalized = parts.inject({}) do |normalized, part|
+                normalized = { part => normalized.empty? ? value : normalized }
+              end
+
+              # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
+              merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
+              result.merge!(normalized, &merger)
+            end
+            result
+          end
+        end
+
+        def normalize_pluralization(locale, key, value)
+          # FIXME po_parser includes \000 chars that can not be turned into Symbols
+          key = key.gsub("\000", I18n::Gettext::PLURAL_SEPARATOR).split(I18n::Gettext::PLURAL_SEPARATOR).first
+
+          keys = I18n::Gettext.plural_keys(locale)
+          values = value.split("\000")
+          raise "invalid number of plurals: #{values.size}, keys: #{keys.inspect}" if values.size != keys.size
+
+          result = {}
+          values.each_with_index { |value, ix| result[keys[ix]] = value }
+          [key, result]
+        end
+
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/interpolation_compiler.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/interpolation_compiler.rb
new file mode 100644
index 0000000..8c7c9c9
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/interpolation_compiler.rb
@@ -0,0 +1,123 @@
+# encoding: utf-8
+
+# The InterpolationCompiler module contains optimizations that can tremendously
+# speed up the interpolation process on the Simple backend.
+#
+# It works by defining a pre-compiled method on stored translation Strings that
+# already bring all the knowledge about contained interpolation variables etc.
+# so that the actual recurring interpolation will be very fast.
+#
+# To enable pre-compiled interpolations you can simply include the
+# InterpolationCompiler module to the Simple backend:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::InterpolationCompiler)
+#
+# Note that InterpolationCompiler does not yield meaningful results and consequently
+# should not be used with Ruby 1.9 (YARV) but improves performance everywhere else
+# (jRuby, Rubinius and 1.8.7).
+module I18n
+  module Backend
+    module InterpolationCompiler
+      module Compiler
+        extend self
+
+        TOKENIZER                    = /(%%\{[^\}]+\}|%\{[^\}]+\})/
+        INTERPOLATION_SYNTAX_PATTERN = /(%)?(%\{([^\}]+)\})/
+
+        def compile_if_an_interpolation(string)
+          if interpolated_str?(string)
+            string.instance_eval <<-RUBY_EVAL, __FILE__, __LINE__
+              def i18n_interpolate(v = {})
+                "#{compiled_interpolation_body(string)}"
+              end
+            RUBY_EVAL
+          end
+
+          string
+        end
+
+        def interpolated_str?(str)
+          str.kind_of?(::String) && str =~ INTERPOLATION_SYNTAX_PATTERN
+        end
+
+        protected
+        # tokenize("foo %{bar} baz %%{buz}") # => ["foo ", "%{bar}", " baz ", "%%{buz}"]
+        def tokenize(str)
+          str.split(TOKENIZER)
+        end
+
+        def compiled_interpolation_body(str)
+          tokenize(str).map do |token|
+            (matchdata = token.match(INTERPOLATION_SYNTAX_PATTERN)) ? handle_interpolation_token(token, matchdata) : escape_plain_str(token)
+          end.join
+        end
+
+        def handle_interpolation_token(interpolation, matchdata)
+          escaped, pattern, key = matchdata.values_at(1, 2, 3)
+          escaped ? pattern : compile_interpolation_token(key.to_sym)
+        end
+
+        def compile_interpolation_token(key)
+          "\#{#{interpolate_or_raise_missing(key)}}"
+        end
+
+        def interpolate_or_raise_missing(key)
+          escaped_key = escape_key_sym(key)
+          Base::RESERVED_KEYS.include?(key) ? reserved_key(escaped_key) : interpolate_key(escaped_key)
+        end
+
+        def interpolate_key(key)
+          [direct_key(key), nil_key(key), missing_key(key)].join('||')
+        end
+
+        def direct_key(key)
+          "((t = v[#{key}]) && t.respond_to?(:call) ? t.call : t)"
+        end
+
+        def nil_key(key)
+          "(v.has_key?(#{key}) && '')"
+        end
+
+        def missing_key(key)
+          "raise(MissingInterpolationArgument.new(#{key}, self))"
+        end
+
+        def reserved_key(key)
+          "raise(ReservedInterpolationKey.new(#{key}, self))"
+        end
+
+        def escape_plain_str(str)
+          str.gsub(/"|\\|#/) {|x| "\\#{x}"}
+        end
+
+        def escape_key_sym(key)
+          # rely on Ruby to do all the hard work :)
+          key.to_sym.inspect
+        end
+      end
+
+      def interpolate(locale, string, values)
+        if string.respond_to?(:i18n_interpolate)
+          string.i18n_interpolate(values)
+        elsif values
+          super
+        else
+          string
+        end
+      end
+
+      def store_translations(locale, data, options = {})
+        compile_all_strings_in(data)
+        super
+      end
+
+      protected
+      def compile_all_strings_in(data)
+        data.each_value do |value|
+          Compiler.compile_if_an_interpolation(value)
+          compile_all_strings_in(value) if value.kind_of?(Hash)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/key_value.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/key_value.rb
new file mode 100644
index 0000000..d0265ab
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/key_value.rb
@@ -0,0 +1,102 @@
+# encoding: utf-8
+
+require 'i18n/backend/base'
+require 'active_support/json'
+
+module I18n
+  module Backend
+    # This is a basic backend for key value stores. It receives on
+    # initialization the store, which should respond to three methods:
+    #
+    # * store#[](key)         - Used to get a value
+    # * store#[]=(key, value) - Used to set a value
+    # * store#keys            - Used to get all keys
+    #
+    # Since these stores only supports string, all values are converted
+    # to JSON before being stored, allowing it to also store booleans,
+    # hashes and arrays. However, this store does not support Procs.
+    #
+    # As the ActiveRecord backend, Symbols are just supported when loading
+    # translations from the filesystem or through explicit store translations.
+    #
+    # Also, avoid calling I18n.available_locales since it's a somehow
+    # expensive operation in most stores.
+    #
+    # == Example
+    #
+    # To setup I18n to use TokyoCabinet in memory is quite straightforward:
+    #
+    #   require 'rufus/tokyo/cabinet' # gem install rufus-tokyo
+    #   I18n.backend = I18n::Backend::KeyValue.new(Rufus::Tokyo::Cabinet.new('*'))
+    #
+    # == Performance
+    #
+    # You may make this backend even faster by including the Memoize module.
+    # However, notice that you should properly clear the cache if you change
+    # values directly in the key-store.
+    #
+    # == Subtrees
+    #
+    # In most backends, you are allowed to retrieve part of a translation tree:
+    #
+    #   I18n.backend.store_translations :en, :foo => { :bar => :baz }
+    #   I18n.t "foo" #=> { :bar => :baz }
+    #
+    # This backend supports this feature by default, but it slows down the storage
+    # of new data considerably and makes hard to delete entries. That said, you are
+    # allowed to disable the storage of subtrees on initialization:
+    #
+    #   I18n::Backend::KeyValue.new(@store, false)
+    #
+    # This is useful if you are using a KeyValue backend chained to a Simple backend.
+    class KeyValue
+      module Implementation
+        attr_accessor :store
+
+        include Base, Flatten
+
+        def initialize(store, subtrees=true)
+          @store, @subtrees = store, subtrees
+        end
+
+        def store_translations(locale, data, options = {})
+          escape = options.fetch(:escape, true)
+          flatten_translations(locale, data, escape, @subtrees).each do |key, value|
+            key = "#{locale}.#{key}"
+
+            case value
+            when Hash
+              if @subtrees && (old_value = @store[key])
+                old_value = ActiveSupport::JSON.decode(old_value)
+                value = old_value.deep_symbolize_keys.deep_merge!(value) if old_value.is_a?(Hash)
+              end
+            when Proc
+              raise "Key-value stores cannot handle procs"
+            end
+
+            @store[key] = ActiveSupport::JSON.encode(value) unless value.is_a?(Symbol)
+          end
+        end
+
+        def available_locales
+          locales = @store.keys.map { |k| k =~ /\./; $` }
+          locales.uniq!
+          locales.compact!
+          locales.map! { |k| k.to_sym }
+          locales
+        end
+
+      protected
+
+        def lookup(locale, key, scope = [], options = {})
+          key   = normalize_flat_keys(locale, key, scope, options[:separator])
+          value = @store["#{locale}.#{key}"]
+          value = ActiveSupport::JSON.decode(value) if value
+          value.is_a?(Hash) ? value.deep_symbolize_keys : value
+        end
+      end
+
+      include Implementation
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/memoize.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/memoize.rb
new file mode 100644
index 0000000..6e811d1
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/memoize.rb
@@ -0,0 +1,48 @@
+# encoding: utf-8
+#
+# Memoize module simply memoizes the values returned by lookup using
+# a flat hash and can tremendously speed up the lookup process in a backend.
+#
+# To enable it you can simply include the Memoize module to your backend:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Memoize)
+#
+# Notice that it's the responsibility of the backend to define whenever the
+# cache should be cleaned.
+module I18n
+  module Backend
+    module Memoize
+      def available_locales
+        @memoized_locales ||= super
+      end
+
+      def store_translations(locale, data, options = {})
+        reset_memoizations!(locale)
+        super
+      end
+
+      def reload!
+        reset_memoizations!
+        super
+      end
+
+      protected
+
+        def lookup(locale, key, scope = nil, options = {})
+          flat_key  = I18n::Backend::Flatten.normalize_flat_keys(locale,
+            key, scope, options[:separator]).to_sym
+          flat_hash = memoized_lookup[locale.to_sym]
+          flat_hash.key?(flat_key) ? flat_hash[flat_key] : (flat_hash[flat_key] = super)
+        end
+
+        def memoized_lookup
+          @memoized_lookup ||= Hash.new { |h, k| h[k] = {} }
+        end
+
+        def reset_memoizations!(locale=nil)
+          @memoized_locales = nil
+          (locale ? memoized_lookup[locale.to_sym] : memoized_lookup).clear
+        end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/metadata.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/metadata.rb
new file mode 100644
index 0000000..5237b4d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/metadata.rb
@@ -0,0 +1,65 @@
+# I18n translation metadata is useful when you want to access information
+# about how a translation was looked up, pluralized or interpolated in
+# your application.
+#
+#   msg = I18n.t(:message, :default => 'Hi!', :scope => :foo)
+#   msg.translation_metadata
+#   # => { :key => :message, :scope => :foo, :default => 'Hi!' }
+#
+# If a :count option was passed to #translate it will be set to the metadata.
+# Likewise, if any interpolation variables were passed they will also be set.
+#
+# To enable translation metadata you can simply include the Metadata module
+# into the Simple backend class - or whatever other backend you are using:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Metadata)
+#
+module I18n
+  module Backend
+    module Metadata
+      class << self
+        def included(base)
+          Object.class_eval do
+            def translation_metadata
+              @translation_metadata ||= {}
+            end
+
+            def translation_metadata=(translation_metadata)
+              @translation_metadata = translation_metadata
+            end
+          end unless Object.method_defined?(:translation_metadata)
+        end
+      end
+
+      def translate(locale, key, options = {})
+        metadata = {
+          :locale    => locale,
+          :key       => key,
+          :scope     => options[:scope],
+          :default   => options[:default],
+          :separator => options[:separator],
+          :values    => options.reject { |name, value| Base::RESERVED_KEYS.include?(name) }
+        }
+        with_metadata(metadata) { super }
+      end
+
+      def interpolate(locale, entry, values = {})
+        metadata = entry.translation_metadata.merge(:original => entry)
+        with_metadata(metadata) { super }
+      end
+
+      def pluralize(locale, entry, count)
+        with_metadata(:count => count) { super }
+      end
+
+      protected
+
+        def with_metadata(metadata, &block)
+          result = yield
+          result.translation_metadata = result.translation_metadata.merge(metadata) if result
+          result
+        end
+
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/pluralization.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/pluralization.rb
new file mode 100644
index 0000000..33a2aff
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/pluralization.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+
+# I18n locale fallbacks are useful when you want your application to use
+# translations from other locales when translations for the current locale are
+# missing. E.g. you might want to use :en translations when translations in
+# your applications main locale :de are missing.
+#
+# To enable locale specific pluralizations you can simply include the
+# Pluralization module to the Simple backend - or whatever other backend you
+# are using.
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Pluralization)
+#
+# You also need to make sure to provide pluralization algorithms to the
+# backend, i.e. include them to your I18n.load_path accordingly.
+module I18n
+  module Backend
+    module Pluralization
+      # Overwrites the Base backend translate method so that it will check the
+      # translation meta data space (:i18n) for a locale specific pluralization
+      # rule and use it to pluralize the given entry. I.e. the library expects
+      # pluralization rules to be stored at I18n.t(:'i18n.plural.rule')
+      #
+      # Pluralization rules are expected to respond to #call(entry, count) and
+      # return a pluralization key. Valid keys depend on the translation data
+      # hash (entry) but it is generally recommended to follow CLDR's style,
+      # i.e., return one of the keys :zero, :one, :few, :many, :other.
+      #
+      # The :zero key is always picked directly when count equals 0 AND the
+      # translation data has the key :zero. This way translators are free to
+      # either pick a special :zero translation even for languages where the
+      # pluralizer does not return a :zero key.
+      def pluralize(locale, entry, count)
+        return entry unless entry.is_a?(Hash) and count
+
+        pluralizer = pluralizer(locale)
+        if pluralizer.respond_to?(:call)
+          key = count == 0 && entry.has_key?(:zero) ? :zero : pluralizer.call(count)
+          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
+          entry[key]
+        else
+          super
+        end
+      end
+
+      protected
+
+        def pluralizers
+          @pluralizers ||= {}
+        end
+
+        def pluralizer(locale)
+          pluralizers[locale] ||= I18n.t(:'i18n.plural.rule', :locale => locale, :resolve => false)
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/simple.rb
new file mode 100644
index 0000000..30e2ac0
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/simple.rb
@@ -0,0 +1,87 @@
+# encoding: utf-8
+
+module I18n
+  module Backend
+    # A simple backend that reads translations from YAML files and stores them in
+    # an in-memory hash. Relies on the Base backend.
+    #
+    # The implementation is provided by a Implementation module allowing to easily
+    # extend Simple backend's behavior by including modules. E.g.:
+    #
+    # module I18n::Backend::Pluralization
+    #   def pluralize(*args)
+    #     # extended pluralization logic
+    #     super
+    #   end
+    # end
+    #
+    # I18n::Backend::Simple.send(:include, I18n::Backend::Pluralization)
+    class Simple
+      module Implementation
+        include Base
+
+        def initialized?
+          @initialized ||= false
+        end
+
+        # Stores translations for the given locale in memory.
+        # This uses a deep merge for the translations hash, so existing
+        # translations will be overwritten by new ones only at the deepest
+        # level of the hash.
+        def store_translations(locale, data, options = {})
+          locale = locale.to_sym
+          translations[locale] ||= {}
+          data = data.deep_symbolize_keys
+          translations[locale].deep_merge!(data)
+        end
+
+        # Get available locales from the translations hash
+        def available_locales
+          init_translations unless initialized?
+          translations.inject([]) do |locales, (locale, data)|
+            locales << locale unless (data.keys - [:i18n]).empty?
+            locales
+          end
+        end
+
+        # Clean up translations hash and set initialized to false on reload!
+        def reload!
+          @initialized = false
+          @translations = nil
+          super
+        end
+
+      protected
+
+        def init_translations
+          load_translations
+          @initialized = true
+        end
+
+        def translations
+          @translations ||= {}
+        end
+
+        # Looks up a translation from the translations hash. Returns nil if
+        # eiher key is nil, or locale, scope or key do not exist as a key in the
+        # nested translations hash. Splits keys or scopes containing dots
+        # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
+        # <tt>%w(currency format)</tt>.
+        def lookup(locale, key, scope = [], options = {})
+          init_translations unless initialized?
+          keys = I18n.normalize_keys(locale, key, scope, options[:separator])
+
+          keys.inject(translations) do |result, key|
+            key = key.to_sym
+            return nil unless result.is_a?(Hash) && result.has_key?(key)
+            result = result[key]
+            result = resolve(locale, key, result, options.merge(:scope => nil)) if result.is_a?(Symbol)
+            result
+          end
+        end
+      end
+
+      include Implementation
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/transliterator.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/transliterator.rb
new file mode 100644
index 0000000..2ce2cc8
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/backend/transliterator.rb
@@ -0,0 +1,98 @@
+# encoding: utf-8
+module I18n
+  module Backend
+    module Transliterator
+      DEFAULT_REPLACEMENT_CHAR = "?"
+
+      # Given a locale and a UTF-8 string, return the locale's ASCII
+      # approximation for the string.
+      def transliterate(locale, string, replacement = nil)
+        @transliterators ||= {}
+        @transliterators[locale] ||= Transliterator.get I18n.t(:'i18n.transliterate.rule',
+          :locale => locale, :resolve => false, :default => {})
+        @transliterators[locale].transliterate(string, replacement)
+      end
+
+      # Get a transliterator instance.
+      def self.get(rule = nil)
+        if !rule || rule.kind_of?(Hash)
+          HashTransliterator.new(rule)
+        elsif rule.kind_of? Proc
+          ProcTransliterator.new(rule)
+        else
+          raise I18n::ArgumentError, "Transliteration rule must be a proc or a hash."
+        end
+      end
+
+      # A transliterator which accepts a Proc as its transliteration rule.
+      class ProcTransliterator
+        def initialize(rule)
+          @rule = rule
+        end
+
+        def transliterate(string, replacement = nil)
+          @rule.call(string)
+        end
+      end
+
+      # A transliterator which accepts a Hash of characters as its translation
+      # rule.
+      class HashTransliterator
+        DEFAULT_APPROXIMATIONS = {
+          "À"=>"A", "Á"=>"A", "Â"=>"A", "Ã"=>"A", "Ä"=>"A", "Å"=>"A", "Æ"=>"AE",
+          "Ç"=>"C", "È"=>"E", "É"=>"E", "Ê"=>"E", "Ë"=>"E", "Ì"=>"I", "Í"=>"I",
+          "Î"=>"I", "Ï"=>"I", "Ð"=>"D", "Ñ"=>"N", "Ò"=>"O", "Ó"=>"O", "Ô"=>"O",
+          "Õ"=>"O", "Ö"=>"O", "×"=>"x", "Ø"=>"O", "Ù"=>"U", "Ú"=>"U", "Û"=>"U",
+          "Ü"=>"U", "Ý"=>"Y", "Þ"=>"Th", "ß"=>"ss", "à"=>"a", "á"=>"a", "â"=>"a",
+          "ã"=>"a", "ä"=>"a", "å"=>"a", "æ"=>"ae", "ç"=>"c", "è"=>"e", "é"=>"e",
+          "ê"=>"e", "ë"=>"e", "ì"=>"i", "í"=>"i", "î"=>"i", "ï"=>"i", "ð"=>"d",
+          "ñ"=>"n", "ò"=>"o", "ó"=>"o", "ô"=>"o", "õ"=>"o", "ö"=>"o", "ø"=>"o",
+          "ù"=>"u", "ú"=>"u", "û"=>"u", "ü"=>"u", "ý"=>"y", "þ"=>"th", "ÿ"=>"y",
+          "Ā"=>"A", "ā"=>"a", "Ă"=>"A", "ă"=>"a", "Ą"=>"A", "ą"=>"a", "Ć"=>"C",
+          "ć"=>"c", "Ĉ"=>"C", "ĉ"=>"c", "Ċ"=>"C", "ċ"=>"c", "Č"=>"C", "č"=>"c",
+          "Ď"=>"D", "ď"=>"d", "Đ"=>"D", "đ"=>"d", "Ē"=>"E", "ē"=>"e", "Ĕ"=>"E",
+          "ĕ"=>"e", "Ė"=>"E", "ė"=>"e", "Ę"=>"E", "ę"=>"e", "Ě"=>"E", "ě"=>"e",
+          "Ĝ"=>"G", "ĝ"=>"g", "Ğ"=>"G", "ğ"=>"g", "Ġ"=>"G", "ġ"=>"g", "Ģ"=>"G",
+          "ģ"=>"g", "Ĥ"=>"H", "ĥ"=>"h", "Ħ"=>"H", "ħ"=>"h", "Ĩ"=>"I", "ĩ"=>"i",
+          "Ī"=>"I", "ī"=>"i", "Ĭ"=>"I", "ĭ"=>"i", "Į"=>"I", "į"=>"i", "İ"=>"I",
+          "ı"=>"i", "Ĳ"=>"IJ", "ĳ"=>"ij", "Ĵ"=>"J", "ĵ"=>"j", "Ķ"=>"K", "ķ"=>"k",
+          "ĸ"=>"k", "Ĺ"=>"L", "ĺ"=>"l", "Ļ"=>"L", "ļ"=>"l", "Ľ"=>"L", "ľ"=>"l",
+          "Ŀ"=>"L", "ŀ"=>"l", "Ł"=>"L", "ł"=>"l", "Ń"=>"N", "ń"=>"n", "Ņ"=>"N",
+          "ņ"=>"n", "Ň"=>"N", "ň"=>"n", "ŉ"=>"'n", "Ŋ"=>"NG", "ŋ"=>"ng",
+          "Ō"=>"O", "ō"=>"o", "Ŏ"=>"O", "ŏ"=>"o", "Ő"=>"O", "ő"=>"o", "Œ"=>"OE",
+          "œ"=>"oe", "Ŕ"=>"R", "ŕ"=>"r", "Ŗ"=>"R", "ŗ"=>"r", "Ř"=>"R", "ř"=>"r",
+          "Ś"=>"S", "ś"=>"s", "Ŝ"=>"S", "ŝ"=>"s", "Ş"=>"S", "ş"=>"s", "Š"=>"S",
+          "š"=>"s", "Ţ"=>"T", "ţ"=>"t", "Ť"=>"T", "ť"=>"t", "Ŧ"=>"T", "ŧ"=>"t",
+          "Ũ"=>"U", "ũ"=>"u", "Ū"=>"U", "ū"=>"u", "Ŭ"=>"U", "ŭ"=>"u", "Ů"=>"U",
+          "ů"=>"u", "Ű"=>"U", "ű"=>"u", "Ų"=>"U", "ų"=>"u", "Ŵ"=>"W", "ŵ"=>"w",
+          "Ŷ"=>"Y", "ŷ"=>"y", "Ÿ"=>"Y", "Ź"=>"Z", "ź"=>"z", "Ż"=>"Z", "ż"=>"z",
+          "Ž"=>"Z", "ž"=>"z"
+        }
+
+        def initialize(rule = nil)
+          @rule = rule
+          add DEFAULT_APPROXIMATIONS
+          add rule if rule
+        end
+
+        def transliterate(string, replacement = nil)
+          string.gsub(/[^\x00-\x7f]/u) do |char|
+            approximations[char] || replacement || DEFAULT_REPLACEMENT_CHAR
+          end
+        end
+
+        private
+
+          def approximations
+            @approximations ||= {}
+          end
+
+          # Add transliteration rules to the approximations hash.
+          def add(hash)
+            hash.keys.each {|key| hash[key.to_s] = hash.delete(key).to_s}
+            approximations.merge! hash
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/config.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/config.rb
new file mode 100644
index 0000000..ceac1d8
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/config.rb
@@ -0,0 +1,84 @@
+module I18n
+  class Config
+    # The only configuration value that is not global and scoped to thread is :locale.
+    # It defaults to the default_locale.
+    def locale
+      @locale ||= default_locale
+    end
+
+    # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
+    def locale=(locale)
+      @locale = locale.to_sym rescue nil
+    end
+
+    # Returns the current backend. Defaults to +Backend::Simple+.
+    def backend
+      @@backend ||= Backend::Simple.new
+    end
+
+    # Sets the current backend. Used to set a custom backend.
+    def backend=(backend)
+      @@backend = backend
+    end
+
+    # Returns the current default locale. Defaults to :'en'
+    def default_locale
+      @@default_locale ||= :en
+    end
+
+    # Sets the current default locale. Used to set a custom default locale.
+    def default_locale=(locale)
+      @@default_locale = locale.to_sym rescue nil
+    end
+
+    # Returns an array of locales for which translations are available.
+    # Unless you explicitely set the these through I18n.available_locales=
+    # the call will be delegated to the backend and memoized on the I18n module.
+    def available_locales
+      @@available_locales ||= backend.available_locales
+    end
+
+    # Sets the available locales.
+    def available_locales=(locales)
+      @@available_locales = locales
+    end
+
+    # Returns the current default scope separator. Defaults to '.'
+    def default_separator
+      @@default_separator ||= '.'
+    end
+
+    # Sets the current default scope separator.
+    def default_separator=(separator)
+      @@default_separator = separator
+    end
+
+    # Return the current exception handler. Defaults to :default_exception_handler.
+    def exception_handler
+      @@exception_handler ||= :default_exception_handler
+    end
+
+    # Sets the exception handler.
+    def exception_handler=(exception_handler)
+      @@exception_handler = exception_handler
+    end
+
+    # Allow clients to register paths providing translation data sources. The
+    # backend defines acceptable sources.
+    #
+    # E.g. the provided SimpleBackend accepts a list of paths to translation
+    # files which are either named *.rb and contain plain Ruby Hashes or are
+    # named *.yml and contain YAML data. So for the SimpleBackend clients may
+    # register translation files like this:
+    #   I18n.load_path << 'path/to/locale/en.yml'
+    def load_path
+      @@load_path ||= []
+    end
+
+    # Sets the load path instance. Custom implementations are expected to
+    # behave like a Ruby Array.
+    def load_path=(load_path)
+      @@load_path = load_path
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/hash.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/hash.rb
new file mode 100644
index 0000000..f2a2422
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/hash.rb
@@ -0,0 +1,29 @@
+class Hash
+  def slice(*keep_keys)
+    h = {}
+    keep_keys.each { |key| h[key] = fetch(key) }
+    h
+  end unless Hash.method_defined?(:slice)
+
+  def except(*less_keys)
+    slice(*keys - less_keys)
+  end unless Hash.method_defined?(:except)
+
+  def deep_symbolize_keys
+    inject({}) { |result, (key, value)|
+      value = value.deep_symbolize_keys if value.is_a?(Hash)
+      result[(key.to_sym rescue key) || key] = value
+      result
+    }
+  end unless Hash.method_defined?(:deep_symbolize_keys)
+
+  # deep_merge_hash! by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
+  MERGER = proc do |key, v1, v2|
+    Hash === v1 && Hash === v2 ? v1.merge(v2, &MERGER) : v2
+  end
+  
+  def deep_merge!(data)
+    merge!(data, &MERGER)
+  end unless Hash.method_defined?(:deep_merge!)
+end
+
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/string/interpolate.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/string/interpolate.rb
new file mode 100644
index 0000000..585af6f
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/core_ext/string/interpolate.rb
@@ -0,0 +1,98 @@
+# encoding: utf-8
+
+=begin
+  heavily based on Masao Mutoh's gettext String interpolation extension
+  http://github.com/mutoh/gettext/blob/f6566738b981fe0952548c421042ad1e0cdfb31e/lib/gettext/core_ext/string.rb
+  Copyright (C) 2005-2009 Masao Mutoh
+  You may redistribute it and/or modify it under the same license terms as Ruby.
+=end
+
+begin
+  raise ArgumentError if ("a %{x}" % {:x=>'b'}) != 'a b'
+rescue ArgumentError
+  # KeyError is raised by String#% when the string contains a named placeholder
+  # that is not contained in the given arguments hash. Ruby 1.9 includes and
+  # raises this exception natively. We define it to mimic Ruby 1.9's behaviour
+  # in Ruby 1.8.x
+  class KeyError < IndexError
+    def initialize(message = nil)
+      super(message || "key not found")
+    end
+  end unless defined?(KeyError)
+
+  # Extension for String class. This feature is included in Ruby 1.9 or later but not occur TypeError.
+  #
+  # String#% method which accept "named argument". The translator can know
+  # the meaning of the msgids using "named argument" instead of %s/%d style.
+  class String
+    # For older ruby versions, such as ruby-1.8.5
+    alias :bytesize :size unless instance_methods.find {|m| m.to_s == 'bytesize'}
+    alias :interpolate_without_ruby_19_syntax :% # :nodoc:
+
+    INTERPOLATION_PATTERN = Regexp.union(
+      /%\{(\w+)\}/,                               # matches placeholders like "%{foo}"
+      /%<(\w+)>(.*?\d*\.?\d*[bBdiouxXeEfgGcps])/  # matches placeholders like "%<foo>.d"
+    )
+
+    INTERPOLATION_PATTERN_WITH_ESCAPE = Regexp.union(
+      /%%/,
+      INTERPOLATION_PATTERN
+    )
+
+    # % uses self (i.e. the String) as a format specification and returns the
+    # result of applying it to the given arguments. In other words it interpolates
+    # the given arguments to the string according to the formats the string
+    # defines.
+    #
+    # There are three ways to use it:
+    #
+    # * Using a single argument or Array of arguments.
+    #
+    #   This is the default behaviour of the String class. See Kernel#sprintf for
+    #   more details about the format string.
+    #
+    #   Example:
+    #
+    #     "%d %s" % [1, "message"]
+    #     # => "1 message"
+    #
+    # * Using a Hash as an argument and unformatted, named placeholders.
+    #
+    #   When you pass a Hash as an argument and specify placeholders with %{foo}
+    #   it will interpret the hash values as named arguments.
+    #
+    #   Example:
+    #
+    #     "%{firstname}, %{lastname}" % {:firstname => "Masao", :lastname => "Mutoh"}
+    #     # => "Masao Mutoh"
+    #
+    # * Using a Hash as an argument and formatted, named placeholders.
+    #
+    #   When you pass a Hash as an argument and specify placeholders with %<foo>d
+    #   it will interpret the hash values as named arguments and format the value
+    #   according to the formatting instruction appended to the closing >.
+    #
+    #   Example:
+    #
+    #     "%<integer>d, %<float>.1f" % { :integer => 10, :float => 43.4 }
+    #     # => "10, 43.3"
+    def %(args)
+      if args.kind_of?(Hash)
+        dup.gsub(INTERPOLATION_PATTERN_WITH_ESCAPE) do |match|
+          if match == '%%'
+            '%'
+          else
+            key = ($1 || $2).to_sym
+            raise KeyError unless args.has_key?(key)
+            $3 ? sprintf("%#{$3}", args[key]) : args[key]
+          end
+        end
+      elsif self =~ INTERPOLATION_PATTERN
+        raise ArgumentError.new('one hash required')
+      else
+        result = gsub(/%([{<])/, '%%\1')
+        result.send :'interpolate_without_ruby_19_syntax', args
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/exceptions.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/exceptions.rb
new file mode 100644
index 0000000..766a171
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/exceptions.rb
@@ -0,0 +1,61 @@
+# encoding: utf-8
+
+class KeyError < IndexError
+  def initialize(message = nil)
+    super(message || "key not found")
+  end
+end unless defined?(KeyError)
+
+module I18n
+  class ArgumentError < ::ArgumentError; end
+
+  class InvalidLocale < ArgumentError
+    attr_reader :locale
+    def initialize(locale)
+      @locale = locale
+      super "#{locale.inspect} is not a valid locale"
+    end
+  end
+
+  class MissingTranslationData < ArgumentError
+    attr_reader :locale, :key, :options
+    def initialize(locale, key, opts = nil)
+      @key, @locale, @options = key, locale, opts || {}
+      keys = I18n.normalize_keys(locale, key, options[:scope])
+      keys << 'no key' if keys.size < 2
+      super "translation missing: #{keys.join(', ')}"
+    end
+  end
+
+  class InvalidPluralizationData < ArgumentError
+    attr_reader :entry, :count
+    def initialize(entry, count)
+      @entry, @count = entry, count
+      super "translation data #{entry.inspect} can not be used with :count => #{count}"
+    end
+  end
+
+  class MissingInterpolationArgument < ArgumentError
+    attr_reader :values, :string
+    def initialize(values, string)
+      @values, @string = values, string
+      super "missing interpolation argument in #{string.inspect} (#{values.inspect} given)"
+    end
+  end
+
+  class ReservedInterpolationKey < ArgumentError
+    attr_reader :key, :string
+    def initialize(key, string)
+      @key, @string = key, string
+      super "reserved key #{key.inspect} used in #{string.inspect}"
+    end
+  end
+
+  class UnknownFileType < ArgumentError
+    attr_reader :type, :filename
+    def initialize(type, filename)
+      @type, @filename = type, filename
+      super "can not load translations from #{filename}, the file type #{type} is not known"
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext.rb
new file mode 100644
index 0000000..a824aa5
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext.rb
@@ -0,0 +1,27 @@
+# encoding: utf-8
+
+module I18n
+  module Gettext
+    PLURAL_SEPARATOR  = "\001"
+    CONTEXT_SEPARATOR = "\004"
+
+    autoload :Helpers, 'i18n/gettext/helpers'
+
+    @@plural_keys = { :en => [:one, :other] }
+
+    class << self
+      # returns an array of plural keys for the given locale so that we can
+      # convert from gettext's integer-index based style
+      # TODO move this information to the pluralization module
+      def plural_keys(locale)
+        @@plural_keys[locale] || @@plural_keys[:en]
+      end
+
+      def extract_scope(msgid, separator)
+        scope = msgid.to_s.split(separator)
+        msgid = scope.pop
+        [scope, msgid]
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/helpers.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/helpers.rb
new file mode 100644
index 0000000..1784163
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/helpers.rb
@@ -0,0 +1,65 @@
+# encoding: utf-8
+require 'i18n/gettext'
+
+module I18n
+  module Gettext
+    # Implements classical Gettext style accessors. To use this include the
+    # module to the global namespace or wherever you want to use it.
+    #
+    #   include I18n::Helpers::Gettext
+    module Helpers
+      def gettext(msgid, options = {})
+        I18n.t(msgid, { :default => msgid, :separator => '|' }.merge(options))
+      end
+      alias _ gettext
+
+      def sgettext(msgid, separator = '|')
+        scope, msgid = I18n::Gettext.extract_scope(msgid, separator)
+        I18n.t(msgid, :scope => scope, :default => msgid, :separator => separator)
+      end
+      alias s_ sgettext
+
+      def pgettext(msgctxt, msgid)
+        separator = I18n::Gettext::CONTEXT_SEPARATOR
+        sgettext([msgctxt, msgid].join(separator), separator)
+      end
+      alias p_ pgettext
+
+      def ngettext(msgid, msgid_plural, n = 1)
+        nsgettext(msgid, msgid_plural, n)
+      end
+      alias n_ ngettext
+
+      # Method signatures:
+      #   nsgettext('Fruits|apple', 'apples', 2)
+      #   nsgettext(['Fruits|apple', 'apples'], 2)
+      def nsgettext(msgid, msgid_plural, n = 1, separator = '|')
+        if msgid.is_a?(Array)
+          msgid, msgid_plural, n, separator = msgid[0], msgid[1], msgid_plural, n
+          separator = '|' unless separator.is_a?(::String)
+        end
+
+        scope, msgid = I18n::Gettext.extract_scope(msgid, separator)
+        default = { :one => msgid, :other => msgid_plural }
+        I18n.t(msgid, :default => default, :count => n, :scope => scope, :separator => separator)
+      end
+      alias ns_ nsgettext
+
+      # Method signatures:
+      #   npgettext('Fruits', 'apple', 'apples', 2)
+      #   npgettext('Fruits', ['apple', 'apples'], 2)
+      def npgettext(msgctxt, msgid, msgid_plural, n = 1)
+        separator = I18n::Gettext::CONTEXT_SEPARATOR
+
+        if msgid.is_a?(Array)
+          msgid_plural, msgid, n = msgid[1], [msgctxt, msgid[0]].join(separator), msgid_plural
+        else
+          msgid = [msgctxt, msgid].join(separator)
+        end
+
+        nsgettext(msgid, msgid_plural, n, separator)
+      end
+      alias np_ npgettext
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/po_parser.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/po_parser.rb
new file mode 100644
index 0000000..547df6a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/gettext/po_parser.rb
@@ -0,0 +1,329 @@
+=begin
+  poparser.rb - Generate a .mo
+
+  Copyright (C) 2003-2009 Masao Mutoh <mutoh at highway.ne.jp>
+
+  You may redistribute it and/or modify it under the same
+  license terms as Ruby.
+=end
+
+#MODIFIED
+# removed include GetText etc
+# added stub translation method _(x)
+require 'racc/parser'
+
+module GetText
+
+  class PoParser < Racc::Parser
+
+    def _(x)
+      x
+    end
+
+module_eval <<'..end src/poparser.ry modeval..id7a99570e05', 'src/poparser.ry', 108
+  def unescape(orig)
+    ret = orig.gsub(/\\n/, "\n")
+    ret.gsub!(/\\t/, "\t")
+    ret.gsub!(/\\r/, "\r")
+    ret.gsub!(/\\"/, "\"")
+    ret
+  end
+  
+  def parse(str, data, ignore_fuzzy = true)
+    @comments = []
+    @data = data
+    @fuzzy = false
+    @msgctxt = ""
+    $ignore_fuzzy = ignore_fuzzy
+
+    str.strip!
+    @q = []
+    until str.empty? do
+      case str
+      when /\A\s+/
+	str = $'
+      when /\Amsgctxt/
+	@q.push [:MSGCTXT, $&]
+	str = $'
+      when /\Amsgid_plural/
+	@q.push [:MSGID_PLURAL, $&]
+	str = $'
+      when /\Amsgid/
+	@q.push [:MSGID, $&]
+	str = $'
+      when /\Amsgstr/
+	@q.push [:MSGSTR, $&]
+	str = $'
+      when /\A\[(\d+)\]/
+	@q.push [:PLURAL_NUM, $1]
+	str = $'
+      when /\A\#~(.*)/
+	$stderr.print _("Warning: obsolete msgid exists.\n")
+	$stderr.print "         #{$&}\n"
+	@q.push [:COMMENT, $&]
+	str = $'
+      when /\A\#(.*)/
+	@q.push [:COMMENT, $&]
+	str = $'      
+      when /\A\"(.*)\"/
+	@q.push [:STRING, $1]
+	str = $'
+      else
+	#c = str[0,1]
+	#@q.push [:STRING, c]
+	str = str[1..-1]
+      end
+    end 
+    @q.push [false, '$end']
+    if $DEBUG
+      @q.each do |a,b|
+      puts "[#{a}, #{b}]"
+      end
+    end
+    @yydebug = true if $DEBUG
+    do_parse
+
+    if @comments.size > 0
+      @data.set_comment(:last, @comments.join("\n"))
+    end
+    @data
+  end
+  
+  def next_token
+    @q.shift
+  end
+
+  def on_message(msgid, msgstr)
+    if msgstr.size > 0
+      @data[msgid] = msgstr
+      @data.set_comment(msgid, @comments.join("\n"))
+    end
+    @comments.clear
+    @msgctxt = ""
+  end
+      
+  def on_comment(comment)
+    @fuzzy = true if (/fuzzy/ =~ comment)
+    @comments << comment
+  end 
+
+
+..end src/poparser.ry modeval..id7a99570e05
+
+##### racc 1.4.5 generates ###
+
+racc_reduce_table = [
+ 0, 0, :racc_error,
+ 0, 10, :_reduce_none,
+ 2, 10, :_reduce_none,
+ 2, 10, :_reduce_none,
+ 2, 10, :_reduce_none,
+ 2, 12, :_reduce_5,
+ 1, 13, :_reduce_none,
+ 1, 13, :_reduce_none,
+ 4, 15, :_reduce_8,
+ 5, 16, :_reduce_9,
+ 2, 17, :_reduce_10,
+ 1, 17, :_reduce_none,
+ 3, 18, :_reduce_12,
+ 1, 11, :_reduce_13,
+ 2, 14, :_reduce_14,
+ 1, 14, :_reduce_15 ]
+
+racc_reduce_n = 16
+
+racc_shift_n = 26
+
+racc_action_table = [
+     3,    13,     5,     7,     9,    15,    16,    17,    20,    17,
+    13,    17,    13,    13,    11,    17,    23,    20,    13,    17 ]
+
+racc_action_check = [
+     1,    16,     1,     1,     1,    12,    12,    12,    18,    18,
+     7,    14,    15,     9,     3,    19,    20,    21,    23,    25 ]
+
+racc_action_pointer = [
+   nil,     0,   nil,    14,   nil,   nil,   nil,     3,   nil,     6,
+   nil,   nil,     0,   nil,     4,     5,    -6,   nil,     2,     8,
+     8,    11,   nil,    11,   nil,    12 ]
+
+racc_action_default = [
+    -1,   -16,    -2,   -16,    -3,   -13,    -4,   -16,    -6,   -16,
+    -7,    26,   -16,   -15,    -5,   -16,   -16,   -14,   -16,    -8,
+   -16,    -9,   -11,   -16,   -10,   -12 ]
+
+racc_goto_table = [
+    12,    22,    14,     4,    24,     6,     2,     8,    18,    19,
+    10,    21,     1,   nil,   nil,   nil,    25 ]
+
+racc_goto_check = [
+     5,     9,     5,     3,     9,     4,     2,     6,     5,     5,
+     7,     8,     1,   nil,   nil,   nil,     5 ]
+
+racc_goto_pointer = [
+   nil,    12,     5,     2,     4,    -7,     6,     9,    -7,   -17 ]
+
+racc_goto_default = [
+   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil ]
+
+racc_token_table = {
+ false => 0,
+ Object.new => 1,
+ :COMMENT => 2,
+ :MSGID => 3,
+ :MSGCTXT => 4,
+ :MSGID_PLURAL => 5,
+ :MSGSTR => 6,
+ :STRING => 7,
+ :PLURAL_NUM => 8 }
+
+racc_use_result_var = true
+
+racc_nt_base = 9
+
+Racc_arg = [
+ racc_action_table,
+ racc_action_check,
+ racc_action_default,
+ racc_action_pointer,
+ racc_goto_table,
+ racc_goto_check,
+ racc_goto_default,
+ racc_goto_pointer,
+ racc_nt_base,
+ racc_reduce_table,
+ racc_token_table,
+ racc_shift_n,
+ racc_reduce_n,
+ racc_use_result_var ]
+
+Racc_token_to_s_table = [
+'$end',
+'error',
+'COMMENT',
+'MSGID',
+'MSGCTXT',
+'MSGID_PLURAL',
+'MSGSTR',
+'STRING',
+'PLURAL_NUM',
+'$start',
+'msgfmt',
+'comment',
+'msgctxt',
+'message',
+'string_list',
+'single_message',
+'plural_message',
+'msgstr_plural',
+'msgstr_plural_line']
+
+Racc_debug_parser = true
+
+##### racc system variables end #####
+
+ # reduce 0 omitted
+
+ # reduce 1 omitted
+
+ # reduce 2 omitted
+
+ # reduce 3 omitted
+
+ # reduce 4 omitted
+
+module_eval <<'.,.,', 'src/poparser.ry', 25
+  def _reduce_5( val, _values, result )
+    @msgctxt = unescape(val[1]) + "\004"
+   result
+  end
+.,.,
+
+ # reduce 6 omitted
+
+ # reduce 7 omitted
+
+module_eval <<'.,.,', 'src/poparser.ry', 48
+  def _reduce_8( val, _values, result )
+    if @fuzzy and $ignore_fuzzy 
+      if val[1] != ""
+        $stderr.print _("Warning: fuzzy message was ignored.\n")
+        $stderr.print "         msgid '#{val[1]}'\n"
+      else
+        on_message('', unescape(val[3]))
+      end
+      @fuzzy = false
+    else
+      on_message(@msgctxt + unescape(val[1]), unescape(val[3]))
+    end
+    result = ""
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 65
+  def _reduce_9( val, _values, result )
+    if @fuzzy and $ignore_fuzzy
+      if val[1] != ""
+        $stderr.print _("Warning: fuzzy message was ignored.\n")
+        $stderr.print "msgid = '#{val[1]}\n"
+      else
+        on_message('', unescape(val[3]))
+      end
+      @fuzzy = false
+    else
+      on_message(@msgctxt + unescape(val[1]) + "\000" + unescape(val[3]), unescape(val[4]))
+    end
+    result = ""
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 76
+  def _reduce_10( val, _values, result )
+    if val[0].size > 0
+      result = val[0] + "\000" + val[1]
+    else
+      result = ""
+    end
+   result
+  end
+.,.,
+
+ # reduce 11 omitted
+
+module_eval <<'.,.,', 'src/poparser.ry', 84
+  def _reduce_12( val, _values, result )
+    result = val[2]
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 91
+  def _reduce_13( val, _values, result )
+    on_comment(val[0])
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 99
+  def _reduce_14( val, _values, result )
+    result = val.delete_if{|item| item == ""}.join
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 103
+  def _reduce_15( val, _values, result )
+    result = val[0]
+   result
+  end
+.,.,
+
+ def _reduce_none( val, _values, result )
+  result
+ end
+
+  end   # class PoParser
+
+end   # module GetText
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale.rb
new file mode 100644
index 0000000..4f9d026
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale.rb
@@ -0,0 +1,6 @@
+module I18n
+  module Locale
+  autoload :Fallbacks, 'i18n/locale/fallbacks'
+  autoload :Tag,       'i18n/locale/tag'
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/fallbacks.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/fallbacks.rb
new file mode 100644
index 0000000..11dcf8c
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/fallbacks.rb
@@ -0,0 +1,98 @@
+# encoding: utf-8
+
+# Locale Fallbacks
+#
+# Extends the I18n module to hold a fallbacks instance which is set to an
+# instance of I18n::Locale::Fallbacks by default but can be swapped with a
+# different implementation.
+#
+# Locale fallbacks will compute a number of fallback locales for a given locale.
+# For example:
+#
+# <pre><code>
+# I18n.fallbacks[:"es-MX"] # => [:"es-MX", :es, :en] </code></pre>
+#
+# Locale fallbacks always fall back to
+#
+#   * all parent locales of a given locale (e.g. :es for :"es-MX") first,
+#   * the current default locales and all of their parents second
+#
+# The default locales are set to [I18n.default_locale] by default but can be
+# set to something else.
+#
+# One can additionally add any number of additional fallback locales manually.
+# These will be added before the default locales to the fallback chain. For
+# example:
+#
+#   # using the default locale as default fallback locale
+#
+#   I18n.default_locale = :"en-US"
+#   I18n.fallbacks = I18n::Fallbacks.new(:"de-AT" => :"de-DE")
+#   I18n.fallbacks[:"de-AT"] # => [:"de-AT", :"de-DE", :de, :"en-US", :en]
+#
+#   # using a custom locale as default fallback locale
+#
+#   I18n.fallbacks = I18n::Fallbacks.new(:"en-GB", :"de-AT" => :de, :"de-CH" => :de)
+#   I18n.fallbacks[:"de-AT"] # => [:"de-AT", :de, :"en-GB", :en]
+#   I18n.fallbacks[:"de-CH"] # => [:"de-CH", :de, :"en-GB", :en]
+#
+#   # mapping fallbacks to an existing instance
+#
+#   # people speaking Catalan also speak Spanish as spoken in Spain
+#   fallbacks = I18n.fallbacks
+#   fallbacks.map(:ca => :"es-ES")
+#   fallbacks[:ca] # => [:ca, :"es-ES", :es, :"en-US", :en]
+#
+#   # people speaking Arabian as spoken in Palestine also speak Hebrew as spoken in Israel
+#   fallbacks.map(:"ar-PS" => :"he-IL")
+#   fallbacks[:"ar-PS"] # => [:"ar-PS", :ar, :"he-IL", :he, :"en-US", :en]
+#   fallbacks[:"ar-EG"] # => [:"ar-EG", :ar, :"en-US", :en]
+#
+#   # people speaking Sami as spoken in Finnland also speak Swedish and Finnish as spoken in Finnland
+#   fallbacks.map(:sms => [:"se-FI", :"fi-FI"])
+#   fallbacks[:sms] # => [:sms, :"se-FI", :se, :"fi-FI", :fi, :"en-US", :en]
+
+module I18n
+  module Locale
+    class Fallbacks < Hash
+      def initialize(*mappings)
+        @map = {}
+        map(mappings.pop) if mappings.last.is_a?(Hash)
+        self.defaults = mappings.empty? ? [I18n.default_locale.to_sym] : mappings
+      end
+
+      def defaults=(defaults)
+        @defaults = defaults.map { |default| compute(default, false) }.flatten
+      end
+      attr_reader :defaults
+
+      def [](locale)
+        raise InvalidLocale.new(locale) if locale.nil?
+        locale = locale.to_sym
+        super || store(locale, compute(locale))
+      end
+
+      def map(mappings)
+        mappings.each do |from, to|
+          from, to = from.to_sym, Array(to)
+          to.each do |to|
+            @map[from] ||= []
+            @map[from] << to.to_sym
+          end
+        end
+      end
+
+      protected
+
+      def compute(tags, include_defaults = true)
+        result = Array(tags).collect do |tag|
+          tags = I18n::Locale::Tag.tag(tag).self_and_parents.map! { |t| t.to_sym }
+          tags.each { |tag| tags += compute(@map[tag]) if @map[tag] }
+          tags
+        end.flatten
+        result.push(*defaults) if include_defaults
+        result.uniq
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag.rb
new file mode 100644
index 0000000..a640b44
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+
+module I18n
+  module Locale
+    module Tag
+      autoload :Parents, 'i18n/locale/tag/parents'
+      autoload :Rfc4646, 'i18n/locale/tag/rfc4646'
+      autoload :Simple,  'i18n/locale/tag/simple'
+
+      class << self
+        # Returns the current locale tag implementation. Defaults to +I18n::Locale::Tag::Simple+.
+        def implementation
+          @@implementation ||= Simple
+        end
+
+        # Sets the current locale tag implementation. Use this to set a different locale tag implementation.
+        def implementation=(implementation)
+          @@implementation = implementation
+        end
+
+        # Factory method for locale tags. Delegates to the current locale tag implementation.
+        def tag(tag)
+          implementation.tag(tag)
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/parents.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/parents.rb
new file mode 100644
index 0000000..a094468
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/parents.rb
@@ -0,0 +1,24 @@
+# encoding: utf-8
+
+module I18n
+  module Locale
+    module Tag
+      module Parents
+        def parent
+          @parent ||= begin
+            segs = to_a.compact
+            segs.length > 1 ? self.class.tag(*segs[0..(segs.length-2)].join('-')) : nil
+          end
+        end
+
+        def self_and_parents
+          @self_and_parents ||= [self] + parents
+        end
+
+        def parents
+          @parents ||= ([parent] + (parent ? parent.parents : [])).compact
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/rfc4646.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/rfc4646.rb
new file mode 100644
index 0000000..c20d35a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/rfc4646.rb
@@ -0,0 +1,76 @@
+# encoding: utf-8
+
+# RFC 4646/47 compliant Locale tag implementation that parses locale tags to
+# subtags such as language, script, region, variant etc.
+#
+# For more information see by http://en.wikipedia.org/wiki/IETF_language_tag
+#
+# Rfc4646::Parser does not implement grandfathered tags.
+
+module I18n
+  module Locale
+    module Tag
+      RFC4646_SUBTAGS = [ :language, :script, :region, :variant, :extension, :privateuse, :grandfathered ]
+      RFC4646_FORMATS = { :language => :downcase, :script => :capitalize, :region => :upcase, :variant => :downcase }
+
+      class Rfc4646 < Struct.new(*RFC4646_SUBTAGS)
+        class << self
+          # Parses the given tag and returns a Tag instance if it is valid.
+          # Returns false if the given tag is not valid according to RFC 4646.
+          def tag(tag)
+            matches = parser.match(tag)
+            new(*matches) if matches
+          end
+
+          def parser
+            @@parser ||= Rfc4646::Parser
+          end
+
+          def parser=(parser)
+            @@parser = parser
+          end
+        end
+
+        include Parents
+
+        RFC4646_FORMATS.each do |name, format|
+          define_method(name) { self[name].send(format) unless self[name].nil? }
+        end
+
+        def to_sym
+          to_s.to_sym
+        end
+
+        def to_s
+          @tag ||= to_a.compact.join("-")
+        end
+
+        def to_a
+          members.collect { |attr| self.send(attr) }
+        end
+
+        module Parser
+          PATTERN = %r{\A(?:
+            ([a-z]{2,3}(?:(?:-[a-z]{3}){0,3})?|[a-z]{4}|[a-z]{5,8}) # language
+            (?:-([a-z]{4}))?                                        # script
+            (?:-([a-z]{2}|\d{3}))?                                  # region
+            (?:-([0-9a-z]{5,8}|\d[0-9a-z]{3}))*                     # variant
+            (?:-([0-9a-wyz](?:-[0-9a-z]{2,8})+))*                   # extension
+            (?:-(x(?:-[0-9a-z]{1,8})+))?|                           # privateuse subtag
+            (x(?:-[0-9a-z]{1,8})+)|                                 # privateuse tag
+            /* ([a-z]{1,3}(?:-[0-9a-z]{2,8}){1,2}) */               # grandfathered
+            )\z}xi
+
+          class << self
+            def match(tag)
+              c = PATTERN.match(tag.to_s).captures
+              c[0..4] << (c[5].nil? ? c[6] : c[5])  << c[7] # TODO c[7] is grandfathered, throw a NotImplemented exception here?
+            rescue
+              false
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/simple.rb
new file mode 100644
index 0000000..0fddb36
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/locale/tag/simple.rb
@@ -0,0 +1,41 @@
+# encoding: utf-8
+
+# Simple Locale tag implementation that computes subtags by simply splitting
+# the locale tag at '-' occurences.
+module I18n
+  module Locale
+    module Tag
+      class Simple
+        class << self
+          def tag(tag)
+            new(tag)
+          end
+        end
+
+        include Parents
+
+        attr_reader :tag
+
+        def initialize(*tag)
+          @tag = tag.join('-').to_sym
+        end
+
+        def subtags
+          @subtags = tag.to_s.split('-').map { |subtag| subtag.to_s }
+        end
+
+        def to_sym
+          tag
+        end
+
+        def to_s
+          tag.to_s
+        end
+
+        def to_a
+          subtags
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/version.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/version.rb
new file mode 100644
index 0000000..e1186c2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/lib/i18n/version.rb
@@ -0,0 +1,3 @@
+module I18n
+  VERSION = "0.4.1"
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/all.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/all.rb
new file mode 100644
index 0000000..e846143
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/all.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+
+dir = File.dirname(__FILE__)
+$LOAD_PATH.unshift(dir)
+
+Dir["#{dir}/**/*_test.rb"].sort.each do |file|
+  require file.sub(/^#{dir}\/(.*)\.rb$/, '\1')
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api.rb
new file mode 100644
index 0000000..17a0163
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api.rb
@@ -0,0 +1,18 @@
+module Tests
+  module Api
+    autoload :Basics,        'api/tests/basics'
+    autoload :Defaults,      'api/tests/defaults'
+    autoload :Interpolation, 'api/tests/interpolation'
+    autoload :Link,          'api/tests/link'
+    autoload :Lookup,        'api/tests/lookup'
+    autoload :Pluralization, 'api/tests/pluralization'
+    autoload :Procs,         'api/tests/procs'
+
+    module Localization
+      autoload :Date,        'api/tests/localization/date'
+      autoload :DateTime,    'api/tests/localization/date_time'
+      autoload :Procs,       'api/tests/localization/procs'
+      autoload :Time,        'api/tests/localization/time'
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/active_record_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/active_record_test.rb
new file mode 100644
index 0000000..c13779c
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/active_record_test.rb
@@ -0,0 +1,30 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+setup_active_record
+
+class I18nActiveRecordApiTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::ActiveRecord.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs # unless RUBY_VERSION >= '1.9.1'
+          
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs # unless RUBY_VERSION >= '1.9.1'
+
+  test "make sure we use an ActiveRecord backend" do
+    assert_equal I18n::Backend::ActiveRecord, I18n.backend.class
+  end
+end if defined?(ActiveRecord)
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/all_features_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/all_features_test.rb
new file mode 100644
index 0000000..4ff1e03
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/all_features_test.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+begin
+  require 'rubygems'
+  require 'active_support'
+rescue LoadError
+  puts "not testing with Cache enabled because active_support can not be found"
+end
+
+class I18nAllFeaturesApiTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Cache
+    include I18n::Backend::Metadata
+    include I18n::Backend::Cascade
+    include I18n::Backend::Fallbacks
+    include I18n::Backend::Pluralization
+    include I18n::Backend::Memoize
+  end
+
+  def setup
+    I18n.backend = I18n::Backend::Chain.new(Backend.new, I18n::Backend::Simple.new)
+    I18n.cache_store = cache_store
+    super
+  end
+
+  def teardown
+    I18n.cache_store.clear
+    I18n.cache_store = nil
+    super
+  end
+
+  def cache_store
+    ActiveSupport::Cache.lookup_store(:memory_store) if defined?(ActiveSupport) && defined?(ActiveSupport::Cache)
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  test "make sure we use a Chain backend with an all features backend" do
+    assert_equal I18n::Backend::Chain, I18n.backend.class
+    assert_equal Backend, I18n.backend.backends.first.class
+  end
+
+  # links: test that keys stored on one backend can link to keys stored on another backend
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/cascade_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/cascade_test.rb
new file mode 100644
index 0000000..9005beb
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/cascade_test.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class I18nCascadeApiTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Cascade
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  test "make sure we use a backend with Cascade included" do
+    assert_equal Backend, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/chain_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/chain_test.rb
new file mode 100644
index 0000000..6f4bbb9
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/chain_test.rb
@@ -0,0 +1,27 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class I18nApiChainTest < Test::Unit::TestCase
+  def setup
+    super
+    I18n.backend = I18n::Backend::Chain.new(I18n::Backend::Simple.new, I18n.backend)
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  test "make sure we use the Chain backend" do
+    assert_equal I18n::Backend::Chain, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/fallbacks_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/fallbacks_test.rb
new file mode 100644
index 0000000..3697655
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/fallbacks_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class I18nFallbacksApiTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  test "make sure we use a backend with Fallbacks included" do
+    assert_equal Backend, I18n.backend.class
+  end
+  
+  # links: test that keys stored on one backend can link to keys stored on another backend
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/key_value_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/key_value_test.rb
new file mode 100644
index 0000000..313f5d8
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/key_value_test.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+setup_rufus_tokyo
+
+class I18nKeyValueApiTest < Test::Unit::TestCase
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  # include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  # include Tests::Api::Localization::Procs
+
+  STORE = Rufus::Tokyo::Cabinet.new('*')
+
+  def setup
+    I18n.backend = I18n::Backend::KeyValue.new(STORE)
+    super
+  end
+
+  test "make sure we use the KeyValue backend" do
+    assert_equal I18n::Backend::KeyValue, I18n.backend.class
+  end
+end if defined?(Rufus::Tokyo::Cabinet)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/memoize_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/memoize_test.rb
new file mode 100644
index 0000000..f01776d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/memoize_test.rb
@@ -0,0 +1,62 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class I18nMemoizeBackendWithSimpleApiTest < Test::Unit::TestCase
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+  
+  class MemoizeBackend < I18n::Backend::Simple
+    include I18n::Backend::Memoize
+  end
+
+  def setup
+    I18n.backend = MemoizeBackend.new
+    super
+  end
+  
+  test "make sure we use the MemoizeBackend backend" do
+    assert_equal MemoizeBackend, I18n.backend.class
+  end
+end
+
+setup_rufus_tokyo
+
+class I18nMemoizeBackendWithKeyValueApiTest < Test::Unit::TestCase
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  # include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  # include Tests::Api::Localization::Procs
+  
+  class MemoizeBackend < I18n::Backend::KeyValue
+    include I18n::Backend::Memoize
+  end
+
+  STORE = Rufus::Tokyo::Cabinet.new('*')
+
+  def setup
+    I18n.backend = MemoizeBackend.new(STORE)
+    super
+  end
+  
+  test "make sure we use the MemoizeBackend backend" do
+    assert_equal MemoizeBackend, I18n.backend.class
+  end
+end if defined?(Rufus::Tokyo::Cabinet)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/pluralization_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/pluralization_test.rb
new file mode 100644
index 0000000..b888a05
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/pluralization_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class I18nPluralizationApiTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Pluralization
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  test "make sure we use a backend with Pluralization included" do
+    assert_equal Backend, I18n.backend.class
+  end
+  
+  # links: test that keys stored on one backend can link to keys stored on another backend
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/simple_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/simple_test.rb
new file mode 100644
index 0000000..25f538e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/simple_test.rb
@@ -0,0 +1,22 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class I18nSimpleBackendApiTest < Test::Unit::TestCase
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  test "make sure we use the Simple backend" do
+    assert_equal I18n::Backend::Simple, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/basics.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/basics.rb
new file mode 100644
index 0000000..96fb80e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/basics.rb
@@ -0,0 +1,24 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Basics
+      def test_available_locales
+        store_translations('de', :foo => 'bar')
+        store_translations('en', :foo => 'foo')
+
+        assert I18n.available_locales.include?(:de)
+        assert I18n.available_locales.include?(:en)
+      end
+
+      def test_delete_value
+        store_translations(:to_be_deleted => 'bar')
+        assert_equal 'bar', I18n.t('to_be_deleted', :default => 'baz')
+
+        I18n.cache_store.clear if I18n.respond_to?(:cache_store) && I18n.cache_store
+        store_translations(:to_be_deleted => nil)
+        assert_equal 'baz', I18n.t('to_be_deleted', :default => 'baz')
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/defaults.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/defaults.rb
new file mode 100644
index 0000000..953237c
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/defaults.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Defaults
+      def setup
+        super
+        store_translations(:foo => { :bar => 'bar', :baz => 'baz' })
+      end
+      
+      define_method "test defaults: given nil as a key it returns the given default" do
+        assert_equal 'default', I18n.t(nil, :default => 'default')
+      end
+      
+      define_method "test defaults: given a symbol as a default it translates the symbol" do
+        assert_equal 'bar', I18n.t(nil, :default => :'foo.bar')
+      end
+
+      define_method "test defaults: given a symbol as a default and a scope it stays inside the scope when looking up the symbol" do
+        assert_equal 'bar', I18n.t(:missing, :default => :bar, :scope => :foo)
+      end
+
+      define_method "test defaults: given an array as a default it returns the first match" do
+        assert_equal 'bar', I18n.t(:does_not_exist, :default => [:does_not_exist_2, :'foo.bar'])
+      end
+
+      define_method "test defaults: given an array of missing keys it raises a MissingTranslationData exception" do
+        assert_raise I18n::MissingTranslationData do
+          I18n.t(:does_not_exist, :default => [:does_not_exist_2, :does_not_exist_3], :raise => true)
+        end
+      end
+
+      define_method "test defaults: using a custom scope separator" do
+        # data must have been stored using the custom separator when using the ActiveRecord backend
+        I18n.backend.store_translations(:en, { :foo => { :bar => 'bar' } }, { :separator => '|' })
+        assert_equal 'bar', I18n.t(nil, :default => :'foo|bar', :separator => '|')
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/interpolation.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/interpolation.rb
new file mode 100644
index 0000000..0c08cfe
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/interpolation.rb
@@ -0,0 +1,108 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Interpolation
+      def interpolate(*args)
+        options = args.last.is_a?(Hash) ? args.pop : {}
+        key = args.pop
+        I18n.backend.translate('en', key, options)
+      end
+
+      # If no interpolation parameter is not given, I18n should not alter the string.
+      # This behavior is due to three reasons:
+      #
+      #   * Checking interpolation keys in all strings hits performance, badly;
+      #
+      #   * This allows us to retrieve untouched values through I18n. For example
+      #     I could have a middleware that returns I18n lookup results in JSON
+      #     to be processed through Javascript. Leaving the keys untouched allows
+      #     the interpolation to happen at the javascript level;
+      #
+      #   * Security concerns: if I allow users to translate a web site, they can
+      #     insert %{} in messages causing the I18n lookup to fail in every request.
+      #
+      define_method "test interpolation: given no values it does not alter the string" do
+        assert_equal 'Hi %{name}!', interpolate(:default => 'Hi %{name}!')
+      end
+
+      define_method "test interpolation: given values it interpolates them into the string" do
+        assert_equal 'Hi David!', interpolate(:default => 'Hi %{name}!', :name => 'David')
+      end
+
+      define_method "test interpolation: given a nil value it still interpolates it into the string" do
+        assert_equal 'Hi !', interpolate(:default => 'Hi %{name}!', :name => nil)
+      end
+
+      define_method "test interpolation: given a lambda as a value it calls it if the string contains the key" do
+        assert_equal 'Hi David!', interpolate(:default => 'Hi %{name}!', :name => lambda { |*args| 'David' })
+      end
+
+      define_method "test interpolation: given a lambda as a value it does not call it if the string does not contain the key" do
+        assert_nothing_raised { interpolate(:default => 'Hi!', :name => lambda { |*args| raise 'fail' }) }
+      end
+
+      define_method "test interpolation: given values but missing a key it raises I18n::MissingInterpolationArgument" do
+        assert_raise(I18n::MissingInterpolationArgument) do
+          interpolate(:default => '%{foo}', :bar => 'bar')
+        end
+      end
+
+      define_method "test interpolation: it does not raise I18n::MissingInterpolationArgument for escaped variables" do
+        assert_nothing_raised(I18n::MissingInterpolationArgument) do
+          assert_equal 'Barr %{foo}', interpolate(:default => '%{bar} %%{foo}', :bar => 'Barr')
+        end
+      end
+
+      define_method "test interpolation: it does not change the original, stored translation string" do
+        I18n.backend.store_translations(:en, :interpolate => 'Hi %{name}!')
+        assert_equal 'Hi David!', interpolate(:interpolate, :name => 'David')
+        assert_equal 'Hi Yehuda!', interpolate(:interpolate, :name => 'Yehuda')
+      end
+
+      define_method "test interpolation: works with the deprecated syntax" do
+        deprecation = capture(:stderr) do
+          assert_equal 'Hi David!', interpolate(:default => 'Hi {{name}}!', :name => 'David')
+        end
+        assert_match "The {{key}} interpolation syntax in I18n messages is deprecated", deprecation
+      end
+
+      define_method "test interpolation: given the translation is in utf-8 it still works" do
+        assert_equal 'Häi David!', interpolate(:default => 'Häi %{name}!', :name => 'David')
+      end
+
+      define_method "test interpolation: given the value is in utf-8 it still works" do
+        assert_equal 'Hi ゆきひろ!', interpolate(:default => 'Hi %{name}!', :name => 'ゆきひろ')
+      end
+
+      define_method "test interpolation: given the translation and the value are in utf-8 it still works" do
+        assert_equal 'こんにちは、ゆきひろさん!', interpolate(:default => 'こんにちは、%{name}さん!', :name => 'ゆきひろ')
+      end
+
+      if Kernel.const_defined?(:Encoding)
+        define_method "test interpolation: given a euc-jp translation and a utf-8 value it raises Encoding::CompatibilityError" do
+          assert_raise(Encoding::CompatibilityError) do
+            interpolate(:default => euc_jp('こんにちは、%{name}さん!'), :name => 'ゆきひろ')
+          end
+        end
+        
+        # define_method "test interpolation: given a utf-8 translation and a euc-jp value it returns a translation in euc-jp" do
+        #   assert_equal euc_jp('Hi ゆきひろ!'), interpolate(:default => 'Hi %{name}!', :name => euc_jp('ゆきひろ'))
+        # end
+        # 
+        # TODO should better explain how this relates to the test above with the simpler utf-8 default string
+        define_method "test interpolation: given a utf-8 translation and a euc-jp value it raises Encoding::CompatibilityError" do
+          assert_raise(Encoding::CompatibilityError) do
+            interpolate(:default => 'こんにちは、%{name}さん!', :name => euc_jp('ゆきひろ'))
+          end
+        end
+      end
+
+      define_method "test interpolation: given a translations containing a reserved key it raises I18n::ReservedInterpolationKey" do
+        assert_raise(I18n::ReservedInterpolationKey) { interpolate(:default => '%{default}',   :foo => :bar) }
+        assert_raise(I18n::ReservedInterpolationKey) { interpolate(:default => '%{scope}',     :foo => :bar) }
+        assert_raise(I18n::ReservedInterpolationKey) { interpolate(:default => '%{separator}', :foo => :bar) }
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/link.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/link.rb
new file mode 100644
index 0000000..0beb839
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/link.rb
@@ -0,0 +1,56 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Link
+      define_method "test linked lookup: if a key resolves to a symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :link  => :linked,
+          :linked => 'linked'
+        }
+        assert_equal 'linked', I18n.backend.translate('en', :link)
+      end
+
+      define_method "test linked lookup: if a key resolves to a dot-separated symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :link => :"foo.linked",
+          :foo  => { :linked => 'linked' }
+        }
+        assert_equal('linked', I18n.backend.translate('en', :link))
+      end
+
+      define_method "test linked lookup: if a dot-separated key resolves to a symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :foo    => { :link => :linked },
+          :linked => 'linked'
+        }
+        assert_equal('linked', I18n.backend.translate('en', :'foo.link'))
+      end
+      
+      define_method "test linked lookup: if a dot-separated key resolves to a dot-separated symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :foo => { :link   => :"bar.linked" },
+          :bar => { :linked => 'linked' }
+        }
+        assert_equal('linked', I18n.backend.translate('en', :'foo.link'))
+      end
+
+      define_method "test linked lookup: links always refer to the absolute key" do
+        I18n.backend.store_translations 'en', {
+          :foo => { :link => :linked, :linked => 'linked in foo' },
+          :linked => 'linked absolutely'
+        }
+        assert_equal 'linked absolutely', I18n.backend.translate('en', :link, :scope => :foo)
+      end
+
+      define_method "test linked lookup: a link can resolve to a namespace in the middle of a dot-separated key" do
+        I18n.backend.store_translations 'en', {
+          :activemodel  => { :errors => { :messages => { :blank => "can't be blank" } } },
+          :activerecord => { :errors => { :messages => :"activemodel.errors.messages" } }
+        }
+        assert_equal "can't be blank", I18n.t(:"activerecord.errors.messages.blank")
+        assert_equal "can't be blank", I18n.t(:"activerecord.errors.messages.blank")
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date.rb
new file mode 100644
index 0000000..d99b6f8
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date.rb
@@ -0,0 +1,84 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module Date
+        def setup
+          super
+          setup_date_translations
+          @date = ::Date.new(2008, 3, 1)
+        end
+
+        define_method "test localize Date: given the short format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '01. Mar', I18n.l(@date, :format => :short, :locale => :de)
+        end
+
+        define_method "test localize Date: given the long format it uses it" do
+          assert_equal '01. März 2008', I18n.l(@date, :format => :long, :locale => :de)
+        end
+
+        define_method "test localize Date: given the default format it uses it" do
+          assert_equal '01.03.2008', I18n.l(@date, :format => :default, :locale => :de)
+        end
+
+        define_method "test localize Date: given a day name format it returns the correct day name" do
+          assert_equal 'Samstag', I18n.l(@date, :format => '%A', :locale => :de)
+        end
+
+        define_method "test localize Date: given an abbreviated day name format it returns the correct abbreviated day name" do
+          assert_equal 'Sa', I18n.l(@date, :format => '%a', :locale => :de)
+        end
+
+        define_method "test localize Date: given a month name format it returns the correct month name" do
+          assert_equal 'März', I18n.l(@date, :format => '%B', :locale => :de)
+        end
+
+        define_method "test localize Date: given an abbreviated month name format it returns the correct abbreviated month name" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Mar', I18n.l(@date, :format => '%b', :locale => :de)
+        end
+
+        define_method "test localize Date: given an unknown format it does not fail" do
+          assert_nothing_raised { I18n.l(@date, :format => '%x') }
+        end
+
+        define_method "test localize Date: given nil it raises I18n::ArgumentError" do
+          assert_raise(I18n::ArgumentError) { I18n.l(nil) }
+        end
+
+        define_method "test localize Date: given a plain Object it raises I18n::ArgumentError" do
+          assert_raise(I18n::ArgumentError) { I18n.l(Object.new) }
+        end
+
+        define_method "test localize Date: given a format is missing it raises I18n::MissingTranslationData" do
+          assert_raise(I18n::MissingTranslationData) { I18n.l(@date, :format => :missing) }
+        end
+
+        define_method "test localize Date: it does not alter the format string" do
+          assert_equal '01. Februar 2009', I18n.l(::Date.parse('2009-02-01'), :format => :long, :locale => :de)
+          assert_equal '01. Oktober 2009', I18n.l(::Date.parse('2009-10-01'), :format => :long, :locale => :de)
+        end
+
+        protected
+
+          def setup_date_translations
+            store_translations :de, {
+              :date => {
+                :formats => {
+                  :default => "%d.%m.%Y",
+                  :short => "%d. %b",
+                  :long => "%d. %B %Y",
+                },
+                :day_names => %w(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag),
+                :abbr_day_names => %w(So Mo Di Mi Do Fr  Sa),
+                :month_names => %w(Januar Februar März April Mai Juni Juli August September Oktober November Dezember).unshift(nil),
+                :abbr_month_names => %w(Jan Feb Mar Apr Mai Jun Jul Aug Sep Okt Nov Dez).unshift(nil)
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date_time.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date_time.rb
new file mode 100644
index 0000000..aaecdcb
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/date_time.rb
@@ -0,0 +1,77 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module DateTime
+        def setup
+          super
+          setup_datetime_translations
+          @datetime = ::DateTime.new(2008, 3, 1, 6)
+          @other_datetime = ::DateTime.new(2008, 3, 1, 18)
+        end
+
+        define_method "test localize DateTime: given the short format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '01. Mar 06:00', I18n.l(@datetime, :format => :short, :locale => :de)
+        end
+
+        define_method "test localize DateTime: given the long format it uses it" do
+          assert_equal '01. März 2008 06:00', I18n.l(@datetime, :format => :long, :locale => :de)
+        end
+
+        define_method "test localize DateTime: given the default format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Sa, 01. Mar 2008 06:00:00 +0000', I18n.l(@datetime, :format => :default, :locale => :de)
+        end
+
+        define_method "test localize DateTime: given a day name format it returns the correct day name" do
+          assert_equal 'Samstag', I18n.l(@datetime, :format => '%A', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given an abbreviated day name format it returns the correct abbreviated day name" do
+          assert_equal 'Sa', I18n.l(@datetime, :format => '%a', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given a month name format it returns the correct month name" do
+          assert_equal 'März', I18n.l(@datetime, :format => '%B', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given an abbreviated month name format it returns the correct abbreviated month name" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Mar', I18n.l(@datetime, :format => '%b', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given a meridian indicator format it returns the correct meridian indicator" do
+          assert_equal 'am', I18n.l(@datetime, :format => '%p', :locale => :de)
+          assert_equal 'pm', I18n.l(@other_datetime, :format => '%p', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given an unknown format it does not fail" do
+          assert_nothing_raised { I18n.l(@datetime, :format => '%x') }
+        end
+
+        define_method "test localize DateTime: given a format is missing it raises I18n::MissingTranslationData" do
+          assert_raise(I18n::MissingTranslationData) { I18n.l(@datetime, :format => :missing) }
+        end
+
+        protected
+
+          def setup_datetime_translations
+            # time translations might have been set up in Tests::Api::Localization::Time
+            store_translations :de, {
+              :time => {
+                :formats => {
+                  :default => "%a, %d. %b %Y %H:%M:%S %z",
+                  :short => "%d. %b %H:%M",
+                  :long => "%d. %B %Y %H:%M"
+                },
+                :am => 'am',
+                :pm => 'pm'
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/procs.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/procs.rb
new file mode 100644
index 0000000..695b09a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/procs.rb
@@ -0,0 +1,117 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module Procs
+        define_method "test localize: using day names from lambdas" do
+          if can_store_procs?
+            setup_time_proc_translations
+            time = ::Time.parse('2008-03-01 6:00 UTC')
+            assert_match /Суббота/, I18n.l(time, :format => "%A, %d %B", :locale => :ru)
+            assert_match /суббота/, I18n.l(time, :format => "%d %B (%A)", :locale => :ru)
+          end
+        end
+
+        define_method "test localize: using month names from lambdas" do
+          if can_store_procs?
+            setup_time_proc_translations
+            time = ::Time.parse('2008-03-01 6:00 UTC')
+            assert_match /марта/, I18n.l(time, :format => "%d %B %Y", :locale => :ru)
+            assert_match /Март /, I18n.l(time, :format => "%B %Y", :locale => :ru)
+          end
+        end
+
+        define_method "test localize: using abbreviated day names from lambdas" do
+          if can_store_procs?
+            setup_time_proc_translations
+            time = ::Time.parse('2008-03-01 6:00 UTC')
+            assert_match /марта/, I18n.l(time, :format => "%d %b %Y", :locale => :ru)
+            assert_match /март /, I18n.l(time, :format => "%b %Y", :locale => :ru)
+          end
+        end
+
+        define_method "test localize Date: given a format that resolves to a Proc it calls the Proc with the object" do
+          if can_store_procs?
+            setup_time_proc_translations
+            date = ::Date.new(2008, 3, 1, 6)
+            assert_equal '[Sat, 01 Mar 2008, {}]', I18n.l(date, :format => :proc, :locale => :ru)
+          end
+        end
+
+        define_method "test localize Date: given a format that resolves to a Proc it calls the Proc with the object and extra options" do
+          if can_store_procs?
+            setup_time_proc_translations
+            date = ::Date.new(2008, 3, 1, 6)
+            assert_equal '[Sat, 01 Mar 2008, {:foo=>"foo"}]', I18n.l(date, :format => :proc, :foo => 'foo', :locale => :ru)
+          end
+        end
+
+        define_method "test localize DateTime: given a format that resolves to a Proc it calls the Proc with the object" do
+          if can_store_procs?
+            setup_time_proc_translations
+            datetime = ::DateTime.new(2008, 3, 1, 6)
+            assert_equal '[Sat, 01 Mar 2008 06:00:00 +0000, {}]', I18n.l(datetime, :format => :proc, :locale => :ru)
+          end
+        end
+
+        define_method "test localize DateTime: given a format that resolves to a Proc it calls the Proc with the object and extra options" do
+          if can_store_procs?
+            setup_time_proc_translations
+            datetime = ::DateTime.new(2008, 3, 1, 6)
+            assert_equal '[Sat, 01 Mar 2008 06:00:00 +0000, {:foo=>"foo"}]', I18n.l(datetime, :format => :proc, :foo => 'foo', :locale => :ru)
+          end
+        end
+
+        define_method "test localize Time: given a format that resolves to a Proc it calls the Proc with the object" do
+          if can_store_procs?
+            setup_time_proc_translations
+            time = ::Time.parse('2008-03-01 6:00 UTC')
+            assert_equal [time, {}].inspect, I18n.l(time, :format => :proc, :locale => :ru)
+          end
+        end
+
+        define_method "test localize Time: given a format that resolves to a Proc it calls the Proc with the object and extra options" do
+          if can_store_procs?
+            setup_time_proc_translations
+            time    = ::Time.parse('2008-03-01 6:00 UTC')
+            options = { :foo => 'foo' }
+            assert_equal [time, options].inspect, I18n.l(time, options.merge(:format => :proc, :locale => :ru))
+          end
+        end
+
+        protected
+
+          def setup_time_proc_translations
+            store_translations :ru, {
+              :time => {
+                :formats => {
+                  :proc => lambda { |*args| args.inspect }
+                }
+              },
+              :date => {
+                :formats => {
+                  :proc => lambda { |*args| args.inspect }
+                },
+                :'day_names' => lambda { |key, options|
+                  (options[:format] =~ /^%A/) ?
+                  %w(Воскресенье Понедельник Вторник Среда Четверг Пятница Суббота) :
+                  %w(воскресенье понедельник вторник среда четверг пятница суббота)
+                },
+                :'month_names' => lambda { |key, options|
+                  (options[:format] =~ /(%d|%e)(\s*)?(%B)/) ?
+                  %w(января февраля марта апреля мая июня июля августа сентября октября ноября декабря).unshift(nil) :
+                  %w(Январь Февраль Март Апрель Май Июнь Июль Август Сентябрь Октябрь Ноябрь Декабрь).unshift(nil)
+                },
+                :'abbr_month_names' => lambda { |key, options|
+                  (options[:format] =~ /(%d|%e)(\s*)(%b)/) ?
+                  %w(янв. февр. марта апр. мая июня июля авг. сент. окт. нояб. дек.).unshift(nil) :
+                  %w(янв. февр. март апр. май июнь июль авг. сент. окт. нояб. дек.).unshift(nil)
+                },
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/time.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/time.rb
new file mode 100644
index 0000000..458ef05
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/localization/time.rb
@@ -0,0 +1,76 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module Time
+        def setup
+          super
+          setup_time_translations
+          @time = ::Time.parse('2008-03-01 6:00 UTC')
+          @other_time = ::Time.parse('2008-03-01 18:00 UTC')
+        end
+
+        define_method "test localize Time: given the short format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '01. Mar 06:00', I18n.l(@time, :format => :short, :locale => :de)
+        end
+
+        define_method "test localize Time: given the long format it uses it" do
+          assert_equal '01. März 2008 06:00', I18n.l(@time, :format => :long, :locale => :de)
+        end
+
+        # TODO Seems to break on Windows because ENV['TZ'] is ignored. What's a better way to do this?
+        # def test_localize_given_the_default_format_it_uses_it
+        #   assert_equal 'Sa, 01. Mar 2008 06:00:00 +0000', I18n.l(@time, :format => :default, :locale => :de)
+        # end
+
+        define_method "test localize Time: given a day name format it returns the correct day name" do
+          assert_equal 'Samstag', I18n.l(@time, :format => '%A', :locale => :de)
+        end
+
+        define_method "test localize Time: given an abbreviated day name format it returns the correct abbreviated day name" do
+          assert_equal 'Sa', I18n.l(@time, :format => '%a', :locale => :de)
+        end
+
+        define_method "test localize Time: given a month name format it returns the correct month name" do
+          assert_equal 'März', I18n.l(@time, :format => '%B', :locale => :de)
+        end
+
+        define_method "test localize Time: given an abbreviated month name format it returns the correct abbreviated month name" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Mar', I18n.l(@time, :format => '%b', :locale => :de)
+        end
+
+        define_method "test localize Time: given a meridian indicator format it returns the correct meridian indicator" do
+          assert_equal 'am', I18n.l(@time, :format => '%p', :locale => :de)
+          assert_equal 'pm', I18n.l(@other_time, :format => '%p', :locale => :de)
+        end
+
+        define_method "test localize Time: given an unknown format it does not fail" do
+          assert_nothing_raised { I18n.l(@time, :format => '%x') }
+        end
+
+        define_method "test localize Time: given a format is missing it raises I18n::MissingTranslationData" do
+          assert_raise(I18n::MissingTranslationData) { I18n.l(@time, :format => :missing) }
+        end
+
+        protected
+
+          def setup_time_translations
+            store_translations :de, {
+              :time => {
+                :formats => {
+                  :default => "%a, %d. %b %Y %H:%M:%S %z",
+                  :short => "%d. %b %H:%M",
+                  :long => "%d. %B %Y %H:%M",
+                },
+                :am => 'am',
+                :pm => 'pm'
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/lookup.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/lookup.rb
new file mode 100644
index 0000000..a87ea5e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/lookup.rb
@@ -0,0 +1,70 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Lookup
+      def setup
+        super
+        store_translations(:foo => { :bar => 'bar', :baz => 'baz' }, :bla => false,
+          :string => "a", :array => %w(a b c), :hash => { "a" => "b" })
+      end
+
+      define_method "test lookup: it returns a string" do
+        assert_equal("a", I18n.t(:string))
+      end
+
+      define_method "test lookup: it returns hash" do
+        assert_equal({ :a => "b" }, I18n.t(:hash))
+      end
+
+      define_method "test lookup: it returns a array" do
+        assert_equal(%w(a b c), I18n.t(:array))
+      end
+
+      define_method "test lookup: it returns a native false" do
+        assert_equal false, I18n.t(:bla)
+      end
+
+      define_method "test lookup: given a missing key, no default and no raise option it returns an error message" do
+        assert_equal "translation missing: en, missing", I18n.t(:missing)
+      end
+
+      define_method "test lookup: given a missing key, no default and the raise option it raises MissingTranslationData" do
+        assert_raise(I18n::MissingTranslationData) { I18n.t(:missing, :raise => true) }
+      end
+
+      define_method "test lookup: does not raise an exception if no translation data is present for the given locale" do
+        assert_nothing_raised { I18n.t(:foo, :locale => :xx) }
+      end
+
+      define_method "test lookup: given an array of keys it translates all of them" do
+        assert_equal %w(bar baz), I18n.t([:bar, :baz], :scope => [:foo])
+      end
+
+      define_method "test lookup: using a custom scope separator" do
+        # data must have been stored using the custom separator when using the ActiveRecord backend
+        I18n.backend.store_translations(:en, { :foo => { :bar => 'bar' } }, { :separator => '|' })
+        assert_equal 'bar', I18n.t('foo|bar', :separator => '|')
+      end
+
+      # In fact it probably *should* fail but Rails currently relies on using the default locale instead.
+      # So we'll stick to this for now until we get it fixed in Rails.
+      define_method "test lookup: given nil as a locale it does not raise but use the default locale" do
+        # assert_raise(I18n::InvalidLocale) { I18n.t(:bar, :locale => nil) }
+        assert_nothing_raised { I18n.t(:bar, :locale => nil) }
+      end
+
+      define_method "test lookup: a resulting String is not frozen" do
+        assert !I18n.t(:string).frozen?
+      end
+
+      define_method "test lookup: a resulting Array is not frozen" do
+        assert !I18n.t(:array).frozen?
+      end
+
+      define_method "test lookup: a resulting Hash is not frozen" do
+        assert !I18n.t(:hash).frozen?
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/pluralization.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/pluralization.rb
new file mode 100644
index 0000000..8d0fc2d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/pluralization.rb
@@ -0,0 +1,35 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Pluralization
+      define_method "test pluralization: given 0 it returns the :zero translation if it is defined" do
+        assert_equal 'zero', I18n.t(:default => { :zero => 'zero' }, :count => 0)
+      end
+
+      define_method "test pluralization: given 0 it returns the :other translation if :zero is not defined" do
+        assert_equal 'bars', I18n.t(:default => { :other => 'bars' }, :count => 0)
+      end
+
+      define_method "test pluralization: given 1 it returns the singular translation" do
+        assert_equal 'bar', I18n.t(:default => { :one => 'bar' }, :count => 1)
+      end
+
+      define_method "test pluralization: given 2 it returns the :other translation" do
+        assert_equal 'bars', I18n.t(:default => { :other => 'bars' }, :count => 2)
+      end
+
+      define_method "test pluralization: given 3 it returns the :other translation" do
+        assert_equal 'bars', I18n.t(:default => { :other => 'bars' }, :count => 3)
+      end
+
+      define_method "test pluralization: given nil it returns the whole entry" do
+        assert_equal({ :one => 'bar' }, I18n.t(:default => { :one => 'bar' }, :count => nil))
+      end
+
+      define_method "test pluralization: given incomplete pluralization data it raises I18n::InvalidPluralizationData" do
+        assert_raise(I18n::InvalidPluralizationData) { I18n.t(:default => { :one => 'bar' }, :count => 2) }
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/procs.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/procs.rb
new file mode 100644
index 0000000..ec0b45a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/api/tests/procs.rb
@@ -0,0 +1,55 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Procs
+      define_method "test lookup: given a translation is a proc it calls the proc with the key and interpolation values" do
+        if can_store_procs?
+          store_translations(:a_lambda => lambda { |*args| args.inspect })
+          assert_equal '[:a_lambda, {:foo=>"foo"}]', I18n.t(:a_lambda, :foo => 'foo')
+        end
+      end
+
+      define_method "test defaults: given a default is a Proc it calls it with the key and interpolation values" do
+        proc = lambda { |*args| args.inspect }
+        assert_equal '[nil, {:foo=>"foo"}]', I18n.t(nil, :default => proc, :foo => 'foo')
+      end
+
+      define_method "test defaults: given a default is a key that resolves to a Proc it calls it with the key and interpolation values" do
+        if can_store_procs?
+          store_translations(:a_lambda => lambda { |*args| args.inspect })
+          assert_equal '[:a_lambda, {:foo=>"foo"}]', I18n.t(nil, :default => :a_lambda, :foo => 'foo')
+          assert_equal '[:a_lambda, {:foo=>"foo"}]', I18n.t(nil, :default => [nil, :a_lambda], :foo => 'foo')
+        end
+      end
+
+      define_method "test interpolation: given an interpolation value is a lambda it calls it with key and values before interpolating it" do
+        proc = lambda { |*args| args.inspect }
+        assert_match %r(\[\{:foo=>#<Proc.*>\}\]), I18n.t(nil, :default => '%{foo}', :foo => proc)
+      end
+
+      define_method "test interpolation: given a key resolves to a Proc that returns a string then interpolation still works" do
+        proc = lambda { |*args| "%{foo}: " + args.inspect }
+        assert_equal 'foo: [nil, {:foo=>"foo"}]', I18n.t(nil, :default => proc, :foo => 'foo')
+      end
+
+      define_method "test pluralization: given a key resolves to a Proc that returns valid data then pluralization still works" do
+        proc = lambda { |*args| { :zero => 'zero', :one => 'one', :other => 'other' } }
+        assert_equal 'zero',  I18n.t(:default => proc, :count => 0)
+        assert_equal 'one',   I18n.t(:default => proc, :count => 1)
+        assert_equal 'other', I18n.t(:default => proc, :count => 2)
+      end
+
+      define_method "test lookup: given the option :resolve => false was passed it does not resolve proc translations" do
+        if can_store_procs?
+          store_translations(:a_lambda => lambda { |*args| args.inspect })
+          assert_equal Proc, I18n.t(:a_lambda, :resolve => false).class
+        end
+      end
+
+      define_method "test lookup: given the option :resolve => false was passed it does not resolve proc default" do
+        assert_equal Proc, I18n.t(nil, :default => lambda { |*args| args.inspect }, :resolve => false).class
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record/missing_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record/missing_test.rb
new file mode 100644
index 0000000..89f461d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record/missing_test.rb
@@ -0,0 +1,51 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../../')); $:.uniq!
+require 'test_helper'
+
+setup_active_record
+
+class I18nActiveRecordMissingTest < Test::Unit::TestCase
+  def setup
+    store_translations(:en, :i18n => { :plural => { :keys => [:zero, :one, :other] } })
+    
+    I18n.backend = I18n::Backend::Chain.new(I18n.backend)
+    I18n.backend.meta_class.send(:include, I18n::Backend::ActiveRecord::Missing)
+    
+    I18n::Backend::ActiveRecord::Translation.delete_all
+  end
+  
+  test "can persist interpolations" do
+    translation = I18n::Backend::ActiveRecord::Translation.new(:key => 'foo', :value => 'bar', :locale => :en)
+    translation.interpolations = %w(count name)
+    translation.save
+    assert translation.valid?
+  end
+
+  test "lookup persists the key" do
+    I18n.t('foo.bar.baz')
+    assert_equal 1, I18n::Backend::ActiveRecord::Translation.count
+  end
+
+  test "lookup does not persist the key twice" do
+    2.times { I18n.t('foo.bar.baz') }
+    assert_equal 1, I18n::Backend::ActiveRecord::Translation.count
+  end
+  
+  test "lookup persists interpolation keys when looked up directly" do
+    I18n.t('foo.bar.baz', :cow => "lucy" )  # creates stub translation.
+    translation_stub = I18n::Backend::ActiveRecord::Translation.locale(:en).lookup('foo.bar.baz').first
+    assert translation_stub.interpolates?(:cow)
+  end
+
+  test "creates one stub per pluralization" do
+    I18n.t('foo', :count => 999)
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).find_all_by_key %w{ foo.zero foo.one foo.other }
+    assert_equal 3, translations.length
+  end
+
+  test "creates no stub for base key in pluralization" do
+    I18n.t('foo', :count => 999)
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).find_by_key %w{ foo.zero foo.one foo.other }
+    assert !I18n::Backend::ActiveRecord::Translation.locale(:en).find_by_key("foo")
+  end
+end if defined?(ActiveRecord)
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record_test.rb
new file mode 100644
index 0000000..97cb269
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/active_record_test.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+setup_active_record
+
+class I18nBackendActiveRecordTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::ActiveRecord.new
+    store_translations(:en, :foo => { :bar => 'bar', :baz => 'baz' })
+  end
+
+  def teardown
+    I18n::Backend::ActiveRecord::Translation.destroy_all
+    super
+  end
+
+  test "store_translations does not allow ambiguous keys (1)" do
+    I18n::Backend::ActiveRecord::Translation.delete_all
+    I18n.backend.store_translations(:en, :foo => 'foo')
+    I18n.backend.store_translations(:en, :foo => { :bar => 'bar' })
+    I18n.backend.store_translations(:en, :foo => { :baz => 'baz' })
+
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).lookup('foo').all
+    assert_equal %w(bar baz), translations.map(&:value)
+
+    assert_equal({ :bar => 'bar', :baz => 'baz' }, I18n.t(:foo))
+  end
+
+  test "store_translations does not allow ambiguous keys (2)" do
+    I18n::Backend::ActiveRecord::Translation.delete_all
+    I18n.backend.store_translations(:en, :foo => { :bar => 'bar' })
+    I18n.backend.store_translations(:en, :foo => { :baz => 'baz' })
+    I18n.backend.store_translations(:en, :foo => 'foo')
+
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).lookup('foo').all
+    assert_equal %w(foo), translations.map(&:value)
+
+    assert_equal 'foo', I18n.t(:foo)
+  end
+  
+  test "can store translations with keys that are translations containing special chars" do
+    I18n.backend.store_translations(:es, :"Pagina's" => "Pagina's" )
+    assert_equal "Pagina's", I18n.t(:"Pagina's", :locale => :es)
+  end
+
+  with_mocha do
+    test "missing translations table does not cause an error in #available_locales" do
+      I18n::Backend::ActiveRecord::Translation.expects(:available_locales).raises(::ActiveRecord::StatementInvalid)
+      assert_equal [], I18n.backend.available_locales
+    end
+  end
+
+  def test_expand_keys
+    assert_equal %w(foo foo.bar foo.bar.baz), I18n.backend.send(:expand_keys, :'foo.bar.baz')
+  end
+end if defined?(ActiveRecord)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cache_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cache_test.rb
new file mode 100644
index 0000000..2cbe8a3
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cache_test.rb
@@ -0,0 +1,70 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+begin
+  require 'active_support'
+rescue LoadError
+  $stderr.puts "Skipping cache tests using ActiveSupport"
+else
+
+class I18nBackendCacheTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Cache
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+    I18n.cache_store = ActiveSupport::Cache.lookup_store(:memory_store)
+  end
+
+  def teardown
+    I18n.cache_store = nil
+  end
+
+  test "it uses the cache" do
+    assert I18n.cache_store.is_a?(ActiveSupport::Cache::MemoryStore)
+  end
+
+  with_mocha do
+    test "translate hits the backend and caches the response" do
+      I18n.backend.expects(:lookup).returns('Foo')
+      assert_equal 'Foo', I18n.t(:foo)
+
+      I18n.backend.expects(:lookup).never
+      assert_equal 'Foo', I18n.t(:foo)
+
+      I18n.backend.expects(:lookup).returns('Bar')
+      assert_equal 'Bar', I18n.t(:bar)
+    end
+
+    test "still raises MissingTranslationData but also caches it" do
+      I18n.backend.expects(:lookup).returns(nil)
+      assert_raise(I18n::MissingTranslationData) { I18n.t(:missing, :raise => true) }
+
+      I18n.backend.expects(:lookup).never
+      assert_raise(I18n::MissingTranslationData) { I18n.t(:missing, :raise => true) }
+    end
+  end
+
+  test "uses 'i18n' as a cache key namespace by default" do
+    assert_equal 0, I18n.backend.send(:cache_key, :foo).index('i18n')
+  end
+
+  test "adds a custom cache key namespace" do
+    with_cache_namespace('bar') do
+      assert_equal 0, I18n.backend.send(:cache_key, :foo).index('i18n-bar')
+    end
+  end
+
+  protected
+
+    def with_cache_namespace(namespace)
+      I18n.cache_namespace = namespace
+      yield
+      I18n.cache_namespace = nil
+    end
+end
+
+end # AS cache check
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cascade_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cascade_test.rb
new file mode 100644
index 0000000..be5dc4f
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cascade_test.rb
@@ -0,0 +1,72 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendCascadeTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Cascade
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en,
+      :foo => 'foo',
+      :bar => { :baz => 'baz' }
+    )
+  end
+
+  def lookup(key, options = {})
+    I18n.t(key, options.merge(:cascade => { :step => 1, :offset => 1, :skip_root => false }))
+  end
+
+  test "still returns an existing translation as usual" do
+    assert_equal 'foo', lookup(:foo)
+    assert_equal 'baz', lookup(:'bar.baz')
+  end
+
+  test "falls back by cutting keys off the end of the scope" do
+    assert_equal 'foo', lookup(:foo, :scope => :'missing')
+    assert_equal 'foo', lookup(:foo, :scope => :'missing.missing')
+    assert_equal 'baz', lookup(:baz, :scope => :'bar.missing')
+    assert_equal 'baz', lookup(:baz, :scope => :'bar.missing.missing')
+  end
+
+  test "raises I18n::MissingTranslationData exception when no translation was found" do
+    assert_raise(I18n::MissingTranslationData) { lookup(:'foo.missing', :raise => true) }
+    assert_raise(I18n::MissingTranslationData) { lookup(:'bar.baz.missing', :raise => true) }
+    assert_raise(I18n::MissingTranslationData) { lookup(:'missing.bar.baz', :raise => true) }
+  end
+
+  test "cascades before evaluating the default" do
+    assert_equal 'foo', lookup(:foo, :scope => :missing, :default => 'default')
+  end
+  
+  test "cascades defaults, too" do
+    assert_equal 'foo', lookup(nil, :default => [:'missing.missing', :'missing.foo'])
+  end
+
+  test "let's us assemble required fallbacks for ActiveRecord validation messages" do
+    store_translations(:en,
+      :errors => {
+        :reply => {
+          :title => {
+            :blank => 'blank on reply title'
+          },
+          :taken => 'taken on reply'
+        },
+        :topic => {
+          :title => {
+            :format => 'format on topic title'
+          },
+          :length => 'length on topic'
+        },
+        :odd => 'odd on errors'
+      }
+    )
+    assert_equal 'blank on reply title',  lookup(:'errors.reply.title.blank',  :default => :'errors.topic.title.blank')
+    assert_equal 'taken on reply',        lookup(:'errors.reply.title.taken',  :default => :'errors.topic.title.taken')
+    assert_equal 'format on topic title', lookup(:'errors.reply.title.format', :default => :'errors.topic.title.format')
+    assert_equal 'length on topic',       lookup(:'errors.reply.title.length', :default => :'errors.topic.title.length')
+    assert_equal 'odd on errors',         lookup(:'errors.reply.title.odd',    :default => :'errors.topic.title.odd')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/chain_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/chain_test.rb
new file mode 100644
index 0000000..1a9874f
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/chain_test.rb
@@ -0,0 +1,63 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendChainTest < Test::Unit::TestCase
+  def setup
+    @first  = backend(:en => {
+      :foo => 'Foo', :formats => { :short => 'short' }, :plural_1 => { :one => '%{count}' }
+    })
+    @second = backend(:en => {
+      :bar => 'Bar', :formats => { :long => 'long' }, :plural_2 => { :one => 'one' }
+    })
+    @chain  = I18n.backend = I18n::Backend::Chain.new(@first, @second)
+  end
+
+  test "looks up translations from the first chained backend" do
+    assert_equal 'Foo', @first.send(:translations)[:en][:foo]
+    assert_equal 'Foo', I18n.t(:foo)
+  end
+
+  test "looks up translations from the second chained backend" do
+    assert_equal 'Bar', @second.send(:translations)[:en][:bar]
+    assert_equal 'Bar', I18n.t(:bar)
+  end
+
+  test "defaults only apply to lookups on the last backend in the chain" do
+    assert_equal 'Foo', I18n.t(:foo, :default => 'Bah')
+    assert_equal 'Bar', I18n.t(:bar, :default => 'Bah')
+    assert_equal 'Bah', I18n.t(:bah, :default => 'Bah') # default kicks in only here
+  end
+
+  test "default" do
+    assert_equal 'Fuh',  I18n.t(:default => 'Fuh')
+    assert_equal 'Zero', I18n.t(:default => { :zero => 'Zero' }, :count => 0)
+    assert_equal({ :zero => 'Zero' }, I18n.t(:default => { :zero => 'Zero' }))
+    assert_equal 'Foo', I18n.t(:default => :foo)
+  end
+
+  test "namespace lookup collects results from all backends" do
+    assert_equal({ :short => 'short', :long => 'long' }, I18n.t(:formats))
+  end
+
+  test "namespace lookup with only the first backend returning a result" do
+    assert_equal({ :one => '%{count}' }, I18n.t(:plural_1))
+  end
+
+  test "pluralization still works" do
+    assert_equal '1',   I18n.t(:plural_1, :count => 1)
+    assert_equal 'one', I18n.t(:plural_2, :count => 1)
+  end
+
+  test "bulk lookup collects results from all backends" do
+    assert_equal ['Foo', 'Bar'], I18n.t([:foo, :bar])
+  end
+
+  protected
+
+    def backend(translations)
+      backend = I18n::Backend::Simple.new
+      translations.each { |locale, translations| backend.store_translations(locale, translations) }
+      backend
+    end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cldr_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cldr_test.rb
new file mode 100644
index 0000000..4b21cb2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/cldr_test.rb
@@ -0,0 +1,150 @@
+# encoding: utf-8
+
+begin
+  require 'cldr'
+rescue LoadError
+  puts "Skipping tests for I18n::Backend::Cldr because the ruby-cldr gem is not installed."
+end
+
+if defined?(Cldr)
+  $:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+  require 'test_helper'
+  require 'i18n/backend/cldr'
+  require 'date'
+
+  class I18nBackendCldrTest < Test::Unit::TestCase
+    class Backend < I18n::Backend::Simple
+      include I18n::Backend::Cldr
+    end
+
+    def setup
+      I18n.backend = Backend.new
+      I18n.locale = :de
+      I18n.load_path += Dir[locales_dir + '/cldr/**/*.{yml,rb}']
+      super
+    end
+
+    # NUMBER
+
+    test "format_number" do
+      assert_equal '123.456,78', I18n.l(123456.78)
+    end
+
+    # CURRENCY
+
+    test "format_currency" do
+      assert_equal '123.456,78 EUR', I18n.l(123456.78, :currency => 'EUR')
+    end
+
+    # hu? does this actually make any sense?
+    test "format_currency translating currency names" do
+      assert_equal '1,00 Irisches Pfund', I18n.l(1, :currency => :IEP)
+      assert_equal '2,00 Irische Pfund',  I18n.l(2, :currency => :IEP)
+    end
+
+    # PERCENT
+
+    # this is odd but the cldr percent format does not include a fraction
+    test "format_percent" do
+      assert_equal '123.457 %', I18n.l(123456.78, :as => :percent)
+    end
+
+    # so we can pass a precision manually
+    test "format_percent w/ precision" do
+      assert_equal '123.456,70 %', I18n.l(123456.7, :as => :percent, :precision => 2)
+    end
+
+    # DATE
+
+    def date
+      Date.new(2010, 1, 1)
+    end
+
+    test "format_date :full" do
+      assert_equal 'Freitag, 1. Januar 2010', I18n.l(date, :format => :full)
+    end
+
+    test "format_date :long" do
+      assert_equal '1. Januar 2010', I18n.l(date, :format => :long)
+    end
+
+    test "format_date :medium" do
+      assert_equal '01.01.2010', I18n.l(date)
+    end
+
+    test "format_date :short" do
+      assert_equal '01.01.10', I18n.l(date, :format => :short)
+    end
+
+    # TIME
+
+    def time
+      Time.utc(2010, 1, 1, 13, 15, 17)
+    end
+
+    # TODO cldr export lacks localized timezone data
+    # test "format_time :full" do
+    #   assert_equal 'Freitag, 1. Januar 2010', I18n.l(time, :format => :full)
+    # end
+
+    test "format_time :long" do
+      assert_equal '13:15:17 UTC', I18n.l(time, :format => :long)
+    end
+
+    test "format_time :medium" do
+      assert_equal '13:15:17', I18n.l(time)
+    end
+
+    test "format_time :short" do
+      assert_equal '13:15', I18n.l(time, :format => :short)
+    end
+
+    # DATETIME
+
+    def datetime
+      DateTime.new(2010, 11, 12, 13, 14, 15)
+    end
+
+    # TODO cldr export lacks localized timezone data
+    # test "format_datetime :full" do
+    #   assert_equal 'Thursday, 12. November 2010 13:14:15', I18n.l(datetime, :format => :full)
+    # end
+
+    test "format_datetime :long" do
+      assert_equal '12. November 2010 13:14:15 +00:00', I18n.l(datetime, :format => :long)
+    end
+
+    test "format_datetime :medium" do
+      assert_equal '12.11.2010 13:14:15', I18n.l(datetime)
+    end
+
+    test "format_datetime :short" do
+      assert_equal '12.11.10 13:14', I18n.l(datetime, :format => :short)
+    end
+
+    test "format_datetime mixed :long + :short" do
+      assert_equal '12. November 2010 13:14', I18n.l(datetime, :date_format => :long, :time_format => :short)
+    end
+
+    test "format_datetime mixed :short + :long" do
+      assert_equal '12.11.10 13:14:15 +00:00', I18n.l(datetime, :date_format => :short, :time_format => :long)
+    end
+
+    # CUSTOM FORMATS
+
+    test "can deal with customized formats data" do
+      store_translations :de, :numbers => {
+        :formats => {
+          :decimal => {
+            :patterns => {
+              :default => "#,##0.###",
+              :stupid  => "#"
+            }
+          }
+        }
+      }
+      assert_equal '123.456,78', I18n.l(123456.78)
+      assert_equal '123457',     I18n.l(123456.78, :format => :stupid)
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/exceptions_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/exceptions_test.rb
new file mode 100644
index 0000000..37f7d54
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/exceptions_test.rb
@@ -0,0 +1,25 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendExceptionsTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::Simple.new
+  end
+
+  test "exceptions: MissingTranslationData message from #translate includes the given scope and full key" do
+    begin
+      I18n.t(:'baz.missing', :scope => :'foo.bar', :raise => true)
+    rescue I18n::MissingTranslationData => exception
+    end
+    assert_equal "translation missing: en, foo, bar, baz, missing", exception.message
+  end
+
+  test "exceptions: MissingTranslationData message from #localize includes the given scope and full key" do
+    begin
+      I18n.l(Time.now, :format => :foo)
+    rescue I18n::MissingTranslationData => exception
+    end
+    assert_equal "translation missing: en, time, formats, foo", exception.message
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/fallbacks_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/fallbacks_test.rb
new file mode 100644
index 0000000..de32b04
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/fallbacks_test.rb
@@ -0,0 +1,104 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendFallbacksTranslateTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en, :foo => 'Foo in :en', :bar => 'Bar in :en', :buz => 'Buz in :en')
+    store_translations(:de, :bar => 'Bar in :de', :baz => 'Baz in :de')
+    store_translations(:'de-DE', :baz => 'Baz in :de-DE')
+  end
+
+  test "still returns an existing translation as usual" do
+    assert_equal 'Foo in :en', I18n.t(:foo, :locale => :en)
+    assert_equal 'Bar in :de', I18n.t(:bar, :locale => :de)
+    assert_equal 'Baz in :de-DE', I18n.t(:baz, :locale => :'de-DE')
+  end
+
+  test "returns the :en translation for a missing :de translation" do
+    assert_equal 'Foo in :en', I18n.t(:foo, :locale => :de)
+  end
+
+  test "returns the :de translation for a missing :'de-DE' translation" do
+    assert_equal 'Bar in :de', I18n.t(:bar, :locale => :'de-DE')
+  end
+
+  test "returns the :en translation for translation missing in both :de and :'de-De'" do
+    assert_equal 'Buz in :en', I18n.t(:buz, :locale => :'de-DE')
+  end
+
+  test "returns the :de translation for a missing :'de-DE' when :default is a String" do
+    assert_equal 'Bar in :de', I18n.t(:bar, :locale => :'de-DE', :default => "Default Bar")
+    assert_equal "Default Bar", I18n.t(:missing_bar, :locale => :'de-DE', :default => "Default Bar")
+  end
+
+  test "returns the :'de-DE' default :baz translation for a missing :'de-DE' when defaults contains Symbol" do
+    assert_equal 'Baz in :de-DE', I18n.t(:missing_foo, :locale => :'de-DE', :default => [:baz, "Default Bar"])
+  end
+
+  test "returns the defaults translation for a missing :'de-DE' when defaults a contains String before Symbol" do
+    assert_equal "Default Bar", I18n.t(:missing_foo, :locale => :'de-DE', :default => [:missing_bar, "Default Bar", :baz])
+  end
+
+  test "returns the default translation for a missing :'de-DE' and existing :de when default is a Hash" do
+    assert_equal 'Default 6 Bars', I18n.t(:missing_foo, :locale => :'de-DE', :default => [:missing_bar, {:other => "Default %{count} Bars"}, "Default Bar"], :count => 6)
+  end
+
+  test "raises I18n::MissingTranslationData exception when no translation was found" do
+    assert_raise(I18n::MissingTranslationData) { I18n.t(:faa, :locale => :en, :raise => true) }
+    assert_raise(I18n::MissingTranslationData) { I18n.t(:faa, :locale => :de, :raise => true) }
+  end
+end
+
+class I18nBackendFallbacksLocalizeTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en, :date => { :formats => { :en => 'en' }, :day_names => %w(Sunday) })
+    store_translations(:de, :date => { :formats => { :de => 'de' } })
+  end
+
+  test "still uses an existing format as usual" do
+    assert_equal 'en', I18n.l(Date.today, :format => :en, :locale => :en)
+  end
+
+  test "looks up and uses a fallback locale's format for a key missing in the given locale (1)" do
+    assert_equal 'en', I18n.l(Date.today, :format => :en, :locale => :de)
+  end
+
+  test "looks up and uses a fallback locale's format for a key missing in the given locale (2)" do
+    assert_equal 'de', I18n.l(Date.today, :format => :de, :locale => :'de-DE')
+  end
+
+  test "still uses an existing day name translation as usual" do
+    assert_equal 'Sunday', I18n.l(Date.new(2010, 1, 3), :format => '%A', :locale => :en)
+  end
+
+  test "uses a fallback locale's translation for a key missing in the given locale" do
+    assert_equal 'Sunday', I18n.l(Date.new(2010, 1, 3), :format => '%A', :locale => :de)
+  end
+end
+
+class I18nBackendFallbacksWithChainTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    backend = Backend.new
+    backend.store_translations(:de, :foo => 'FOO')
+    I18n.backend = I18n::Backend::Chain.new(I18n::Backend::Simple.new, backend)
+  end
+
+  test "falls back from de-DE to de when there is no translation for de-DE available" do
+    assert_equal 'FOO', I18n.t(:foo, :locale => :'de-DE')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/interpolation_compiler_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/interpolation_compiler_test.rb
new file mode 100644
index 0000000..b87c3f2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/interpolation_compiler_test.rb
@@ -0,0 +1,105 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'api'
+
+class InterpolationCompilerTest < Test::Unit::TestCase
+  Compiler = I18n::Backend::InterpolationCompiler::Compiler
+
+  def compile_and_interpolate(str, values = {})
+    Compiler.compile_if_an_interpolation(str).i18n_interpolate(values)
+  end
+
+  def assert_escapes_interpolation_key(expected, malicious_str)
+    assert_equal(expected, Compiler.send(:escape_key_sym, malicious_str))
+  end
+
+  def test_escape_key_properly_escapes
+    assert_escapes_interpolation_key ':"\""',       '"'
+    assert_escapes_interpolation_key ':"\\\\"',     '\\'
+    assert_escapes_interpolation_key ':"\\\\\""',   '\\"'
+    assert_escapes_interpolation_key ':"\#{}"',     '#{}'
+    assert_escapes_interpolation_key ':"\\\\\#{}"', '\#{}'
+  end
+
+  def assert_escapes_plain_string(expected, plain_str)
+    assert_equal expected, Compiler.send(:escape_plain_str, plain_str)
+  end
+
+  def test_escape_plain_string_properly_escapes
+    assert_escapes_plain_string '\\"',    '"'
+    assert_escapes_plain_string '\'',     '\''
+    assert_escapes_plain_string '\\#',    '#'
+    assert_escapes_plain_string '\\#{}',  '#{}'
+    assert_escapes_plain_string '\\\\\\"','\\"'
+  end
+
+  def test_non_interpolated_strings_or_arrays_dont_get_compiled
+    ['abc', '\\{a}}', '{a}}', []].each do |obj|
+      Compiler.compile_if_an_interpolation(obj)
+      assert_equal false, obj.respond_to?(:i18n_interpolate)
+    end
+  end
+
+  def test_interpolated_string_gets_compiled
+    assert_equal '-A-', compile_and_interpolate('-%{a}-', :a => 'A')
+  end
+
+  def assert_handles_key(str, key)
+    assert_equal 'A', compile_and_interpolate(str, key => 'A')
+  end
+
+  def test_compiles_fancy_keys
+    assert_handles_key('%{\}',       :'\\'    )
+    assert_handles_key('%{#}',       :'#'     )
+    assert_handles_key('%{#{}',      :'#{'    )
+    assert_handles_key('%{#$SAFE}',  :'#$SAFE')
+    assert_handles_key('%{\000}',    :'\000'  )
+    assert_handles_key('%{\'}',      :'\''    )
+    assert_handles_key('%{\'\'}',    :'\'\''  )
+    assert_handles_key('%{a.b}',     :'a.b'   )
+    assert_handles_key('%{ }',       :' '     )
+    assert_handles_key('%{:}',       :':'     )
+    assert_handles_key("%{:''}",     :":''"   )
+    assert_handles_key('%{:"}',      :':"'    )
+  end
+
+  def test_str_containing_only_escaped_interpolation_is_handled_correctly
+    assert_equal 'abc %{x}', compile_and_interpolate('abc %%{x}')
+  end
+
+  def test_handles_weird_strings
+    assert_equal '#{} a',         compile_and_interpolate('#{} %{a}',         :a    => 'a')
+    assert_equal '"#{abc}"',      compile_and_interpolate('"#{ab%{a}c}"',     :a    => '' )
+    assert_equal 'a}',            compile_and_interpolate('%{{a}}',           :'{a' => 'a')
+    assert_equal '"',             compile_and_interpolate('"%{a}',            :a    => '' )
+    assert_equal 'a%{a}',         compile_and_interpolate('%{a}%%{a}',        :a    => 'a')
+    assert_equal '%%{a}',         compile_and_interpolate('%%%{a}')
+    assert_equal '\";eval("a")',  compile_and_interpolate('\";eval("%{a}")',  :a    => 'a')
+    assert_equal '\";eval("a")',  compile_and_interpolate('\";eval("a")%{a}', :a    => '' )
+    assert_equal "\na",           compile_and_interpolate("\n%{a}",           :a    => 'a')
+  end
+end
+
+class I18nBackendInterpolationCompilerTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::InterpolationCompiler
+  end
+  
+  include Tests::Api::Interpolation
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+  
+  # pre-compile default strings to make sure we are testing I18n::Backend::InterpolationCompiler
+  def interpolate(*args)
+    options = args.last.kind_of?(Hash) ? args.last : {}
+    if default_str = options[:default]
+      I18n::Backend::InterpolationCompiler::Compiler.compile_if_an_interpolation(default_str)
+    end
+    super
+  end
+
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/key_value_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/key_value_test.rb
new file mode 100644
index 0000000..dee720a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/key_value_test.rb
@@ -0,0 +1,50 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+setup_rufus_tokyo
+
+require 'active_support/all'
+
+class I18nBackendKeyValueTest < Test::Unit::TestCase
+  def setup_backend!(subtree=true)
+    I18n.backend = I18n::Backend::KeyValue.new(Rufus::Tokyo::Cabinet.new('*'), subtree)
+    store_translations(:en, :foo => { :bar => 'bar', :baz => 'baz' })
+  end
+
+  def assert_flattens(expected, nested, escape=true, subtree=true)
+    assert_equal expected, I18n.backend.flatten_translations("en", nested, escape, subtree)
+  end
+
+  test "hash flattening works" do
+    setup_backend!
+    assert_flattens(
+      {:a=>'a', :b=>{:c=>'c', :d=>'d', :f=>{:x=>'x'}}, :"b.f" => {:x=>"x"}, :"b.c"=>"c", :"b.f.x"=>"x", :"b.d"=>"d"},
+      {:a=>'a', :b=>{:c=>'c', :d=>'d', :f=>{:x=>'x'}}}
+    )
+    assert_flattens({:a=>{:b =>['a', 'b']}, :"a.b"=>['a', 'b']}, {:a=>{:b =>['a', 'b']}})
+    assert_flattens({:"a\001b" => "c"}, {:"a.b" => "c"})
+    assert_flattens({:"a.b"=>['a', 'b']}, {:a=>{:b =>['a', 'b']}}, true, false)
+    assert_flattens({:"a.b" => "c"}, {:"a.b" => "c"}, false)
+  end
+
+  test "store_translations handle subtrees by default" do
+    setup_backend!
+    assert_equal({ :bar => 'bar', :baz => 'baz' }, I18n.t("foo"))
+  end
+
+  test "store_translations merge subtrees accordingly" do
+    setup_backend!
+    store_translations(:en, :foo => { :baz => "BAZ"})
+    assert_equal('BAZ', I18n.t("foo.baz"))
+    assert_equal({ :bar => 'bar', :baz => 'BAZ' }, I18n.t("foo"))
+  end
+
+  test "store_translations does not handle subtrees if desired" do
+    setup_backend!(false)
+    assert_raise I18n::MissingTranslationData do
+      I18n.t("foo", :raise => true)
+    end
+  end
+
+end if defined?(Rufus::Tokyo::Cabinet)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/memoize_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/memoize_test.rb
new file mode 100644
index 0000000..e9ed8c8
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/memoize_test.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'backend/simple_test'
+
+class I18nBackendMemoizeTest < I18nBackendSimpleTest
+  class MemoizeBackend < I18n::Backend::Simple
+    include I18n::Backend::Memoize
+  end
+  
+  def setup
+    I18n.backend = MemoizeBackend.new
+    super
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/metadata_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/metadata_test.rb
new file mode 100644
index 0000000..9e529e7
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/metadata_test.rb
@@ -0,0 +1,69 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendMetadataTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Metadata
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en, :foo => 'Hi %{name}')
+  end
+
+  test "translation strings carry metadata" do
+    translation = I18n.t(:foo, :name => 'David')
+    assert translation.respond_to?(:translation_metadata)
+    assert translation.translation_metadata.is_a?(Hash)
+  end
+
+  test "translate preserves metadata stored on original Strings" do
+    store_metadata(:foo, :bar, 'bar')
+    assert_equal 'bar', I18n.t(:foo, :name => 'David').translation_metadata[:bar]
+  end
+
+  test "translate preserves metadata stored on original Strings (when interpolated)" do
+    store_metadata(:foo, :bar, 'bar')
+    assert_equal 'bar', I18n.t(:foo, :name => 'David').translation_metadata[:bar]
+  end
+
+  test "translate adds the locale to metadata on Strings" do
+    assert_equal :en, I18n.t(:foo, :name => 'David', :locale => :en).translation_metadata[:locale]
+  end
+
+  test "translate adds the key to metadata on Strings" do
+    assert_equal :foo, I18n.t(:foo, :name => 'David').translation_metadata[:key]
+  end
+#
+  test "translate adds the default to metadata on Strings" do
+    assert_equal 'bar', I18n.t(:foo, :default => 'bar', :name => '').translation_metadata[:default]
+  end
+
+  test "translation adds the interpolation values to metadata on Strings" do
+    assert_equal({:name => 'David'}, I18n.t(:foo, :name => 'David').translation_metadata[:values])
+  end
+
+  test "interpolation adds the original string to metadata on Strings" do
+    assert_equal('Hi %{name}', I18n.t(:foo, :name => 'David').translation_metadata[:original])
+  end
+
+  test "pluralization adds the count to metadata on Strings" do
+    assert_equal(1, I18n.t(:missing, :count => 1, :default => { :one => 'foo' }).translation_metadata[:count])
+  end
+
+  test "metadata works with frozen values" do
+    assert_equal(1, I18n.t(:missing, :count => 1, :default => 'foo'.freeze).translation_metadata[:count])
+  end
+  
+  protected
+  
+    def translations
+      I18n.backend.instance_variable_get(:@translations)
+    end
+
+    def store_metadata(key, name, value)
+      translations[:en][key].translation_metadata[name] = value
+    end
+end
+
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/pluralization_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/pluralization_test.rb
new file mode 100644
index 0000000..1af0088
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/pluralization_test.rb
@@ -0,0 +1,46 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendPluralizationTest < Test::Unit::TestCase
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Pluralization
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    @rule = lambda { |n| n == 1 ? :one : n == 0 || (2..10).include?(n % 100) ? :few : (11..19).include?(n % 100) ? :many : :other }
+    store_translations(:xx, :i18n => { :plural => { :rule => @rule } })
+    @entry = { :zero => 'zero', :one => 'one', :few => 'few', :many => 'many', :other => 'other' }
+  end
+
+  test "pluralization picks a pluralizer from :'i18n.pluralize'" do
+    assert_equal @rule, I18n.backend.send(:pluralizer, :xx)
+  end
+
+  test "pluralization picks :one for 1" do
+    assert_equal 'one', I18n.t(:count => 1, :default => @entry, :locale => :xx)
+  end
+
+  test "pluralization picks :few for 2" do
+    assert_equal 'few', I18n.t(:count => 2, :default => @entry, :locale => :xx)
+  end
+
+  test "pluralization picks :many for 11" do
+    assert_equal 'many', I18n.t(:count => 11, :default => @entry, :locale => :xx)
+  end
+
+  test "pluralization picks zero for 0 if the key is contained in the data" do
+    assert_equal 'zero', I18n.t(:count => 0, :default => @entry, :locale => :xx)
+  end
+
+  test "pluralization picks few for 0 if the key is not contained in the data" do
+    @entry.delete(:zero)
+    assert_equal 'few', I18n.t(:count => 0, :default => @entry, :locale => :xx)
+  end
+
+  test "Fallbacks can pick up rules from fallback locales, too" do
+    assert_equal @rule, I18n.backend.send(:pluralizer, :'xx-XX')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/simple_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/simple_test.rb
new file mode 100644
index 0000000..3a8f093
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/simple_test.rb
@@ -0,0 +1,81 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendSimpleTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::Simple.new
+    I18n.load_path = [locales_dir + '/en.yml']
+  end
+
+  # useful because this way we can use the backend with no key for interpolation/pluralization
+  test "simple backend translate: given nil as a key it still interpolations the default value" do
+    assert_equal "Hi David", I18n.t(nil, :default => "Hi %{name}", :name => "David")
+  end
+  
+  # loading translations
+  test "simple load_translations: given an unknown file type it raises I18n::UnknownFileType" do
+    assert_raise(I18n::UnknownFileType) { I18n.backend.load_translations("#{locales_dir}/en.xml") }
+  end
+  
+  test "simple load_translations: given a Ruby file name it does not raise anything" do
+    assert_nothing_raised { I18n.backend.load_translations("#{locales_dir}/en.rb") }
+  end
+
+  test "simple load_translations: given no argument, it uses I18n.load_path" do
+    I18n.backend.load_translations
+    assert_equal({ :en => { :foo => { :bar => 'baz' } } }, I18n.backend.send(:translations))
+  end
+  
+  test "simple load_rb: loads data from a Ruby file" do
+    data = I18n.backend.send(:load_rb, "#{locales_dir}/en.rb")
+    assert_equal({ :en => { :fuh => { :bah => 'bas' } } }, data)
+  end
+
+  test "simple load_yml: loads data from a YAML file" do
+    data = I18n.backend.send(:load_yml, "#{locales_dir}/en.yml")
+    assert_equal({ 'en' => { 'foo' => { 'bar' => 'baz' } } }, data)
+  end
+
+  test "simple load_translations: loads data from known file formats" do
+    I18n.backend = I18n::Backend::Simple.new
+    I18n.backend.load_translations("#{locales_dir}/en.rb", "#{locales_dir}/en.yml")
+    expected = { :en => { :fuh => { :bah => "bas" }, :foo => { :bar => "baz" } } }
+    assert_equal expected, translations
+  end
+  
+  # storing translations
+
+  test "simple store_translations: stores translations, ... no, really :-)" do
+    I18n.backend.store_translations :'en', :foo => 'bar'
+    assert_equal Hash[:'en', {:foo => 'bar'}], translations
+  end
+
+  test "simple store_translations: deep_merges with existing translations" do
+    I18n.backend.store_translations :'en', :foo => {:bar => 'bar'}
+    I18n.backend.store_translations :'en', :foo => {:baz => 'baz'}
+    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], translations
+  end
+
+  test "simple store_translations: converts the given locale to a Symbol" do
+    I18n.backend.store_translations 'en', :foo => 'bar'
+    assert_equal Hash[:'en', {:foo => 'bar'}], translations
+  end
+
+  test "simple store_translations: converts keys to Symbols" do
+    I18n.backend.store_translations 'en', 'foo' => {'bar' => 'bar', 'baz' => 'baz'}
+    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], translations
+  end
+  
+  # reloading translations
+
+  test "simple reload_translations: unloads translations" do
+    I18n.backend.reload!
+    assert_nil translations
+  end
+
+  test "simple reload_translations: uninitializes the backend" do
+    I18n.backend.reload!
+    assert_equal I18n.backend.initialized?, false
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/transliterator_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/transliterator_test.rb
new file mode 100644
index 0000000..41cab18
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/backend/transliterator_test.rb
@@ -0,0 +1,83 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nBackendTransliterator < Test::Unit::TestCase
+
+  def setup
+    I18n.backend = I18n::Backend::Simple.new
+    @proc = lambda { |n| n.upcase }
+    @hash = { :"ü" => "ue", :"ö" => "oe" }
+    @transliterator = I18n::Backend::Transliterator.get
+  end
+
+  test "transliteration rule can be a proc" do
+    store_translations(:xx, :i18n => {:transliterate => {:rule => @proc}})
+    assert_equal "HELLO", I18n.backend.transliterate(:xx, "hello")
+  end
+
+  test "transliteration rule can be a hash" do
+    store_translations(:xx, :i18n => {:transliterate => {:rule => @hash}})
+    assert_equal "ue", I18n.backend.transliterate(:xx, "ü")
+  end
+
+  test "transliteration rule must be a proc or hash" do
+    store_translations(:xx, :i18n => {:transliterate => {:rule => ""}})
+    assert_raise I18n::ArgumentError do
+      I18n.backend.transliterate(:xx, "ü")
+    end
+  end
+
+  test "transliterator defaults to latin => ascii when no rule is given" do
+    assert_equal "AEroskobing", I18n.backend.transliterate(:xx, "Ærøskøbing")
+  end
+
+  test "default transliterator should not modify ascii characters" do
+    (0..127).each do |byte|
+      char = [byte].pack("U")
+      assert_equal char, @transliterator.transliterate(char)
+    end
+  end
+
+  test "default transliterator correctly transliterates latin characters" do
+    # create string with range of Unicode's western characters with
+    # diacritics, excluding the division and multiplication signs which for
+    # some reason or other are floating in the middle of all the letters.
+    string = (0xC0..0x17E).to_a.reject {|c| [0xD7, 0xF7].include? c}.pack("U*")
+    string.split(//) do |char|
+      assert_match %r{^[a-zA-Z']*$}, @transliterator.transliterate(string)
+    end
+  end
+
+  test "should replace non-ASCII chars not in map with a replacement char" do
+    assert_equal "abc?", @transliterator.transliterate("abcſ")
+  end
+
+  test "can replace non-ASCII chars not in map with a custom replacement string" do
+    assert_equal "abc#", @transliterator.transliterate("abcſ", "#")
+  end
+
+  if RUBY_VERSION >= "1.9"
+    test "default transliterator raises errors for invalid UTF-8" do
+      assert_raise ArgumentError do
+        @transliterator.transliterate("a\x92b")
+      end
+    end
+  end
+
+  test "I18n.transliterate should transliterate using a default transliterator" do
+    assert_equal "aeo", I18n.transliterate("áèö")
+  end
+
+  test "I18n.transliterate should transliterate using a locale" do
+    store_translations(:xx, :i18n => {:transliterate => {:rule => @hash}})
+    assert_equal "ue", I18n.transliterate("ü", :locale => :xx)
+  end
+
+  test "default transliterator fails with custom rules with uncomposed input" do
+    char = [117, 776].pack("U*") # "ü" as ASCII "u" plus COMBINING DIAERESIS
+    transliterator = I18n::Backend::Transliterator.get(@hash)
+    assert_not_equal "ue", transliterator.transliterate(char)
+  end
+
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/hash_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/hash_test.rb
new file mode 100644
index 0000000..8405d49
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/hash_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+
+require 'test_helper'
+require 'i18n/core_ext/hash'
+
+class I18nCoreExtHashInterpolationTest < Test::Unit::TestCase
+  test "#deep_symbolize_keys" do
+    hash = { 'foo' => { 'bar' => { 'baz' => 'bar' } } }
+    expected = { :foo => { :bar => { :baz => 'bar' } } }
+    assert_equal expected, hash.deep_symbolize_keys
+  end
+
+  test "#slice" do
+    hash = { :foo => 'bar',  :baz => 'bar' }
+    expected = { :foo => 'bar' }
+    assert_equal expected, hash.slice(:foo)
+  end
+
+  test "#except" do
+    hash = { :foo => 'bar',  :baz => 'bar' }
+    expected = { :foo => 'bar' }
+    assert_equal expected, hash.except(:baz)
+  end
+
+  test "#deep_merge!" do
+    hash = { :foo => { :bar => { :baz => 'bar' } }, :baz => 'bar' }
+    hash.deep_merge!(:foo => { :bar => { :baz => 'foo' } })
+
+    expected = { :foo => { :bar => { :baz => 'foo' } }, :baz => 'bar' }
+    assert_equal expected, hash
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/string/interpolate_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/string/interpolate_test.rb
new file mode 100644
index 0000000..b648fdd
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/core_ext/string/interpolate_test.rb
@@ -0,0 +1,100 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../../')); $:.uniq!
+require 'test_helper'
+
+# thanks to Masao's String extensions these should work the same in
+# Ruby 1.8 (patched) and Ruby 1.9 (native)
+# some tests taken from Masao's tests
+# http://github.com/mutoh/gettext/blob/edbbe1fa8238fa12c7f26f2418403015f0270e47/test/test_string.rb
+
+class I18nCoreExtStringInterpolationTest < Test::Unit::TestCase
+  test "String interpolates a single argument" do
+    assert_equal "Masao", "%s" % "Masao"
+  end
+
+  test "String interpolates an array argument" do
+    assert_equal "1 message", "%d %s" % [1, 'message']
+  end
+
+  test "String interpolates a hash argument w/ named placeholders" do
+    assert_equal "Masao Mutoh", "%{first} %{last}" % { :first => 'Masao', :last => 'Mutoh' }
+  end
+
+  test "String interpolates a hash argument w/ named placeholders (reverse order)" do
+    assert_equal "Mutoh, Masao", "%{last}, %{first}" % { :first => 'Masao', :last => 'Mutoh' }
+  end
+
+  test "String interpolates named placeholders with sprintf syntax" do
+    assert_equal "10, 43.4", "%<integer>d, %<float>.1f" % {:integer => 10, :float => 43.4}
+  end
+
+  test "String interpolates named placeholders with sprintf syntax, does not recurse" do
+    assert_equal "%<not_translated>s", "%{msg}" % { :msg => '%<not_translated>s', :not_translated => 'should not happen' }
+  end
+
+  test "String interpolation does not replace anything when no placeholders are given" do
+    assert_equal("aaa", "aaa" % {:num => 1})
+    assert_equal("bbb", "bbb" % [1])
+  end
+
+  test "String interpolation sprintf behaviour equals Ruby 1.9 behaviour" do
+    assert_equal("1", "%<num>d" % {:num => 1})
+    assert_equal("0b1", "%<num>#b" % {:num => 1})
+    assert_equal("foo", "%<msg>s" % {:msg => "foo"})
+    assert_equal("1.000000", "%<num>f" % {:num => 1.0})
+    assert_equal("  1", "%<num>3.0f" % {:num => 1.0})
+    assert_equal("100.00", "%<num>2.2f" % {:num => 100.0})
+    assert_equal("0x64", "%<num>#x" % {:num => 100.0})
+    assert_raise(ArgumentError) { "%<num>,d" % {:num => 100} }
+    assert_raise(ArgumentError) { "%<num>/d" % {:num => 100} }
+  end
+
+  test "String interpolation old-style sprintf still works" do
+    assert_equal("foo 1.000000", "%s %f" % ["foo", 1.0])
+  end
+
+  test "String interpolation raises an ArgumentError when the string has extra placeholders (Array)" do
+    assert_raise(ArgumentError) do # Ruby 1.9 msg: "too few arguments"
+      "%s %s" % %w(Masao)
+    end
+  end
+
+  test "String interpolation raises a KeyError when the string has extra placeholders (Hash)" do
+    assert_raise(KeyError) do # Ruby 1.9 msg: "key not found"
+      "%{first} %{last}" % { :first => 'Masao' }
+    end
+  end
+
+  test "String interpolation does not raise when passed extra values (Array)" do
+    assert_nothing_raised do
+      assert_equal "Masao", "%s" % %w(Masao Mutoh)
+    end
+  end
+
+  test "String interpolation does not raise when passed extra values (Hash)" do
+    assert_nothing_raised do
+      assert_equal "Masao Mutoh", "%{first} %{last}" % { :first => 'Masao', :last => 'Mutoh', :salutation => 'Mr.' }
+    end
+  end
+
+  test "% acts as escape character in String interpolation" do
+    assert_equal "%{first}", "%%{first}" % { :first => 'Masao' }
+    assert_equal("% 1", "%% %<num>d" % {:num => 1.0})
+    assert_equal("%{num} %<num>d", "%%{num} %%<num>d" % {:num => 1})
+  end
+
+  test "% can be used in Ruby's own sprintf behavior" do
+    assert_equal "70%", "%d%%" % 70
+    assert_equal "70-100%", "%d-%d%%" % [70, 100]
+    assert_equal "+2.30%", "%+.2f%%" % 2.3
+  end
+
+  def test_sprintf_mix_unformatted_and_formatted_named_placeholders
+    assert_equal("foo 1.000000", "%{name} %<num>f" % {:name => "foo", :num => 1.0})
+  end
+
+  def test_string_interpolation_raises_an_argument_error_when_mixing_named_and_unnamed_placeholders
+    assert_raise(ArgumentError) { "%{name} %f" % [1.0] }
+    assert_raise(ArgumentError) { "%{name} %f" % [1.0, 2.0] }
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/api_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/api_test.rb
new file mode 100644
index 0000000..2c5f359
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/api_test.rb
@@ -0,0 +1,207 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+require 'i18n/gettext/helpers'
+
+include I18n::Gettext::Helpers
+
+class I18nGettextApiTest < Test::Unit::TestCase
+  def setup
+    I18n.locale = :en
+    I18n.backend.store_translations :de, {
+      'Hi Gettext!' => 'Hallo Gettext!',
+      'Sentence 1. Sentence 2.' => 'Satz 1. Satz 2.',
+      "An apple" => { :one => 'Ein Apfel', :other => '%{count} Äpfel' },
+      :special => { "A special apple" => { :one => 'Ein spezieller Apfel', :other => '%{count} spezielle Äpfel' } },
+      :foo => { :bar => 'bar-de' },
+      'foo.bar' => 'Foo Bar'
+    }, :separator => '|'
+  end
+
+  # gettext
+  def test_gettext_uses_msg_as_default
+    assert_equal 'Hi Gettext!', _('Hi Gettext!')
+  end
+
+  def test_gettext_uses_msg_as_key
+    I18n.locale = :de
+    assert_equal 'Hallo Gettext!', gettext('Hi Gettext!')
+    assert_equal 'Hallo Gettext!', _('Hi Gettext!')
+  end
+
+  def test_gettext_uses_msg_containing_dots_as_default
+    assert_equal 'Sentence 1. Sentence 2.', gettext('Sentence 1. Sentence 2.')
+    assert_equal 'Sentence 1. Sentence 2.', _('Sentence 1. Sentence 2.')
+  end
+
+  def test_gettext_uses_msg_containing_dots_as_key
+    I18n.locale = :de
+    assert_equal 'Satz 1. Satz 2.', gettext('Sentence 1. Sentence 2.')
+    assert_equal 'Satz 1. Satz 2.', _('Sentence 1. Sentence 2.')
+  end
+
+  # sgettext
+  def test_sgettext_defaults_to_the_last_token_of_a_scoped_msgid
+    assert_equal 'bar', sgettext('foo|bar')
+    assert_equal 'bar', s_('foo|bar')
+  end
+
+  def test_sgettext_looks_up_a_scoped_translation
+    I18n.locale = :de
+    assert_equal 'bar-de', sgettext('foo|bar')
+    assert_equal 'bar-de', s_('foo|bar')
+  end
+
+  def test_sgettext_ignores_dots
+    I18n.locale = :de
+    assert_equal 'Foo Bar', sgettext('foo.bar')
+    assert_equal 'Foo Bar', s_('foo.bar')
+  end
+
+  # pgettext
+  def test_pgettext_defaults_to_msgid
+    assert_equal 'bar', pgettext('foo', 'bar')
+    assert_equal 'bar', p_('foo', 'bar')
+  end
+
+  def test_pgettext_looks_up_a_scoped_translation
+    I18n.locale = :de
+    assert_equal 'bar-de', pgettext('foo', 'bar')
+    assert_equal 'bar-de', p_('foo', 'bar')
+  end
+
+  # ngettext
+  def test_ngettext_looks_up_msg_id_as_default_singular
+    assert_equal 'An apple', ngettext('An apple', '%{count} apples', 1)
+    assert_equal 'An apple', n_('An apple', '%{count} apples', 1)
+  end
+
+  def test_ngettext_looks_up_msg_id_plural_as_default_plural
+    assert_equal '2 apples', ngettext('An apple', '%{count} apples', 2)
+    assert_equal '2 apples', n_('An apple', '%{count} apples', 2)
+  end
+
+  def test_ngettext_looks_up_a_singular
+    I18n.locale = :de
+    assert_equal 'Ein Apfel', ngettext('An apple', '%{count} apples', 1)
+    assert_equal 'Ein Apfel', n_('An apple', '%{count} apples', 1)
+  end
+
+  def test_ngettext_looks_up_a_plural
+    I18n.locale = :de
+    assert_equal '2 Äpfel', ngettext('An apple', '%{count} apples', 2)
+    assert_equal '2 Äpfel', n_('An apple', '%{count} apples', 2)
+  end
+
+  def test_ngettext_looks_up_msg_id_as_default_singular_with_alternative_syntax
+    assert_equal 'An apple', ngettext(['An apple', '%{count} apples'], 1)
+    assert_equal 'An apple', n_(['An apple', '%{count} apples'], 1)
+  end
+
+  def test_ngettext_looks_up_msg_id_plural_as_default_plural_with_alternative_syntax
+    assert_equal '2 apples', ngettext(['An apple', '%{count} apples'], 2)
+    assert_equal '2 apples', n_(['An apple', '%{count} apples'], 2)
+  end
+
+  def test_ngettext_looks_up_a_singular_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Ein Apfel', ngettext(['An apple', '%{count} apples'], 1)
+    assert_equal 'Ein Apfel', n_(['An apple', '%{count} apples'], 1)
+  end
+
+  def test_ngettext_looks_up_a_plural_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal '2 Äpfel', ngettext(['An apple', '%{count} apples'], 2)
+    assert_equal '2 Äpfel', n_(['An apple', '%{count} apples'], 2)
+  end
+
+  # nsgettext
+  def test_nsgettext_looks_up_msg_id_as_default_singular
+    assert_equal 'A special apple', nsgettext('special|A special apple', '%{count} special apples', 1)
+    assert_equal 'A special apple', ns_('special|A special apple', '%{count} special apples', 1)
+  end
+
+  def test_nsgettext_looks_up_msg_id_plural_as_default_plural
+    assert_equal '2 special apples', nsgettext('special|A special apple', '%{count} special apples', 2)
+    assert_equal '2 special apples', ns_('special|A special apple', '%{count} special apples', 2)
+  end
+
+  def test_nsgettext_looks_up_a_singular
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', nsgettext('special|A special apple', '%{count} special apples', 1)
+    assert_equal 'Ein spezieller Apfel', ns_('special|A special apple', '%{count} special apples', 1)
+  end
+
+  def test_nsgettext_looks_up_a_plural
+    I18n.locale = :de
+    assert_equal '2 spezielle Äpfel', nsgettext('special|A special apple', '%{count} special apples', 2)
+    assert_equal '2 spezielle Äpfel', ns_('special|A special apple', '%{count} special apples', 2)
+  end
+
+  def test_nsgettext_looks_up_msg_id_as_default_singular_with_alternative_syntax
+    assert_equal 'A special apple', nsgettext(['special|A special apple', '%{count} special apples'], 1)
+    assert_equal 'A special apple', ns_(['special|A special apple', '%{count} special apples'], 1)
+  end
+
+  def test_nsgettext_looks_up_msg_id_plural_as_default_plural_with_alternative_syntax
+    assert_equal '2 special apples', nsgettext(['special|A special apple', '%{count} special apples'], 2)
+    assert_equal '2 special apples', ns_(['special|A special apple', '%{count} special apples'], 2)
+  end
+
+  def test_nsgettext_looks_up_a_singular_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', nsgettext(['special|A special apple', '%{count} special apples'], 1)
+    assert_equal 'Ein spezieller Apfel', ns_(['special|A special apple', '%{count} special apples'], 1)
+  end
+
+  def test_nsgettext_looks_up_a_plural_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal '2 spezielle Äpfel', nsgettext(['special|A special apple', '%{count} special apples'], 2)
+    assert_equal '2 spezielle Äpfel', ns_(['special|A special apple', '%{count} special apples'], 2)
+  end
+
+  # npgettext
+  def test_npgettext_looks_up_msg_id_as_default_singular
+    assert_equal 'A special apple', npgettext('special', 'A special apple', '%{count} special apples', 1)
+    assert_equal 'A special apple', np_('special', 'A special apple', '%{count} special apples', 1)
+  end
+
+  def test_npgettext_looks_up_msg_id_plural_as_default_plural
+    assert_equal '2 special apples', npgettext('special', 'A special apple', '%{count} special apples', 2)
+    assert_equal '2 special apples', np_('special', 'A special apple', '%{count} special apples', 2)
+  end
+
+  def test_npgettext_looks_up_a_singular
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', npgettext('special', 'A special apple', '%{count} special apples', 1)
+    assert_equal 'Ein spezieller Apfel', np_('special', 'A special apple', '%{count} special apples', 1)
+  end
+
+  def test_npgettext_looks_up_a_plural
+    I18n.locale = :de
+    assert_equal '2 spezielle Äpfel', npgettext('special', 'A special apple', '%{count} special apples', 2)
+    assert_equal '2 spezielle Äpfel', np_('special', 'A special apple', '%{count} special apples', 2)
+  end
+
+  def test_npgettext_looks_up_msg_id_as_default_singular_with_alternative_syntax
+    assert_equal 'A special apple', npgettext('special', ['A special apple', '%{count} special apples'], 1)
+    assert_equal 'A special apple', np_('special', ['A special apple', '%{count} special apples'], 1)
+  end
+
+  def test_npgettext_looks_up_msg_id_plural_as_default_plural_with_alternative_syntax
+    assert_equal '2 special apples', npgettext('special', ['A special apple', '%{count} special apples'], 2)
+    assert_equal '2 special apples', np_('special', ['A special apple', '%{count} special apples'], 2)
+  end
+
+  def test_npgettext_looks_up_a_singular_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', npgettext('special', ['A special apple', '%{count} special apples'], 1)
+    assert_equal 'Ein spezieller Apfel', np_('special', ['A special apple', '%{count} special apples'], 1)
+  end
+
+  def test_npgettext_looks_up_a_plural_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal '2 spezielle Äpfel', npgettext('special', ['A special apple', '%{count} special apples'], 2)
+    assert_equal '2 spezielle Äpfel', np_('special', ['A special apple', '%{count} special apples'], 2)
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/backend_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/backend_test.rb
new file mode 100644
index 0000000..06f83ff
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/gettext/backend_test.rb
@@ -0,0 +1,90 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+class I18nGettextBackendTest < Test::Unit::TestCase
+  include I18n::Gettext::Helpers
+
+  class Backend < I18n::Backend::Simple
+    include I18n::Backend::Gettext
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    I18n.locale = :en
+    I18n.load_path = ["#{locales_dir}/de.po"]
+    @old_separator, I18n.default_separator = I18n.default_separator, '|'
+  end
+
+  def teardown
+    I18n.load_path = nil
+    I18n.backend = nil
+    I18n.default_separator = @old_separator
+  end
+
+  def test_backend_loads_po_file
+    I18n.backend.send(:init_translations)
+    assert I18n.backend.send(:translations)[:de][:"Axis"]
+  end
+
+  def test_looks_up_a_translation
+    I18n.locale = :de
+    assert_equal 'Auto', gettext('car')
+  end
+
+  def test_uses_default_translation
+    assert_equal 'car', gettext('car')
+  end
+
+  def test_looks_up_a_namespaced_translation
+    I18n.locale = :de
+    assert_equal 'Räderzahl', sgettext('Car|Wheels count')
+    assert_equal 'Räderzahl', pgettext('Car', 'Wheels count')
+  end
+
+  def test_uses_namespaced_default_translation
+    assert_equal 'Wheels count', sgettext('Car|Wheels count')
+    assert_equal 'Wheels count', pgettext('Car', 'Wheels count')
+  end
+
+  def test_pluralizes_entry
+    I18n.locale = :de
+    assert_equal 'Achse', ngettext('Axis', 'Axis', 1)
+    assert_equal 'Achsen', ngettext('Axis', 'Axis', 2)
+  end
+
+  def test_pluralizes_default_entry
+    assert_equal 'Axis', ngettext('Axis', 'Axis', 1)
+    assert_equal 'Axis', ngettext('Axis', 'Axis', 2)
+  end
+
+  def test_pluralizes_namespaced_entry
+    I18n.locale = :de
+    assert_equal 'Rad',   nsgettext('Car|wheel', 'wheels', 1)
+    assert_equal 'Räder', nsgettext('Car|wheel', 'wheels', 2)
+    assert_equal 'Rad',   npgettext('Car', 'wheel', 'wheels', 1)
+    assert_equal 'Räder', npgettext('Car', 'wheel', 'wheels', 2)
+  end
+
+  def test_pluralizes_namespaced_default_entry
+    assert_equal 'wheel',  nsgettext('Car|wheel', 'wheels', 1)
+    assert_equal 'wheels', nsgettext('Car|wheel', 'wheels', 2)
+    assert_equal 'wheel',  npgettext('Car', 'wheel', 'wheels', 1)
+    assert_equal 'wheels', npgettext('Car', 'wheel', 'wheels', 2)
+  end
+
+  def test_pluralizes_namespaced_entry_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Rad',   nsgettext(['Car|wheel', 'wheels'], 1)
+    assert_equal 'Räder', nsgettext(['Car|wheel', 'wheels'], 2)
+    assert_equal 'Rad',   npgettext('Car', ['wheel', 'wheels'], 1)
+    assert_equal 'Räder', npgettext('Car', ['wheel', 'wheels'], 2)
+  end
+  
+  def test_ngettextpluralizes_entry_with_dots
+    I18n.locale = :de
+    assert_equal 'Auf 1 Achse.', n_("On %{count} wheel.", "On %{count} wheels.", 1)
+    assert_equal 'Auf 2 Achsen.', n_("On %{count} wheel.", "On %{count} wheels.", 2)
+  end
+  
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_exceptions_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_exceptions_test.rb
new file mode 100644
index 0000000..9afc56a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_exceptions_test.rb
@@ -0,0 +1,97 @@
+# encoding: utf-8
+$:.unshift File.expand_path(File.dirname(__FILE__) + '/')
+require 'test_helper'
+
+class I18nExceptionsTest < Test::Unit::TestCase
+  def test_invalid_locale_stores_locale
+    force_invalid_locale
+  rescue I18n::ArgumentError => e
+    assert_nil e.locale
+  end
+
+  def test_invalid_locale_message
+    force_invalid_locale
+  rescue I18n::ArgumentError => e
+    assert_equal 'nil is not a valid locale', e.message
+  end
+
+  def test_missing_translation_data_stores_locale_key_and_options
+    force_missing_translation_data
+  rescue I18n::ArgumentError => e
+    options = {:scope => :bar}
+    assert_equal 'de', e.locale
+    assert_equal :foo, e.key
+    assert_equal options, e.options
+  end
+
+  def test_missing_translation_data_message
+    force_missing_translation_data
+  rescue I18n::ArgumentError => e
+    assert_equal 'translation missing: de, bar, foo', e.message
+  end
+
+  def test_invalid_pluralization_data_stores_entry_and_count
+    force_invalid_pluralization_data
+  rescue I18n::ArgumentError => e
+    assert_equal [:bar], e.entry
+    assert_equal 1, e.count
+  end
+
+  def test_invalid_pluralization_data_message
+    force_invalid_pluralization_data
+  rescue I18n::ArgumentError => e
+    assert_equal 'translation data [:bar] can not be used with :count => 1', e.message
+  end
+
+  def test_missing_interpolation_argument_stores_key_and_string
+    assert_raise(I18n::MissingInterpolationArgument) { force_missing_interpolation_argument } 
+    force_missing_interpolation_argument
+  rescue I18n::ArgumentError => e
+    # assert_equal :bar, e.key
+    assert_equal "%{bar}", e.string
+  end
+
+  def test_missing_interpolation_argument_message
+    force_missing_interpolation_argument
+  rescue I18n::ArgumentError => e
+    assert_equal 'missing interpolation argument in "%{bar}" ({:baz=>"baz"} given)', e.message
+  end
+
+  def test_reserved_interpolation_key_stores_key_and_string
+    force_reserved_interpolation_key
+  rescue I18n::ArgumentError => e
+    assert_equal :scope, e.key
+    assert_equal "%{scope}", e.string
+  end
+
+  def test_reserved_interpolation_key_message
+    force_reserved_interpolation_key
+  rescue I18n::ArgumentError => e
+    assert_equal 'reserved key :scope used in "%{scope}"', e.message
+  end
+
+  private
+    def force_invalid_locale
+      I18n.backend.translate nil, :foo
+    end
+
+    def force_missing_translation_data
+      I18n.backend.store_translations 'de', :bar => nil
+      I18n.backend.translate 'de', :foo, :scope => :bar
+    end
+
+    def force_invalid_pluralization_data
+      I18n.backend.store_translations 'de', :foo => [:bar]
+      I18n.backend.translate 'de', :foo, :count => 1
+    end
+
+    def force_missing_interpolation_argument
+      I18n.backend.store_translations 'de', :foo => "%{bar}"
+      I18n.backend.translate 'de', :foo, :baz => 'baz'
+    end
+
+    def force_reserved_interpolation_key
+      I18n.backend.store_translations 'de', :foo => "%{scope}"
+      I18n.backend.translate 'de', :foo, :baz => 'baz'
+    end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_load_path_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_load_path_test.rb
new file mode 100644
index 0000000..fb8e3b9
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_load_path_test.rb
@@ -0,0 +1,23 @@
+# encoding: utf-8
+$:.unshift File.expand_path(File.dirname(__FILE__) + '/')
+require 'test_helper'
+
+class I18nLoadPathTest < Test::Unit::TestCase
+  # include Tests::Backend::Simple::Setup::Base
+  
+  def setup
+    I18n.locale = :en
+    I18n.backend = I18n::Backend::Simple.new
+    store_translations(:en, :foo => {:bar => 'bar', :baz => 'baz'})
+  end
+
+  def test_nested_load_paths_do_not_break_locale_loading
+    I18n.load_path = [[locales_dir + '/en.yml']]
+    assert_equal "baz", I18n.t(:'foo.bar')
+  end
+
+  def test_adding_arrays_of_filenames_to_load_path_do_not_break_locale_loading
+    I18n.load_path << Dir[locales_dir + '/*.{rb,yml}']
+    assert_equal "baz", I18n.t(:'foo.bar')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_test.rb
new file mode 100644
index 0000000..45de23d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/i18n_test.rb
@@ -0,0 +1,244 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__))); $:.uniq!
+require 'test_helper'
+
+class I18nTest < Test::Unit::TestCase
+  def setup
+    I18n.backend.store_translations :'en', {
+      :currency => {
+        :format => {
+          :separator => '.',
+          :delimiter => ',',
+        }
+      }
+    }
+  end
+
+  def test_uses_simple_backend_set_by_default
+    assert I18n.backend.is_a?(I18n::Backend::Simple)
+  end
+
+  def test_can_set_backend
+    assert_nothing_raised { I18n.backend = self }
+    assert_equal self, I18n.backend
+  ensure
+    I18n.backend = I18n::Backend::Simple.new
+  end
+
+  def test_uses_en_us_as_default_locale_by_default
+    assert_equal :en, I18n.default_locale
+  end
+
+  def test_can_set_default_locale
+    assert_nothing_raised { I18n.default_locale = 'de' }
+    assert_equal :de, I18n.default_locale
+  ensure
+    I18n.default_locale = :en
+  end
+
+  def test_uses_default_locale_as_locale_by_default
+    assert_equal I18n.default_locale, I18n.locale
+  end
+
+  def test_can_set_locale_to_thread_current
+    assert_nothing_raised { I18n.locale = 'de' }
+    assert_equal :de, I18n.locale
+    assert_equal :de, Thread.current[:i18n_config].locale
+    I18n.locale = :en
+  end
+
+  def test_can_set_i18n_config
+    I18n.config = self
+    assert_equal self, I18n.config
+    assert_equal self, Thread.current[:i18n_config]
+  ensure
+    I18n.config = ::I18n::Config.new
+  end
+
+  def test_locale_is_not_shared_between_configurations
+    a = I18n::Config.new
+    b = I18n::Config.new
+    a.locale = :fr
+    b.locale = :es
+    assert_equal :fr, a.locale
+    assert_equal :es, b.locale
+    assert_equal :en, I18n.locale
+  end
+
+  def test_other_options_are_shared_between_configurations
+    a = I18n::Config.new
+    b = I18n::Config.new
+    a.default_locale = :fr
+    b.default_locale = :es
+    assert_equal :es, a.default_locale
+    assert_equal :es, b.default_locale
+    assert_equal :es, I18n.default_locale
+  ensure
+    I18n.default_locale = :en
+  end
+
+  def test_defaults_to_dot_as_separator
+    assert_equal '.', I18n.default_separator
+  end
+
+  def test_can_set_default_separator
+    assert_nothing_raised { I18n.default_separator = "\001" }
+  ensure
+    I18n.default_separator = '.' # revert it
+  end
+
+  def test_normalize_keys
+    assert_equal [:en, :foo, :bar], I18n.normalize_keys(:en, :bar, :foo)
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, :'baz.buz', :'foo.bar')
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, 'baz.buz', 'foo.bar')
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, %w(baz buz), %w(foo bar))
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, [:baz, :buz], [:foo, :bar])
+  end
+
+  def test_normalize_keys_should_not_attempt_to_sym_on_empty_string
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, :'baz.buz', :'foo..bar')
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, :'baz.buz', :'foo......bar')
+  end
+
+  def test_uses_passed_separator_to_normalize_keys
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.normalize_keys(:en, :'baz|buz', :'foo|bar', '|')
+  end
+
+  def test_can_set_exception_handler
+    assert_nothing_raised { I18n.exception_handler = :custom_exception_handler }
+  ensure
+    I18n.exception_handler = :default_exception_handler
+  end
+
+  with_mocha do
+    def test_uses_custom_exception_handler
+      I18n.exception_handler = :custom_exception_handler
+      I18n.expects(:custom_exception_handler)
+      I18n.translate :bogus
+    ensure
+      I18n.exception_handler = :default_exception_handler # revert it
+    end
+
+    def test_delegates_translate_to_backend
+      I18n.backend.expects(:translate).with('de', :foo, {})
+      I18n.translate :foo, :locale => 'de'
+    end
+
+    def test_delegates_localize_to_backend
+      I18n.backend.expects(:localize).with('de', :whatever, :default, {})
+      I18n.localize :whatever, :locale => 'de'
+    end
+
+    def test_translate_given_no_locale_uses_i18n_locale
+      I18n.backend.expects(:translate).with(:en, :foo, {})
+      I18n.translate :foo
+    end
+  end
+
+  def test_translate_on_nested_symbol_keys_works
+    assert_equal ".", I18n.t(:'currency.format.separator')
+  end
+
+  def test_translate_with_nested_string_keys_works
+    assert_equal ".", I18n.t('currency.format.separator')
+  end
+
+  def test_translate_with_array_as_scope_works
+    assert_equal ".", I18n.t(:separator, :scope => %w(currency format))
+  end
+
+  def test_translate_with_array_containing_dot_separated_strings_as_scope_works
+    assert_equal ".", I18n.t(:separator, :scope => ['currency.format'])
+  end
+
+  def test_translate_with_key_array_and_dot_separated_scope_works
+    assert_equal [".", ","], I18n.t(%w(separator delimiter), :scope => 'currency.format')
+  end
+
+  def test_translate_with_dot_separated_key_array_and_scope_works
+    assert_equal [".", ","], I18n.t(%w(format.separator format.delimiter), :scope => 'currency')
+  end
+
+  # with_mocha do
+  #   def test_translate_with_options_using_scope_works
+  #     I18n.backend.expects(:translate).with('de', :precision, :scope => :"currency.format")
+  #     I18n.with_options :locale => 'de', :scope => :'currency.format' do |locale|
+  #       locale.t :precision
+  #     end
+  #   end
+  # end
+
+  # def test_translate_given_no_args_raises_missing_translation_data
+  #   assert_equal "translation missing: en, no key", I18n.t
+  # end
+
+  def test_translate_given_a_bogus_key_raises_missing_translation_data
+    assert_equal "translation missing: en, bogus", I18n.t(:bogus)
+  end
+
+  def test_localize_nil_raises_argument_error
+    assert_raise(I18n::ArgumentError) { I18n.l nil }
+  end
+
+  def test_localize_object_raises_argument_error
+    assert_raise(I18n::ArgumentError) { I18n.l Object.new }
+  end
+
+  def test_proc_exception_handler
+    I18n.exception_handler = Proc.new { |exception, locale, key, options|
+      "No exception here! [Proc handler]"
+    }
+    assert_equal "No exception here! [Proc handler]", I18n.translate(:test_proc_handler)
+  ensure
+    I18n.exception_handler = :default_exception_handler
+  end
+
+  def test_class_exception_handler
+    I18n.exception_handler = Class.new do
+      def call(exception, locale, key, options)
+        "No exception here! [Class handler]"
+      end
+    end.new
+    assert_equal "No exception here! [Class handler]", I18n.translate(:test_class_handler)
+  ensure
+    I18n.exception_handler = :default_exception_handler
+  end
+
+  test "I18n.with_locale" do
+    store_translations(:en, :foo => 'Foo in :en')
+    store_translations(:de, :foo => 'Foo in :de')
+    store_translations(:pl, :foo => 'Foo in :pl')
+
+    I18n.with_locale do
+      assert_equal I18n.default_locale, I18n.locale
+      assert_equal 'Foo in :en', I18n.t(:foo)
+    end
+
+    I18n.with_locale(:de) do
+      assert_equal :de, I18n.locale
+      assert_equal 'Foo in :de', I18n.t(:foo)
+    end
+
+    I18n.with_locale(:pl) do
+      assert_equal :pl, I18n.locale
+      assert_equal 'Foo in :pl', I18n.t(:foo)
+    end
+    
+    I18n.with_locale(:en) do
+      assert_equal :en, I18n.locale
+      assert_equal 'Foo in :en', I18n.t(:foo)
+    end
+
+    assert_equal I18n.default_locale, I18n.locale
+  end
+
+  test "whether I18n.with_locale reset the locale in case of errors" do
+    assert_raise(I18n::ArgumentError) do
+      I18n.with_locale(:pl) do
+        raise I18n::ArgumentError
+      end
+    end
+    assert_equal I18n.default_locale, I18n.locale
+  end
+
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/fallbacks_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/fallbacks_test.rb
new file mode 100644
index 0000000..6fadb0e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/fallbacks_test.rb
@@ -0,0 +1,126 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../')); $:.uniq!
+require 'test_helper'
+
+include I18n::Locale
+
+class I18nFallbacksDefaultsTest < Test::Unit::TestCase
+  def teardown
+    I18n.default_locale = :en
+  end
+
+  test "defaults reflect the I18n.default_locale if no default has been set manually" do
+    I18n.default_locale = :'en-US'
+    fallbacks = Fallbacks.new
+    assert_equal [:'en-US', :en], fallbacks.defaults
+  end
+
+  test "defaults reflect a manually passed default locale if any" do
+    fallbacks = Fallbacks.new(:'fi-FI')
+    assert_equal [:'fi-FI', :fi], fallbacks.defaults
+    I18n.default_locale = :'de-DE'
+    assert_equal [:'fi-FI', :fi], fallbacks.defaults
+  end
+
+  test "defaults allows to set multiple defaults" do
+    fallbacks = Fallbacks.new(:'fi-FI', :'se-FI')
+    assert_equal [:'fi-FI', :fi, :'se-FI', :se], fallbacks.defaults
+  end
+end
+
+class I18nFallbacksComputationTest < Test::Unit::TestCase
+  def setup
+    @fallbacks = Fallbacks.new(:'en-US')
+  end
+
+  test "with no mappings defined it returns [:es, :en-US] for :es" do
+    assert_equal [:es, :"en-US", :en], @fallbacks[:es]
+  end
+
+  test "with no mappings defined it returns [:es-ES, :es, :en-US] for :es-ES" do
+    assert_equal [:"es-ES", :es, :"en-US", :en], @fallbacks[:"es-ES"]
+  end
+
+  test "with no mappings defined it returns [:es-MX, :es, :en-US] for :es-MX" do
+    assert_equal [:"es-MX", :es, :"en-US", :en], @fallbacks[:"es-MX"]
+  end
+
+  test "with no mappings defined it returns [:es-Latn-ES, :es-Latn, :es, :en-US] for :es-Latn-ES" do
+    assert_equal [:"es-Latn-ES", :"es-Latn", :es, :"en-US", :en], @fallbacks[:'es-Latn-ES']
+  end
+
+  test "with no mappings defined it returns [:en, :en-US] for :en" do
+    assert_equal [:en, :"en-US"], @fallbacks[:en]
+  end
+
+  test "with no mappings defined it returns [:en-US, :en] for :en-US (special case: locale == default)" do
+    assert_equal [:"en-US", :en], @fallbacks[:"en-US"]
+  end
+
+  # Most people who speak Catalan also live in Spain, so it is safe to assume
+  # that they also speak Spanish as spoken in Spain.
+  test "with a Catalan mapping defined it returns [:ca, :es-ES, :es, :en-US] for :ca" do
+    @fallbacks.map(:ca => :"es-ES")
+    assert_equal [:ca, :"es-ES", :es, :"en-US", :en], @fallbacks[:ca]
+  end
+
+  test "with a Catalan mapping defined it returns [:ca-ES, :ca, :es-ES, :es, :en-US] for :ca-ES" do
+    @fallbacks.map(:ca => :"es-ES")
+    assert_equal [:"ca-ES", :ca, :"es-ES", :es, :"en-US", :en], @fallbacks[:"ca-ES"]
+  end
+
+  # People who speak Arabic as spoken in Palestine often times also speak
+  # Hebrew as spoken in Israel. However it is in no way safe to assume that
+  # everybody who speaks Arabic also speaks Hebrew.
+
+  test "with a Hebrew mapping defined it returns [:ar, :en-US] for :ar" do
+    @fallbacks.map(:"ar-PS" => :"he-IL")
+    assert_equal [:ar, :"en-US", :en], @fallbacks[:ar]
+  end
+
+  test "with a Hebrew mapping defined it returns [:ar-EG, :ar, :en-US] for :ar-EG" do
+    @fallbacks.map(:"ar-PS" => :"he-IL")
+    assert_equal [:"ar-EG", :ar, :"en-US", :en], @fallbacks[:"ar-EG"]
+  end
+
+  test "with a Hebrew mapping defined it returns [:ar-PS, :ar, :he-IL, :he, :en-US] for :ar-PS" do
+    @fallbacks.map(:"ar-PS" => :"he-IL")
+    assert_equal [:"ar-PS", :ar, :"he-IL", :he, :"en-US", :en], @fallbacks[:"ar-PS"]
+  end
+
+  # Sami people live in several scandinavian countries. In Finnland many people
+  # know Swedish and Finnish. Thus, it can be assumed that Sami living in
+  # Finnland also speak Swedish and Finnish.
+
+  test "with a Sami mapping defined it returns [:sms-FI, :sms, :se-FI, :se, :fi-FI, :fi, :en-US] for :sms-FI" do
+    @fallbacks.map(:sms => [:"se-FI", :"fi-FI"])
+    assert_equal [:"sms-FI", :sms, :"se-FI", :se, :"fi-FI", :fi, :"en-US", :en], @fallbacks[:"sms-FI"]
+  end
+
+  # Austrian people understand German as spoken in Germany
+
+  test "with a German mapping defined it returns [:de, :en-US] for de" do
+    @fallbacks.map(:"de-AT" => :"de-DE")
+    assert_equal [:de, :"en-US", :en], @fallbacks[:"de"]
+  end
+
+  test "with a German mapping defined it returns [:de-DE, :de, :en-US] for de-DE" do
+    @fallbacks.map(:"de-AT" => :"de-DE")
+    assert_equal [:"de-DE", :de, :"en-US", :en], @fallbacks[:"de-DE"]
+  end
+
+  test "with a German mapping defined it returns [:de-AT, :de, :de-DE, :en-US] for de-AT" do
+    @fallbacks.map(:"de-AT" => :"de-DE")
+    assert_equal [:"de-AT", :de, :"de-DE", :"en-US", :en], @fallbacks[:"de-AT"]
+  end
+
+  # Mapping :de => :en, :he => :en
+
+  test "with a mapping :de => :en, :he => :en defined it returns [:de, :en] for :de" do
+    assert_equal [:de, :"en-US", :en], @fallbacks[:de]
+  end
+
+  test "with a mapping :de => :en, :he => :en defined it [:he, :en] for :de" do
+    assert_equal [:he, :"en-US", :en], @fallbacks[:he]
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/rfc4646_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/rfc4646_test.rb
new file mode 100644
index 0000000..1abb7be
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/rfc4646_test.rb
@@ -0,0 +1,143 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../../')); $:.uniq!
+require 'test_helper'
+
+class I18nLocaleTagRfc4646ParserTest < Test::Unit::TestCase
+  include I18n::Locale
+
+  test "Rfc4646::Parser given a valid tag 'de' returns an array of subtags" do
+    assert_equal ['de', nil, nil, nil, nil, nil, nil], Tag::Rfc4646::Parser.match('de')
+  end
+
+  test "Rfc4646::Parser given a valid tag 'de-DE' returns an array of subtags" do
+    assert_equal ['de', nil, 'DE', nil, nil, nil, nil], Tag::Rfc4646::Parser.match('de-DE')
+  end
+
+  test "Rfc4646::Parser given a valid lowercase tag 'de-latn-de-variant-x-phonebk' returns an array of subtags" do
+    assert_equal ['de', 'latn', 'de', 'variant', nil, 'x-phonebk', nil], Tag::Rfc4646::Parser.match('de-latn-de-variant-x-phonebk')
+  end
+
+  test "Rfc4646::Parser given a valid uppercase tag 'DE-LATN-DE-VARIANT-X-PHONEBK' returns an array of subtags" do
+    assert_equal ['DE', 'LATN', 'DE', 'VARIANT', nil, 'X-PHONEBK', nil], Tag::Rfc4646::Parser.match('DE-LATN-DE-VARIANT-X-PHONEBK')
+  end
+
+  test "Rfc4646::Parser given an invalid tag 'a-DE' it returns false" do
+    assert_equal false, Tag::Rfc4646::Parser.match('a-DE')
+  end
+
+  test "Rfc4646::Parser given an invalid tag 'de-419-DE' it returns false" do
+    assert_equal false, Tag::Rfc4646::Parser.match('de-419-DE')
+  end
+end
+
+# Tag for the locale 'de-Latn-DE-Variant-a-ext-x-phonebk-i-klingon'
+
+class I18nLocaleTagSubtagsTest < Test::Unit::TestCase
+  include I18n::Locale
+
+  def setup
+    subtags = %w(de Latn DE variant a-ext x-phonebk i-klingon)
+    @tag = Tag::Rfc4646.new *subtags
+  end
+
+  test "returns 'de' as the language subtag in lowercase" do
+    assert_equal 'de', @tag.language
+  end
+
+  test "returns 'Latn' as the script subtag in titlecase" do
+    assert_equal 'Latn', @tag.script
+  end
+
+  test "returns 'DE' as the region subtag in uppercase" do
+    assert_equal 'DE', @tag.region
+  end
+
+  test "returns 'variant' as the variant subtag in lowercase" do
+    assert_equal 'variant', @tag.variant
+  end
+
+  test "returns 'a-ext' as the extension subtag" do
+    assert_equal 'a-ext', @tag.extension
+  end
+
+  test "returns 'x-phonebk' as the privateuse subtag" do
+    assert_equal 'x-phonebk', @tag.privateuse
+  end
+
+  test "returns 'i-klingon' as the grandfathered subtag" do
+    assert_equal 'i-klingon', @tag.grandfathered
+  end
+
+  test "returns a formatted tag string from #to_s" do
+    assert_equal 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon', @tag.to_s
+  end
+
+  test "returns an array containing the formatted subtags from #to_a" do
+    assert_equal %w(de Latn DE variant a-ext x-phonebk i-klingon), @tag.to_a
+  end
+end
+
+# Tag inheritance
+
+class I18nLocaleTagSubtagsTest < Test::Unit::TestCase
+  test "#parent returns 'de-Latn-DE-variant-a-ext-x-phonebk' as the parent of 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk i-klingon)
+    assert_equal 'de-Latn-DE-variant-a-ext-x-phonebk', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn-DE-variant-a-ext' as the parent of 'de-Latn-DE-variant-a-ext-x-phonebk'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk)
+    assert_equal 'de-Latn-DE-variant-a-ext', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn-DE-variant' as the parent of 'de-Latn-DE-variant-a-ext'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext)
+    assert_equal 'de-Latn-DE-variant', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn-DE' as the parent of 'de-Latn-DE-variant'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant)
+    assert_equal 'de-Latn-DE', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn' as the parent of 'de-Latn-DE'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE)
+    assert_equal 'de-Latn', tag.parent.to_s
+  end
+
+  test "#parent returns 'de' as the parent of 'de-Latn'" do
+    tag = Tag::Rfc4646.new *%w(de Latn)
+    assert_equal 'de', tag.parent.to_s
+  end
+
+  # TODO RFC4647 says: "If no language tag matches the request, the "default" value is returned."
+  # where should we set the default language?
+  # test "#parent returns '' as the parent of 'de'" do
+  #   tag = Tag::Rfc4646.new *%w(de)
+  #   assert_equal '', tag.parent.to_s
+  # end
+
+  test "#parent returns an array of 5 parents for 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon'" do
+    parents = %w(de-Latn-DE-variant-a-ext-x-phonebk-i-klingon
+                 de-Latn-DE-variant-a-ext-x-phonebk
+                 de-Latn-DE-variant-a-ext
+                 de-Latn-DE-variant
+                 de-Latn-DE
+                 de-Latn
+                 de)
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk i-klingon)
+    assert_equal parents, tag.self_and_parents.map{|tag| tag.to_s}
+  end
+
+  test "returns an array of 5 parents for 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon'" do
+    parents = %w(de-Latn-DE-variant-a-ext-x-phonebk-i-klingon
+                 de-Latn-DE-variant-a-ext-x-phonebk
+                 de-Latn-DE-variant-a-ext
+                 de-Latn-DE-variant
+                 de-Latn-DE
+                 de-Latn
+                 de)
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk i-klingon)
+    assert_equal parents, tag.self_and_parents.map{|tag| tag.to_s}
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/simple_test.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/simple_test.rb
new file mode 100644
index 0000000..66f4663
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/locale/tag/simple_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../../')); $:.uniq!
+require 'test_helper'
+
+class I18nLocaleTagSimpleTest < Test::Unit::TestCase
+  include I18n::Locale
+
+  test "returns 'de' as the language subtag in lowercase" do
+    assert_equal %w(de Latn DE), Tag::Simple.new('de-Latn-DE').subtags
+  end
+
+  test "returns a formatted tag string from #to_s" do
+    assert_equal 'de-Latn-DE', Tag::Simple.new('de-Latn-DE').to_s
+  end
+
+  test "returns an array containing the formatted subtags from #to_a" do
+    assert_equal %w(de Latn DE), Tag::Simple.new('de-Latn-DE').to_a
+  end
+
+  # Tag inheritance
+
+  test "#parent returns 'de-Latn' as the parent of 'de-Latn-DE'" do
+    assert_equal 'de-Latn', Tag::Simple.new('de-Latn-DE').parent.to_s
+  end
+
+  test "#parent returns 'de' as the parent of 'de-Latn'" do
+    assert_equal 'de', Tag::Simple.new('de-Latn').parent.to_s
+  end
+
+  test "#self_and_parents returns an array of 3 tags for 'de-Latn-DE'" do
+    assert_equal %w(de-Latn-DE de-Latn de), Tag::Simple.new('de-Latn-DE').self_and_parents.map { |tag| tag.to_s}
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/calendars.yml b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/calendars.yml
new file mode 100644
index 0000000..7ec740b
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/calendars.yml
@@ -0,0 +1,152 @@
+de: 
+  calendars: 
+    gregorian: 
+      days: 
+        format: 
+          abbreviated: 
+            fri: Fr.
+            mon: Mo.
+            sat: Sa.
+            sun: So.
+            thu: Do.
+            tue: Di.
+            wed: Mi.
+          narrow: :"calendars.gregorian.days.stand-alone.narrow"
+          wide: 
+            fri: Freitag
+            mon: Montag
+            sat: Samstag
+            sun: Sonntag
+            thu: Donnerstag
+            tue: Dienstag
+            wed: Mittwoch
+        stand-alone: 
+          abbreviated: :"calendars.gregorian.days.format.abbreviated"
+          narrow: 
+            fri: F
+            mon: M
+            sat: S
+            sun: S
+            thu: D
+            tue: D
+            wed: M
+          wide: :"calendars.gregorian.days.format.wide"
+      fields: 
+        day: Tag
+        dayperiod: Tageshälfte
+        era: Epoche
+        hour: Stunde
+        minute: Minute
+        month: Monat
+        second: Sekunde
+        week: Woche
+        weekday: Wochentag
+        year: Jahr
+        zone: Zone
+      formats: 
+        date: 
+          default: :"calendars.gregorian.formats.date.medium"
+          full: 
+            pattern: "EEEE, d. MMMM y"
+          long: 
+            pattern: "d. MMMM y"
+          medium: 
+            pattern: dd.MM.yyyy
+          short: 
+            pattern: dd.MM.yy
+        datetime: 
+          default: :"calendars.gregorian.formats.datetime.medium"
+          full: 
+            pattern: "%{date} %{time}"
+          long: 
+            pattern: "%{date} %{time}"
+          medium: 
+            pattern: "%{date} %{time}"
+          short: 
+            pattern: "%{date} %{time}"
+        time: 
+          default: :"calendars.gregorian.formats.time.medium"
+          full: 
+            pattern: "HH:mm:ss zzzz"
+          long: 
+            pattern: "HH:mm:ss z"
+          medium: 
+            pattern: "HH:mm:ss"
+          short: 
+            pattern: "HH:mm"
+      months: 
+        format: 
+          abbreviated: 
+            1: Jan
+            10: Okt
+            11: Nov
+            12: Dez
+            2: Feb
+            3: Mär
+            4: Apr
+            5: Mai
+            6: Jun
+            7: Jul
+            8: Aug
+            9: Sep
+          narrow: :"calendars.gregorian.months.stand-alone.narrow"
+          wide: 
+            1: Januar
+            10: Oktober
+            11: November
+            12: Dezember
+            2: Februar
+            3: März
+            4: April
+            5: Mai
+            6: Juni
+            7: Juli
+            8: August
+            9: September
+        stand-alone: 
+          abbreviated: 
+            10: Okt
+            11: Nov
+            12: Dez
+            3: Mär
+            7: Jul
+            8: Aug
+            9: Sep
+          narrow: 
+            1: J
+            10: O
+            11: N
+            12: D
+            2: F
+            3: M
+            4: A
+            5: M
+            6: J
+            7: J
+            8: A
+            9: S
+          wide: :"calendars.gregorian.months.format.wide"
+      periods: 
+        am: vorm.
+        pm: nachm.
+      quarters: 
+        format: 
+          abbreviated: 
+            1: Q1
+            2: Q2
+            3: Q3
+            4: Q4
+          narrow: :"calendars.gregorian.quarters.stand-alone.narrow"
+          wide: 
+            1: "1. Quartal"
+            2: "2. Quartal"
+            3: "3. Quartal"
+            4: "4. Quartal"
+        stand-alone: 
+          abbreviated: :"calendars.gregorian.quarters.format.abbreviated"
+          narrow: 
+            1: 1
+            2: 2
+            3: 3
+            4: 4
+          wide: :"calendars.gregorian.quarters.format.wide"
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/currencies.yml b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/currencies.yml
new file mode 100644
index 0000000..40f477d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/currencies.yml
@@ -0,0 +1,8 @@
+de: 
+  currencies: 
+    EUR: 
+      one: Euro
+      other: Euro
+    IEP: 
+      one: "Irisches Pfund"
+      other: "Irische Pfund"
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/numbers.yml b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/numbers.yml
new file mode 100644
index 0000000..fac4d6c
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/cldr/de/numbers.yml
@@ -0,0 +1,31 @@
+de: 
+  numbers: 
+    formats: 
+      currency: 
+        patterns: 
+          default: "#,##0.00 ¤"
+        unit: 
+          one: "{0} {1}"
+          other: "{0} {1}"
+      decimal: 
+        patterns: 
+          default: "#,##0.###"
+      percent: 
+        patterns: 
+          default: "#,##0 %"
+      scientific: 
+        patterns: 
+          default: "#E0"
+    symbols: 
+      decimal: ","
+      exponential: E
+      group: "."
+      infinity: ∞
+      list: ;
+      minus_sign: "-"
+      nan: NaN
+      native_zero_digit: 0
+      pattern_digit: "#"
+      per_mille: ‰
+      percent_sign: "%"
+      plus_sign: +
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/de.po b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/de.po
new file mode 100644
index 0000000..c162e87
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/de.po
@@ -0,0 +1,72 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: version 0.0.1\n"
+"POT-Creation-Date: 2009-02-26 19:50+0100\n"
+"PO-Revision-Date: 2009-02-18 14:53+0100\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
+
+# #: app/helpers/translation_helper.rb:3
+# msgid "%{relative_time} ago"
+# msgstr "vor %{relative_time}"
+
+#: app/views/cars/show.html.erb:5
+msgid "Axis"
+msgid_plural "Axis"
+msgstr[0] "Achse"
+msgstr[1] "Achsen"
+
+#: app/controllers/cars_controller.rb:47
+msgid "Car was successfully created."
+msgstr "Auto wurde erfolgreich gespeichert"
+
+#: app/controllers/cars_controller.rb:64
+msgid "Car was successfully updated."
+msgstr "Auto wurde erfolgreich aktualisiert"
+
+#: app/views/cars/show.html.erb:1 locale/model_attributes.rb:3
+msgid "Car|Model"
+msgstr "Modell"
+
+#: app/views/cars/show.html.erb:3 locale/model_attributes.rb:4
+msgid "Car|Wheels count"
+msgstr "Räderzahl"
+
+#: app/views/cars/show.html.erb:7
+msgid "Created"
+msgstr "Erstellt"
+
+#: app/views/cars/show.html.erb:9
+msgid "Month"
+msgstr "Monat"
+
+#: locale/model_attributes.rb:2
+msgid "car"
+msgstr "Auto"
+
+#: locale/testlog_phrases.rb:2
+msgid "this is a dynamic translation which was found thorugh gettext_test_log!"
+msgstr ""
+"Dies ist eine dynamische Übersetzung, die durch gettext_test_log "
+"gefunden wurde!"
+
+#: app/views/cars/nowhere_really
+msgid "Car|wheel"
+msgid_plural "Car|wheels"
+msgstr[0] "Rad"
+msgstr[1] "Räder"
+
+msgid "On %{count} wheel."
+msgid_plural "On %{count} wheels."
+msgstr[0] "Auf %{count} Achse."
+msgstr[1] "Auf %{count} Achsen."
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.rb
new file mode 100644
index 0000000..e847d10
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.rb
@@ -0,0 +1,3 @@
+# encoding: utf-8
+
+{ :en => { :fuh => { :bah => "bas" } } }
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.yml b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.yml
new file mode 100644
index 0000000..25f5bb6
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/en.yml
@@ -0,0 +1,3 @@
+en:
+  foo:
+    bar: baz
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/plurals.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/plurals.rb
new file mode 100644
index 0000000..d1ea34e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_data/locales/plurals.rb
@@ -0,0 +1,113 @@
+# encoding: utf-8
+
+{
+  :af => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :am => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :ar => { :i18n => { :plural => { :keys => [:zero, :one, :two, :few, :many, :other], :rule => lambda { |n| n == 0 ? :zero : n == 1 ? :one : n == 2 ? :two : [3, 4, 5, 6, 7, 8, 9, 10].include?(n % 100) ? :few : [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99].include?(n % 100) ? :many : :other } } } },
+  :az => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :be => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :bg => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :bh => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :bn => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :bo => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :bs => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :ca => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :cs => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : [2, 3, 4].include?(n) ? :few : :other } } } },
+  :cy => { :i18n => { :plural => { :keys => [:one, :two, :many, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : n == 8 || n == 11 ? :many : :other } } } },
+  :da => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :de => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :dz => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :el => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :en => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :eo => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :es => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :et => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :eu => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fa => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :fi => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fil => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :fo => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fr => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n && n != 2 ? :one : :other } } } },
+  :fur => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fy => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ga => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :gl => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :gu => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :guw => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :ha => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :he => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :hi => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :hr => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :hu => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :id => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :is => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :it => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :iw => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ja => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :jv => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ka => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :km => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :kn => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ko => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ku => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :lb => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ln => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :lt => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n % 10 == 1 && ![11, 12, 13, 14, 15, 16, 17, 18, 19].include?(n % 100) ? :one : [2, 3, 4, 5, 6, 7, 8, 9].include?(n % 10) && ![11, 12, 13, 14, 15, 16, 17, 18, 19].include?(n % 100) ? :few : :other } } } },
+  :lv => { :i18n => { :plural => { :keys => [:zero, :one, :other], :rule => lambda { |n| n == 0 ? :zero : n % 10 == 1 && n % 100 != 11 ? :one : :other } } } },
+  :mg => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :mk => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n % 10 == 1 ? :one : :other } } } },
+  :ml => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :mn => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :mo => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : n == 0 ? :few : :other } } } },
+  :mr => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ms => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :mt => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n == 1 ? :one : n == 0 || [2, 3, 4, 5, 6, 7, 8, 9, 10].include?(n % 100) ? :few : [11, 12, 13, 14, 15, 16, 17, 18, 19].include?(n % 100) ? :many : :other } } } },
+  :my => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :nah => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nb => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ne => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nl => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nn => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :no => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nso => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :om => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :or => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pa => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pap => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pl => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) && ![22, 23, 24].include?(n % 100) ? :few : :other } } } },
+  :ps => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pt => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :"pt-PT" => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ro => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : n == 0 ? :few : :other } } } },
+  :ru => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :se => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :sh => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :sk => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : [2, 3, 4].include?(n) ? :few : :other } } } },
+  :sl => { :i18n => { :plural => { :keys => [:one, :two, :few, :other], :rule => lambda { |n| n % 100 == 1 ? :one : n % 100 == 2 ? :two : [3, 4].include?(n % 100) ? :few : :other } } } },
+  :sma => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :smi => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :smj => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :smn => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :sms => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :so => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :sq => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :sr => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :sv => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :sw => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ta => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :te => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :th => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ti => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :tk => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :tl => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :to => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :tr => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :uk => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :ur => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :vi => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :wa => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :yo => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :zh => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :zu => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } }
+}
+
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_helper.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_helper.rb
new file mode 100644
index 0000000..098020e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_helper.rb
@@ -0,0 +1,85 @@
+# encoding: utf-8
+$KCODE = 'u' unless RUBY_VERSION >= '1.9'
+
+$:.unshift File.expand_path("../lib", File.dirname(__FILE__))
+$:.unshift File.expand_path(File.dirname(__FILE__))
+$:.uniq!
+
+require 'rubygems'
+require 'test/unit'
+require 'time'
+require 'yaml'
+
+require 'i18n'
+require 'test_setup_requirements'
+
+setup_mocha
+
+class Test::Unit::TestCase
+  def self.test(name, &block)
+    test_name = "test_#{name.gsub(/\s+/,'_')}".to_sym
+    defined = instance_method(test_name) rescue false
+    raise "#{test_name} is already defined in #{self}" if defined
+    if block_given?
+      define_method(test_name, &block)
+    else
+      define_method(test_name) do
+        flunk "No implementation provided for #{name}"
+      end
+    end
+  end
+
+  def self.with_mocha
+    yield if Object.respond_to?(:expects)
+  end
+
+  def teardown
+    I18n.locale = nil
+    I18n.default_locale = :en
+    I18n.load_path = []
+    I18n.available_locales = nil
+    I18n.backend = nil
+  end
+
+  def translations
+    I18n.backend.instance_variable_get(:@translations)
+  end
+
+  def store_translations(*args)
+    data   = args.pop
+    locale = args.pop || :en
+    I18n.backend.store_translations(locale, data)
+  end
+
+  def locales_dir
+    File.dirname(__FILE__) + '/test_data/locales'
+  end
+
+  def euc_jp(string)
+    string.encode!(Encoding::EUC_JP)
+  end
+
+  def can_store_procs?
+    I18n.backend.class != I18n::Backend::ActiveRecord or
+    I18n::Backend::ActiveRecord.included_modules.include?(I18n::Backend::ActiveRecord::StoreProcs)
+  end
+
+  def capture(stream)
+    begin
+      stream = stream.to_s
+      eval "$#{stream} = StringIO.new"
+      yield
+      result = eval("$#{stream}").string
+    ensure 
+      eval("$#{stream} = #{stream.upcase}")
+    end
+
+    result
+  end
+end
+
+Object.class_eval do
+  def meta_class
+    class << self; self; end
+  end
+end unless Object.method_defined?(:meta_class)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_setup_requirements.rb b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_setup_requirements.rb
new file mode 100644
index 0000000..0bcc55d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.4.1/test/test_setup_requirements.rb
@@ -0,0 +1,71 @@
+require 'optparse'
+
+options = { :with => [] }
+OptionParser.new do |o|
+   o.on('-w', '--with DEPENDENCIES', 'Define dependencies') do |dep|
+     options[:with] = dep.split(',').map { |group| group.to_sym }
+   end
+end.parse!
+
+options[:with].each do |dep|
+  case dep
+  when :ar23, :'activerecord-2.3'
+    gem 'activerecord', '~> 2.3'
+  when :ar3, :'activerecord-3'
+    gem 'activerecord', '~> 3'
+  end
+end
+
+# Do not load the i18n gem from libraries like active_support, we'll load it from here :)
+alias :gem_for_ruby_19 :gem # for 1.9. gives a super ugly seg fault otherwise
+def gem(gem_name, *version_requirements)
+  if gem_name =='i18n'
+    puts "skipping loading the i18n gem ..."
+    return
+  end
+  super(gem_name, *version_requirements)
+end
+
+def setup_mocha
+  begin
+    require 'mocha'
+  rescue LoadError
+    puts "skipping tests using mocha as mocha can't be found"
+  end
+end
+
+def setup_active_record
+  begin
+    require 'active_record'
+    ActiveRecord::Base.connection
+    true
+  rescue LoadError => e
+    puts "can't use ActiveRecord backend because: #{e.message}"
+  rescue ActiveRecord::ConnectionNotEstablished
+    require 'i18n/backend/active_record'
+    require 'i18n/backend/active_record/store_procs'
+    connect_active_record
+    true
+  end
+end
+
+def connect_active_record
+  ActiveRecord::Base.establish_connection(:adapter => "sqlite3", :database => ":memory:")
+  ActiveRecord::Migration.verbose = false
+  ActiveRecord::Schema.define(:version => 1) do
+    create_table :translations do |t|
+      t.string :locale
+      t.string :key
+      t.string :value
+      t.string :interpolations
+      t.boolean :is_proc, :default => false
+    end
+  end
+end
+
+def setup_rufus_tokyo
+  require 'rubygems'
+  require 'rufus/tokyo'
+rescue LoadError => e
+  puts "can't use KeyValue backend because: #{e.message}"
+end
\ No newline at end of file
-- 
1.7.0.4

