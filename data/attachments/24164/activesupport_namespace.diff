From 0b654e69ee114729146d6ffc77664158531d330c Mon Sep 17 00:00:00 2001
From: Joshua Peek <josh@joshpeek.com>
Date: Thu, 22 May 2008 09:19:01 -0500
Subject: [PATCH] Namespace Inflector, Dependencies, OrderedOptions, and TimeZone under ActiveSupport

---
 actionpack/lib/action_controller/dispatcher.rb     |    2 +-
 actionpack/lib/action_controller/routing.rb        |    2 +-
 actionpack/test/controller/dispatcher_test.rb      |    4 +-
 .../test/controller/integration_upload_test.rb     |    2 +-
 actionpack/test/controller/routing_test.rb         |  502 +++++++-------
 activerecord/lib/active_record/base.rb             |    2 +-
 activerecord/test/cases/attribute_methods_test.rb  |   14 +-
 activerecord/test/cases/base_test.rb               |    6 +-
 activerecord/test/cases/inheritance_test.rb        |    4 +-
 activerecord/test/cases/multiple_db_test.rb        |    2 +-
 activesupport/lib/active_support.rb                |    4 +
 activesupport/lib/active_support/dependencies.rb   |  784 ++++++++++----------
 activesupport/lib/active_support/deprecation.rb    |   32 +-
 activesupport/lib/active_support/inflections.rb    |  100 ++--
 activesupport/lib/active_support/inflector.rb      |  532 +++++++-------
 .../lib/active_support/ordered_options.rb          |   26 +-
 .../lib/active_support/values/time_zone.rb         |  732 +++++++++---------
 activesupport/test/core_ext/date_ext_test.rb       |   12 +-
 activesupport/test/core_ext/date_time_ext_test.rb  |   24 +-
 activesupport/test/core_ext/duration_test.rb       |    8 +-
 activesupport/test/core_ext/time_ext_test.rb       |   28 +-
 activesupport/test/core_ext/time_with_zone_test.rb |  241 +++---
 activesupport/test/dependencies_test.rb            |  250 ++++----
 activesupport/test/deprecation_test.rb             |   10 +
 activesupport/test/inflector_test.rb               |  118 ++--
 activesupport/test/ordered_options_test.rb         |    6 +-
 activesupport/test/time_zone_test.rb               |   47 +-
 27 files changed, 1767 insertions(+), 1727 deletions(-)

diff --git a/actionpack/lib/action_controller/dispatcher.rb b/actionpack/lib/action_controller/dispatcher.rb
index 6e1e7a2..4389b29 100644
--- a/actionpack/lib/action_controller/dispatcher.rb
+++ b/actionpack/lib/action_controller/dispatcher.rb
@@ -135,7 +135,7 @@ module ActionController
     # be reloaded on the next request without restarting the server.
     def cleanup_application
       ActiveRecord::Base.reset_subclasses if defined?(ActiveRecord)
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
       ActiveRecord::Base.clear_reloadable_connections! if defined?(ActiveRecord)
     end
 
diff --git a/actionpack/lib/action_controller/routing.rb b/actionpack/lib/action_controller/routing.rb
index 6aa2665..8846dcc 100644
--- a/actionpack/lib/action_controller/routing.rb
+++ b/actionpack/lib/action_controller/routing.rb
@@ -369,7 +369,7 @@ module ActionController
 
     Routes = RouteSet.new
 
-    ::Inflector.module_eval do
+    ActiveSupport::Inflector.module_eval do
 	  # Ensures that routes are reloaded when Rails inflections are updated.
       def inflections_with_route_reloading(&block)
         returning(inflections_without_route_reloading(&block)) {
diff --git a/actionpack/test/controller/dispatcher_test.rb b/actionpack/test/controller/dispatcher_test.rb
index eea0813..911fcab 100644
--- a/actionpack/test/controller/dispatcher_test.rb
+++ b/actionpack/test/controller/dispatcher_test.rb
@@ -27,14 +27,14 @@ class DispatcherTest < Test::Unit::TestCase
 
   def test_clears_dependencies_after_dispatch_if_in_loading_mode
     ActionController::Routing::Routes.expects(:reload).once
-    Dependencies.expects(:clear).once
+    ActiveSupport::Dependencies.expects(:clear).once
 
     dispatch(@output, false)
   end
 
   def test_leaves_dependencies_after_dispatch_if_not_in_loading_mode
     ActionController::Routing::Routes.expects(:reload).never
-    Dependencies.expects(:clear).never
+    ActiveSupport::Dependencies.expects(:clear).never
 
     dispatch
   end
diff --git a/actionpack/test/controller/integration_upload_test.rb b/actionpack/test/controller/integration_upload_test.rb
index 33df113..4af9b7e 100644
--- a/actionpack/test/controller/integration_upload_test.rb
+++ b/actionpack/test/controller/integration_upload_test.rb
@@ -28,7 +28,7 @@ class SessionUploadTest < ActionController::IntegrationTest
   # end
   def test_post_with_upload
     uses_mocha "test_post_with_upload" do
-      Dependencies.stubs(:load?).returns(false)
+      ActiveSupport::Dependencies.stubs(:load?).returns(false)
       with_routing do |set|
         set.draw do |map|
           map.update 'update', :controller => "upload_test", :action => "update", :method => :post
diff --git a/actionpack/test/controller/routing_test.rb b/actionpack/test/controller/routing_test.rb
index 5e5503f..e7e7933 100644
--- a/actionpack/test/controller/routing_test.rb
+++ b/actionpack/test/controller/routing_test.rb
@@ -75,23 +75,23 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert_equal({:controller => "content", :action => 'index'}, rs.recognize_path("/content"))
     assert_equal({:controller => "content", :action => 'list'}, rs.recognize_path("/content/list"))
     assert_equal({:controller => "content", :action => 'show', :id => '10'}, rs.recognize_path("/content/show/10"))
-    
+
     assert_equal({:controller => "admin/user", :action => 'show', :id => '10'}, rs.recognize_path("/admin/user/show/10"))
-    
+
     assert_equal '/admin/user/show/10', rs.generate(:controller => 'admin/user', :action => 'show', :id => 10)
-    
+
     assert_equal '/admin/user/show', rs.generate({:action => 'show'}, {:controller => 'admin/user', :action => 'list', :id => '10'})
     assert_equal '/admin/user/list/10', rs.generate({}, {:controller => 'admin/user', :action => 'list', :id => '10'})
 
     assert_equal '/admin/stuff', rs.generate({:controller => 'stuff'}, {:controller => 'admin/user', :action => 'list', :id => '10'})
     assert_equal '/stuff', rs.generate({:controller => '/stuff'}, {:controller => 'admin/user', :action => 'list', :id => '10'})
   end
-  
+
   def test_ignores_leading_slash
     @rs.draw {|m| m.connect '/:controller/:action/:id'}
     test_default_setup
   end
-  
+
   def test_time_recognition
     # We create many routes to make situation more realistic
     @rs = ::ActionController::Routing::RouteSet.new
@@ -145,7 +145,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       GC.start
       pairs = [
         [{:controller => 'content', :action => 'index'}, {:controller => 'content', :action => 'show'}],
-        [{:controller => 'content'}, {:controller => 'content', :action => 'index'}],   
+        [{:controller => 'content'}, {:controller => 'content', :action => 'index'}],
         [{:controller => 'content', :action => 'list'}, {:controller => 'content', :action => 'index'}],
         [{:controller => 'content', :action => 'show', :id => '10'}, {:controller => 'content', :action => 'list'}],
         [{:controller => 'admin/user', :action => 'index'}, {:controller => 'admin/user', :action => 'show'}],
@@ -159,7 +159,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
         pairs.each {|(a, b)| rs.generate(a, b)}
         end
       end
-      
+
       puts "\n\nGeneration (RouteSet): (#{(n * 8)} urls)"
       per_url = gentime / (n * 8)
       puts "#{per_url * 1000} ms/url"
@@ -209,16 +209,16 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       {:controller => "user", :action => "download", :file => "file.jpg"},
       rs.recognize_path("/user/download/file.jpg"))
   end
-  
+
   def test_basic_named_route
-    rs.add_named_route :home, '', :controller => 'content', :action => 'list' 
+    rs.add_named_route :home, '', :controller => 'content', :action => 'list'
     x = setup_for_named_route
     assert_equal("http://named.route.test/",
                  x.send(:home_url))
   end
 
   def test_basic_named_route_with_relative_url_root
-    rs.add_named_route :home, '', :controller => 'content', :action => 'list' 
+    rs.add_named_route :home, '', :controller => 'content', :action => 'list'
     x = setup_for_named_route
     x.relative_url_root="/foo"
     assert_equal("http://named.route.test/foo/",
@@ -247,7 +247,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert_equal("http://named.route.test/admin/user",
                  x.send(:users_url))
   end
-  
+
   uses_mocha "named route optimisation" do
     def test_optimised_named_route_call_never_uses_url_for
       rs.add_named_route :users, 'admin/user', :controller => '/admin/user', :action => 'index'
@@ -259,13 +259,13 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       x.send(:user_url, 2, :foo=>"bar")
       x.send(:user_path, 3, :bar=>"foo")
     end
-    
-    def test_optimised_named_route_with_host 
-     	rs.add_named_route :pages, 'pages', :controller => 'content', :action => 'show_page', :host => 'foo.com' 
-     	x = setup_for_named_route 
+
+    def test_optimised_named_route_with_host
+     	rs.add_named_route :pages, 'pages', :controller => 'content', :action => 'show_page', :host => 'foo.com'
+     	x = setup_for_named_route
      	x.expects(:url_for).with(:host => 'foo.com', :only_path => false, :controller => 'content', :action => 'show_page', :use_route => :pages).once
       x.send(:pages_url)
-    end  
+    end
   end
 
   def setup_for_named_route
@@ -279,16 +279,16 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       map.normal ':controller/:action/:id'
     end
   end
-     
+
   def test_named_route_root
     rs.draw do |map|
       map.root :controller => "hello"
-    end                     
-    x = setup_for_named_route       
+    end
+    x = setup_for_named_route
     assert_equal("http://named.route.test/", x.send(:root_url))
     assert_equal("/", x.send(:root_path))
   end
-  
+
   def test_named_route_with_regexps
     rs.draw do |map|
       map.article 'page/:year/:month/:day/:title', :controller => 'page', :action => 'show',
@@ -311,7 +311,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       {:controller => 'stuff', :action => 'show', :id => 10},
       {:controller => 'admin/user', :action => 'index'}
     )
-  end  
+  end
 
   def test_paths_escaped
     rs.draw do |map|
@@ -333,15 +333,15 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert results, "Recognition should have succeeded"
     assert_equal [], results[:path]
   end
-  
+
   def test_paths_slashes_unescaped_with_ordered_parameters
-    rs.add_named_route :path, '/file/*path', :controller => 'content' 
+    rs.add_named_route :path, '/file/*path', :controller => 'content'
 
-    # No / to %2F in URI, only for query params. 
-    x = setup_for_named_route 
+    # No / to %2F in URI, only for query params.
+    x = setup_for_named_route
     assert_equal("/file/hello/world", x.send(:path_path, 'hello/world'))
   end
-  
+
   def test_non_controllers_cannot_be_matched
     rs.draw do |map|
       map.connect ':controller/:action/:id'
@@ -356,13 +356,13 @@ class LegacyRouteSetTests < Test::Unit::TestCase
         map.connect ':controller/:action/:id'
       end
     end
-    
+
     rs.draw do |map|
       map.path 'file/*path', :controller => 'content', :action => 'show_file', :path => []
       map.connect ':controller/:action/:id'
     end
   end
-  
+
   def test_should_list_options_diff_when_routing_requirements_dont_match
     rs.draw do |map|
       map.post 'post/:id', :controller=> 'post', :action=> 'show', :requirements => {:id => /\d+/}
@@ -373,7 +373,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert_match /:bad_param=>"foo"/,   from_match
     assert_match /:action=>"show"/,     from_match
     assert_match /:controller=>"post"/, from_match
-    
+
     expected_match = exception.message.match(/expected: \{[^\}]+\}/).to_s
     assert_no_match /:bad_param=>"foo"/,   expected_match
     assert_match    /:action=>"show"/,     expected_match
@@ -397,7 +397,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert_match %r[you may have ambiguous routes, or you may need to supply additional parameters for this route], exception.message
     assert_match %r[content_url has the following required parameters: \["content", :query\] - are they all satisfied?], exception.message
   end
-  
+
   def test_dynamic_path_allowed
     rs.draw do |map|
       map.connect '*path', :controller => 'content', :action => 'show_file'
@@ -410,7 +410,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     rs.draw do |map|
       map.connect '*path', :controller => 'content', :action => 'show_file'
     end
-    
+
     recall_path = ActionController::Routing::PathSegment::Result.new(%w(pages boo))
     assert_equal '/pages/boo', rs.generate({}, :controller => 'content', :action => 'show_file', :path => recall_path)
   end
@@ -458,7 +458,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert_equal '/page/' + escaped_token, rs.generate(:controller => 'content', :action => 'show_page', :id => token)
     assert_equal({:controller => "content", :action => 'show_page', :id => token}, rs.recognize_path("/page/#{escaped_token}"))
   end
-  
+
   def test_action_expiry
     assert_equal '/content', rs.generate({:controller => 'content'}, {:controller => 'content', :action => 'show'})
   end
@@ -472,19 +472,19 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     #assert_equal({'controller' => "admin/news_feed", 'action' => 'index'}, rs.recognize_path("Admin/NewsFeed"))
     #assert_equal({'controller' => "admin/news_feed", 'action' => 'index'}, rs.recognize_path("Admin/News_Feed"))
   end
-  
+
   def test_requirement_should_prevent_optional_id
     rs.draw do |map|
       map.post 'post/:id', :controller=> 'post', :action=> 'show', :requirements => {:id => /\d+/}
     end
 
     assert_equal '/post/10', rs.generate(:controller => 'post', :action => 'show', :id => 10)
-    
+
     assert_raises ActionController::RoutingError do
       rs.generate(:controller => 'post', :action => 'show')
     end
   end
-  
+
   def test_both_requirement_and_optional
     rs.draw do |map|
       map.blog('test/:year', :controller => 'post', :action => 'show',
@@ -496,25 +496,25 @@ class LegacyRouteSetTests < Test::Unit::TestCase
 
     assert_equal '/test', rs.generate(:controller => 'post', :action => 'show')
     assert_equal '/test', rs.generate(:controller => 'post', :action => 'show', :year => nil)
-    
+
     x = setup_for_named_route
     assert_equal("http://named.route.test/test",
                  x.send(:blog_url))
   end
-  
+
   def test_set_to_nil_forgets
     rs.draw do |map|
       map.connect 'pages/:year/:month/:day', :controller => 'content', :action => 'list_pages', :month => nil, :day => nil
       map.connect ':controller/:action/:id'
     end
-    
+
     assert_equal '/pages/2005',
       rs.generate(:controller => 'content', :action => 'list_pages', :year => 2005)
     assert_equal '/pages/2005/6',
       rs.generate(:controller => 'content', :action => 'list_pages', :year => 2005, :month => 6)
     assert_equal '/pages/2005/6/12',
       rs.generate(:controller => 'content', :action => 'list_pages', :year => 2005, :month => 6, :day => 12)
-    
+
     assert_equal '/pages/2005/6/4',
       rs.generate({:day => 4}, {:controller => 'content', :action => 'list_pages', :year => '2005', :month => '6', :day => '12'})
 
@@ -524,13 +524,13 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     assert_equal '/pages/2005',
       rs.generate({:day => nil, :month => nil}, {:controller => 'content', :action => 'list_pages', :year => '2005', :month => '6', :day => '12'})
   end
-  
+
   def test_url_with_no_action_specified
     rs.draw do |map|
       map.connect '', :controller => 'content'
       map.connect ':controller/:action/:id'
     end
-    
+
     assert_equal '/', rs.generate(:controller => 'content', :action => 'index')
     assert_equal '/', rs.generate(:controller => 'content')
   end
@@ -540,17 +540,17 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       map.home '', :controller => 'content'
       map.connect ':controller/:action/:id'
     end
-    
+
     assert_equal '/', rs.generate(:controller => 'content', :action => 'index')
     assert_equal '/', rs.generate(:controller => 'content')
-    
+
     x = setup_for_named_route
     assert_equal("http://named.route.test/",
                  x.send(:home_url))
   end
-  
+
   def test_url_generated_when_forgetting_action
-    [{:controller => 'content', :action => 'index'}, {:controller => 'content'}].each do |hash| 
+    [{:controller => 'content', :action => 'index'}, {:controller => 'content'}].each do |hash|
       rs.draw do |map|
         map.home '', hash
         map.connect ':controller/:action/:id'
@@ -560,7 +560,7 @@ class LegacyRouteSetTests < Test::Unit::TestCase
       assert_equal '/content/hi', rs.generate({:controller => 'content', :action => 'hi'})
     end
   end
-  
+
   def test_named_route_method
     rs.draw do |map|
       map.categories 'categories', :controller => 'content', :action => 'categories'
@@ -629,11 +629,11 @@ class LegacyRouteSetTests < Test::Unit::TestCase
     hash = rs.recognize_path "/books/17/edit"
     assert_not_nil hash
     assert_equal %w(subpath_books 17 edit), [hash[:controller], hash[:id], hash[:action]]
-    
+
     hash = rs.recognize_path "/items/3/complete"
     assert_not_nil hash
     assert_equal %w(subpath_books 3 complete), [hash[:controller], hash[:id], hash[:action]]
-    
+
     hash = rs.recognize_path "/posts/new/preview"
     assert_not_nil hash
     assert_equal %w(subpath_books preview), [hash[:controller], hash[:action]]
@@ -660,42 +660,42 @@ class LegacyRouteSetTests < Test::Unit::TestCase
   ensure
     Object.send(:remove_const, :SubpathBooksController) rescue nil
   end
-  
+
   def test_failed_requirements_raises_exception_with_violated_requirements
     rs.draw do |r|
       r.foo_with_requirement 'foos/:id', :controller=>'foos', :requirements=>{:id=>/\d+/}
     end
-    
+
     x = setup_for_named_route
-    assert_raises(ActionController::RoutingError) do 
+    assert_raises(ActionController::RoutingError) do
       x.send(:foo_with_requirement_url, "I am Against the requirements")
     end
   end
 end
 
 class SegmentTest < Test::Unit::TestCase
-  
+
   def test_first_segment_should_interpolate_for_structure
     s = ROUTING::Segment.new
     def s.interpolation_statement(array) 'hello' end
     assert_equal 'hello', s.continue_string_structure([])
   end
-  
+
   def test_interpolation_statement
     s = ROUTING::StaticSegment.new
     s.value = "Hello"
     assert_equal "Hello", eval(s.interpolation_statement([]))
     assert_equal "HelloHello", eval(s.interpolation_statement([s]))
-    
+
     s2 = ROUTING::StaticSegment.new
     s2.value = "-"
     assert_equal "Hello-Hello", eval(s.interpolation_statement([s, s2]))
-    
+
     s3 = ROUTING::StaticSegment.new
     s3.value = "World"
     assert_equal "Hello-World", eval(s3.interpolation_statement([s, s2]))
   end
-  
+
 end
 
 class StaticSegmentTest < Test::Unit::TestCase
@@ -713,28 +713,28 @@ class StaticSegmentTest < Test::Unit::TestCase
 
   def test_regexp_chunk_should_escape_specials
     s = ROUTING::StaticSegment.new
-    
+
     s.value = 'Hello*World'
     assert_equal 'Hello\*World', s.regexp_chunk
-    
+
     s.value = 'HelloWorld'
     assert_equal 'HelloWorld', s.regexp_chunk
   end
-  
+
   def test_regexp_chunk_should_add_question_mark_for_optionals
     s = ROUTING::StaticSegment.new
     s.value = "/"
     s.is_optional = true
     assert_equal "/?", s.regexp_chunk
-    
+
     s.value = "hello"
     assert_equal "(?:hello)?", s.regexp_chunk
   end
-  
+
 end
 
 class DynamicSegmentTest < Test::Unit::TestCase
-  
+
   def segment
     unless @segment
       @segment = ROUTING::DynamicSegment.new
@@ -742,126 +742,126 @@ class DynamicSegmentTest < Test::Unit::TestCase
     end
     @segment
   end
-  
+
   def test_extract_value
     s = ROUTING::DynamicSegment.new
     s.key = :a
-    
+
     hash = {:a => '10', :b => '20'}
     assert_equal '10', eval(s.extract_value)
-    
+
     hash = {:b => '20'}
     assert_equal nil, eval(s.extract_value)
-    
+
     s.default = '20'
     assert_equal '20', eval(s.extract_value)
   end
-  
+
   def test_default_local_name
     assert_equal 'a_value', segment.local_name,
       "Unexpected name -- all value_check tests will fail!"
   end
-  
+
   def test_presence_value_check
     a_value = 10
     assert eval(segment.value_check)
   end
-  
+
   def test_regexp_value_check_rejects_nil
     segment.regexp = /\d+/
     a_value = nil
     assert ! eval(segment.value_check)
   end
-  
+
   def test_optional_regexp_value_check_should_accept_nil
     segment.regexp = /\d+/
     segment.is_optional = true
     a_value = nil
     assert eval(segment.value_check)
   end
-  
+
   def test_regexp_value_check_rejects_no_match
     segment.regexp = /\d+/
-    
+
     a_value = "Hello20World"
     assert ! eval(segment.value_check)
-    
+
     a_value = "20Hi"
     assert ! eval(segment.value_check)
   end
-  
+
   def test_regexp_value_check_accepts_match
     segment.regexp = /\d+/
-    
+
     a_value = "30"
     assert eval(segment.value_check)
   end
-  
+
   def test_value_check_fails_on_nil
     a_value = nil
     assert ! eval(segment.value_check)
   end
-  
+
   def test_optional_value_needs_no_check
     segment.is_optional = true
     a_value = nil
     assert_equal nil, segment.value_check
   end
-  
+
   def test_regexp_value_check_should_accept_match_with_default
     segment.regexp = /\d+/
     segment.default = '200'
-    
+
     a_value = '100'
     assert eval(segment.value_check)
   end
-  
+
   def test_expiry_should_not_trigger_once_expired
     expired = true
     hash = merged = {:a => 2, :b => 3}
     options = {:b => 3}
     expire_on = Hash.new { raise 'No!!!' }
-    
+
     eval(segment.expiry_statement)
   rescue RuntimeError
     flunk "Expiry check should not have occurred!"
   end
-  
+
   def test_expiry_should_occur_according_to_expire_on
     expired = false
     hash = merged = {:a => 2, :b => 3}
     options = {:b => 3}
-    
+
     expire_on = {:b => true, :a => false}
     eval(segment.expiry_statement)
     assert !expired
     assert_equal({:a => 2, :b => 3}, hash)
-    
+
     expire_on = {:b => true, :a => true}
     eval(segment.expiry_statement)
     assert expired
     assert_equal({:b => 3}, hash)
   end
-  
+
   def test_extraction_code_should_return_on_nil
     hash = merged = {:b => 3}
     options = {:b => 3}
     a_value = nil
-    
+
     # Local jump because of return inside eval.
     assert_raises(LocalJumpError) { eval(segment.extraction_code) }
   end
-  
+
   def test_extraction_code_should_return_on_mismatch
     segment.regexp = /\d+/
     hash = merged = {:a => 'Hi', :b => '3'}
     options = {:b => '3'}
     a_value = nil
-    
+
     # Local jump because of return inside eval.
     assert_raises(LocalJumpError) { eval(segment.extraction_code) }
   end
-  
+
   def test_extraction_code_should_accept_value_and_set_local
     hash = merged = {:a => 'Hi', :b => '3'}
     options = {:b => '3'}
@@ -871,45 +871,45 @@ class DynamicSegmentTest < Test::Unit::TestCase
     eval(segment.extraction_code)
     assert_equal 'Hi', a_value
   end
-  
+
   def test_extraction_should_work_without_value_check
     segment.default = 'hi'
     hash = merged = {:b => '3'}
     options = {:b => '3'}
     a_value = nil
     expired = true
-    
+
     eval(segment.extraction_code)
     assert_equal 'hi', a_value
   end
-  
+
   def test_extraction_code_should_perform_expiry
     expired = false
     hash = merged = {:a => 'Hi', :b => '3'}
     options = {:b => '3'}
     expire_on = {:a => true}
     a_value = nil
-    
+
     eval(segment.extraction_code)
     assert_equal 'Hi', a_value
     assert expired
     assert_equal options, hash
   end
-  
+
   def test_interpolation_chunk_should_replace_value
     a_value = 'Hi'
     assert_equal a_value, eval(%("#{segment.interpolation_chunk}"))
   end
-  
+
   def test_interpolation_chunk_should_accept_nil
     a_value = nil
     assert_equal '', eval(%("#{segment.interpolation_chunk('a_value')}"))
   end
-  
+
   def test_value_regexp_should_be_nil_without_regexp
     assert_equal nil, segment.value_regexp
   end
-  
+
   def test_value_regexp_should_match_exacly
     segment.regexp = /\d+/
     assert_no_match segment.value_regexp, "Hello 10 World"
@@ -917,12 +917,12 @@ class DynamicSegmentTest < Test::Unit::TestCase
     assert_no_match segment.value_regexp, "10 World"
     assert_match segment.value_regexp, "10"
   end
-  
+
   def test_regexp_chunk_should_return_string
     segment.regexp = /\d+/
     assert_kind_of String, segment.regexp_chunk
   end
-  
+
   def test_build_pattern_non_optional_with_no_captures
     # Non optional
     a_segment = ROUTING::DynamicSegment.new
@@ -958,22 +958,22 @@ class DynamicSegmentTest < Test::Unit::TestCase
 end
 
 class ControllerSegmentTest < Test::Unit::TestCase
-  
+
   def test_regexp_should_only_match_possible_controllers
     ActionController::Routing.with_controllers %w(admin/accounts admin/users account pages) do
       cs = ROUTING::ControllerSegment.new :controller
       regexp = %r{\A#{cs.regexp_chunk}\Z}
-      
+
       ActionController::Routing.possible_controllers.each do |name|
         assert_match regexp, name
         assert_no_match regexp, "#{name}_fake"
-        
+
         match = regexp.match name
         assert_equal name, match[1]
       end
     end
   end
-  
+
 end
 
 uses_mocha 'RouteTest' do
@@ -987,22 +987,22 @@ uses_mocha 'RouteTest' do
 
     def url_for(options)
       only_path = options.delete(:only_path)
-      
+
       port        = options.delete(:port) || 80
       port_string = port == 80 ? '' : ":#{port}"
-      
+
       host   = options.delete(:host) || "named.route.test"
       anchor = "##{options.delete(:anchor)}" if options.key?(:anchor)
-      
+
       path = routes.generate(options)
-      
+
       only_path ? "#{path}#{anchor}" : "http://#{host}#{port_string}#{path}#{anchor}"
     end
-    
+
     def request
       @request ||= MockRequest.new(:host => "named.route.test", :method => :get)
     end
-    
+
     def relative_url_root=(value)
       request.relative_url_root=value
     end
@@ -1011,7 +1011,7 @@ uses_mocha 'RouteTest' do
   class MockRequest
     attr_accessor :path, :path_parameters, :host, :subdomains, :domain,
                   :method, :relative_url_root
-    
+
     def initialize(values={})
       values.each { |key, value| send("#{key}=", value) }
       if values[:host]
@@ -1019,11 +1019,11 @@ uses_mocha 'RouteTest' do
         self.subdomains = [subdomain]
       end
     end
-    
+
     def protocol
       "http://"
     end
-    
+
     def host_with_port
       (subdomains * '.') + '.' +  domain
     end
@@ -1040,29 +1040,29 @@ class RouteTest < Test::Unit::TestCase
       s.is_optional = is_optional
     end
   end
-  
+
   def default_route
     unless defined?(@default_route)
       @default_route = ROUTING::Route.new
-      
+
       @default_route.segments << (s = ROUTING::StaticSegment.new)
       s.value = '/'
       s.raw = true
-      
+
       @default_route.segments << (s = ROUTING::DynamicSegment.new)
       s.key = :controller
-      
+
       @default_route.segments << slash_segment(:optional)
       @default_route.segments << (s = ROUTING::DynamicSegment.new)
       s.key = :action
       s.default = 'index'
       s.is_optional = true
-      
+
       @default_route.segments << slash_segment(:optional)
       @default_route.segments << (s = ROUTING::DynamicSegment.new)
       s.key = :id
       s.is_optional = true
-      
+
       @default_route.segments << slash_segment(:optional)
     end
     @default_route
@@ -1072,37 +1072,37 @@ class RouteTest < Test::Unit::TestCase
     expected = {:controller => 'accounts', :action => 'show', :id => '10'}
     assert_equal expected, default_route.recognize('/accounts/show/10')
     assert_equal expected, default_route.recognize('/accounts/show/10/')
-    
+
     expected[:id] = 'jamis'
     assert_equal expected, default_route.recognize('/accounts/show/jamis/')
-    
+
     expected.delete :id
     assert_equal expected, default_route.recognize('/accounts/show')
     assert_equal expected, default_route.recognize('/accounts/show/')
-    
+
     expected[:action] = 'index'
     assert_equal expected, default_route.recognize('/accounts/')
     assert_equal expected, default_route.recognize('/accounts')
-    
+
     assert_equal nil, default_route.recognize('/')
     assert_equal nil, default_route.recognize('/accounts/how/goood/it/is/to/be/free')
   end
-  
+
   def test_default_route_should_omit_default_action
     o = {:controller => 'accounts', :action => 'index'}
     assert_equal '/accounts', default_route.generate(o, o, {})
   end
-  
+
   def test_default_route_should_include_default_action_when_id_present
     o = {:controller => 'accounts', :action => 'index', :id => '20'}
     assert_equal '/accounts/index/20', default_route.generate(o, o, {})
   end
-  
+
   def test_default_route_should_work_with_action_but_no_id
     o = {:controller => 'accounts', :action => 'list_all'}
     assert_equal '/accounts/list_all', default_route.generate(o, o, {})
   end
-  
+
   def test_default_route_should_uri_escape_pluses
     expected = { :controller => 'accounts', :action => 'show', :id => 'hello world' }
     assert_equal expected, default_route.recognize('/accounts/show/hello world')
@@ -1119,13 +1119,13 @@ class RouteTest < Test::Unit::TestCase
     # requirement_for should only be called for the action and controller _once_
     @route.expects(:requirement_for).with(:controller).times(1).returns('pages')
     @route.expects(:requirement_for).with(:action).times(1).returns('show')
-    
+
     @route.requirements = {:controller => 'pages', :action => 'show'}
     assert @route.matches_controller_and_action?('pages', 'show')
     assert !@route.matches_controller_and_action?('not_pages', 'show')
     assert !@route.matches_controller_and_action?('pages', 'not_show')
   end
-    
+
   def test_parameter_shell
     page_url = ROUTING::Route.new
     page_url.requirements = {:controller => 'pages', :action => 'show', :id => /\d+/}
@@ -1138,7 +1138,7 @@ class RouteTest < Test::Unit::TestCase
       { :controller => "users", :action => "show", :format => "html" },
       route.defaults)
   end
-  
+
   def test_builder_complains_without_controller
     assert_raises(ArgumentError) do
       ROUTING::RouteBuilder.new.build '/contact', :contoller => "contact", :action => "index"
@@ -1149,31 +1149,31 @@ class RouteTest < Test::Unit::TestCase
     keys = default_route.significant_keys.sort_by {|k| k.to_s }
     assert_equal [:action, :controller, :id], keys
   end
-  
+
   def test_significant_keys
     user_url = ROUTING::Route.new
     user_url.segments << (s = ROUTING::StaticSegment.new)
     s.value = '/'
     s.raw = true
-    
+
     user_url.segments << (s = ROUTING::StaticSegment.new)
     s.value = 'user'
-    
+
     user_url.segments << (s = ROUTING::StaticSegment.new)
     s.value = '/'
     s.raw = true
     s.is_optional = true
-    
+
     user_url.segments << (s = ROUTING::DynamicSegment.new)
     s.key = :user
-    
+
     user_url.segments << (s = ROUTING::StaticSegment.new)
     s.value = '/'
     s.raw = true
     s.is_optional = true
-    
+
     user_url.requirements = {:controller => 'users', :action => 'show'}
-    
+
     keys = user_url.significant_keys.sort_by { |k| k.to_s }
     assert_equal [:action, :controller, :user], keys
   end
@@ -1205,7 +1205,7 @@ class RouteTest < Test::Unit::TestCase
   def test_escape_spaces_build_query_string_selected_keys
     assert_equal '?x=hello+world', order_query_string(@route.build_query_string({:x => 'hello world', :y => 'goodbye world'}, [:x]))
   end
-  
+
   private
     def order_query_string(qs)
       '?' + qs[1..-1].split('&').sort.join('&')
@@ -1244,7 +1244,7 @@ class RouteBuilderTest < Test::Unit::TestCase
     assert_kind_of ROUTING::StaticSegment, segment
     assert_equal 'ulysses', segment.value
   end
-  
+
   def test_segment_for_action
     segment, rest = builder.segment_for ':action'
     assert_equal '', rest
@@ -1252,7 +1252,7 @@ class RouteBuilderTest < Test::Unit::TestCase
     assert_equal :action, segment.key
     assert_equal 'index', segment.default
   end
-  
+
   def test_segment_for_dynamic
     segment, rest = builder.segment_for ':login'
     assert_equal '', rest
@@ -1261,7 +1261,7 @@ class RouteBuilderTest < Test::Unit::TestCase
     assert_equal nil, segment.default
     assert ! segment.optional?
   end
-  
+
   def test_segment_for_with_rest
     segment, rest = builder.segment_for ':login/:action'
     assert_equal :login, segment.key
@@ -1273,105 +1273,105 @@ class RouteBuilderTest < Test::Unit::TestCase
     assert_equal :action, segment.key
     assert_equal '', rest
   end
-  
+
   def test_segments_for
     segments = builder.segments_for_route_path '/:controller/:action/:id'
-    
+
     assert_kind_of ROUTING::DividerSegment, segments[0]
     assert_equal '/', segments[2].value
-    
+
     assert_kind_of ROUTING::DynamicSegment, segments[1]
     assert_equal :controller, segments[1].key
-    
+
     assert_kind_of ROUTING::DividerSegment, segments[2]
     assert_equal '/', segments[2].value
-    
+
     assert_kind_of ROUTING::DynamicSegment, segments[3]
     assert_equal :action, segments[3].key
-    
+
     assert_kind_of ROUTING::DividerSegment, segments[4]
     assert_equal '/', segments[4].value
-    
+
     assert_kind_of ROUTING::DynamicSegment, segments[5]
     assert_equal :id, segments[5].key
   end
-  
+
   def test_segment_for_action
     s, r = builder.segment_for(':action/something/else')
     assert_equal '/something/else', r
     assert_equal :action, s.key
   end
-  
+
   def test_action_default_should_not_trigger_on_prefix
     s, r = builder.segment_for ':action_name/something/else'
     assert_equal '/something/else', r
     assert_equal :action_name, s.key
     assert_equal nil, s.default
   end
-  
+
   def test_divide_route_options
     segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
     defaults, requirements = builder.divide_route_options(segments,
       :action => 'buy', :person => /\w+/, :car => /\w+/,
       :defaults => {:person => nil, :car => nil}
     )
-    
+
     assert_equal({:action => 'buy', :person => nil, :car => nil}, defaults)
     assert_equal({:person => /\w+/, :car => /\w+/}, requirements)
   end
-  
+
   def test_assign_route_options
     segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
     defaults = {:action => 'buy', :person => nil, :car => nil}
     requirements = {:person => /\w+/, :car => /\w+/}
-    
+
     route_requirements = builder.assign_route_options(segments, defaults, requirements)
     assert_equal({}, route_requirements)
-    
+
     assert_equal :action, segments[3].key
     assert_equal 'buy', segments[3].default
-    
+
     assert_equal :person, segments[5].key
     assert_equal %r/\w+/, segments[5].regexp
     assert segments[5].optional?
-    
+
     assert_equal :car, segments[7].key
     assert_equal %r/\w+/, segments[7].regexp
     assert segments[7].optional?
   end
-  
+
   def test_assign_route_options_with_anchor_chars
     segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
     defaults = {:action => 'buy', :person => nil, :car => nil}
     requirements = {:person => /\w+/, :car => /^\w+$/}
-    
+
     assert_raises ArgumentError do
       route_requirements = builder.assign_route_options(segments, defaults, requirements)
     end
-    
+
     requirements[:car] = /[^\/]+/
     route_requirements = builder.assign_route_options(segments, defaults, requirements)
   end
-  
+
 
   def test_optional_segments_preceding_required_segments
     segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
     defaults = {:action => 'buy', :person => nil, :car => "model-t"}
     assert builder.assign_route_options(segments, defaults, {}).empty?
-    
+
     0.upto(1) { |i| assert !segments[i].optional?, "segment #{i} is optional and it shouldn't be" }
     assert segments[2].optional?
-    
+
     assert_equal nil, builder.warn_output # should only warn on the :person segment
   end
-  
+
   def test_segmentation_of_dot_path
     segments = builder.segments_for_route_path '/books/:action.rss'
     assert builder.assign_route_options(segments, {}, {}).empty?
     assert_equal 6, segments.length # "/", "books", "/", ":action", ".", "rss"
     assert !segments.any? { |seg| seg.optional? }
   end
-  
+
   def test_segmentation_of_dynamic_dot_path
     segments = builder.segments_for_route_path '/books/:action.:format'
     assert builder.assign_route_options(segments, {}, {}).empty?
@@ -1379,56 +1379,56 @@ class RouteBuilderTest < Test::Unit::TestCase
     assert !segments.any? { |seg| seg.optional? }
     assert_kind_of ROUTING::DynamicSegment, segments.last
   end
-  
+
   def test_assignment_of_default_options
     segments = builder.segments_for_route_path '/:controller/:action/:id/'
     action, id = segments[-4], segments[-2]
-    
+
     assert_equal :action, action.key
     assert_equal :id, id.key
     assert ! action.optional?
     assert ! id.optional?
-    
+
     builder.assign_default_route_options(segments)
-    
+
     assert_equal 'index', action.default
     assert action.optional?
     assert id.optional?
   end
-  
+
   def test_assignment_of_default_options_respects_existing_defaults
     segments = builder.segments_for_route_path '/:controller/:action/:id/'
     action, id = segments[-4], segments[-2]
-    
+
     assert_equal :action, action.key
     assert_equal :id, id.key
     action.default = 'show'
     action.is_optional = true
-    
+
     id.default = 'Welcome'
     id.is_optional = true
-    
+
     builder.assign_default_route_options(segments)
-    
+
     assert_equal 'show', action.default
     assert action.optional?
     assert_equal 'Welcome', id.default
     assert id.optional?
   end
-  
+
   def test_assignment_of_default_options_respects_regexps
     segments = builder.segments_for_route_path '/:controller/:action/:id/'
     action = segments[-4]
-    
+
     assert_equal :action, action.key
     action.regexp = /show|in/ # Use 'in' to check partial matches
-    
+
     builder.assign_default_route_options(segments)
-    
+
     assert_equal nil, action.default
     assert ! action.optional?
   end
-  
+
   def test_assignment_of_is_optional_when_default
     segments = builder.segments_for_route_path '/books/:action.rss'
     assert_equal segments[3].key, :action
@@ -1436,44 +1436,44 @@ class RouteBuilderTest < Test::Unit::TestCase
     builder.ensure_required_segments(segments)
     assert ! segments[3].optional?
   end
-  
+
   def test_is_optional_is_assigned_to_default_segments
     segments = builder.segments_for_route_path '/books/:action'
     builder.assign_route_options(segments, {:action => 'index'}, {})
-    
+
     assert_equal segments[3].key, :action
     assert segments[3].optional?
     assert_kind_of ROUTING::DividerSegment, segments[2]
     assert segments[2].optional?
   end
-  
+
   # XXX is optional not being set right?
   # /blah/:defaulted_segment <-- is the second slash optional? it should be.
-  
+
   def test_route_build
     ActionController::Routing.with_controllers %w(users pages) do
       r = builder.build '/:controller/:action/:id/', :action => nil
-      
+
       [0, 2, 4].each do |i|
         assert_kind_of ROUTING::DividerSegment, r.segments[i]
         assert_equal '/', r.segments[i].value
         assert r.segments[i].optional? if i > 1
       end
-      
+
       assert_kind_of ROUTING::DynamicSegment, r.segments[1]
       assert_equal :controller, r.segments[1].key
       assert_equal nil, r.segments[1].default
-      
+
       assert_kind_of ROUTING::DynamicSegment, r.segments[3]
       assert_equal :action, r.segments[3].key
       assert_equal 'index', r.segments[3].default
-      
+
       assert_kind_of ROUTING::DynamicSegment, r.segments[5]
       assert_equal :id, r.segments[5].key
       assert r.segments[5].optional?
     end
   end
-  
+
   def test_slashes_are_implied
     routes = [
       builder.build('/:controller/:action/:id/', :action => nil),
@@ -1487,7 +1487,7 @@ class RouteBuilderTest < Test::Unit::TestCase
       assert_equal expected, found, "Route #{i + 1} has #{found} segments, expected #{expected}"
     end
   end
-  
+
 end
 
 
@@ -1515,33 +1515,33 @@ class RouteSetTest < Test::Unit::TestCase
     extras = set.extra_keys(:controller => "foo", :action => "bar", :id => 15, :this => "hello", :that => "world")
     assert_equal %w(that this), extras.map(&:to_s).sort
   end
-  
+
   def test_generate_extras_not_first
-    set.draw do |map| 
+    set.draw do |map|
       map.connect ':controller/:action/:id.:format'
       map.connect ':controller/:action/:id'
-    end    
+    end
     path, extras = set.generate_extras(:controller => "foo", :action => "bar", :id => 15, :this => "hello", :that => "world")
     assert_equal "/foo/bar/15", path
     assert_equal %w(that this), extras.map(&:to_s).sort
   end
-  
+
   def test_generate_not_first
-    set.draw do |map| 
+    set.draw do |map|
       map.connect ':controller/:action/:id.:format'
       map.connect ':controller/:action/:id'
-    end    
+    end
     assert_equal "/foo/bar/15?this=hello", set.generate(:controller => "foo", :action => "bar", :id => 15, :this => "hello")
   end
-  
+
   def test_extra_keys_not_first
-    set.draw do |map| 
+    set.draw do |map|
       map.connect ':controller/:action/:id.:format'
       map.connect ':controller/:action/:id'
     end
     extras = set.extra_keys(:controller => "foo", :action => "bar", :id => 15, :this => "hello", :that => "world")
     assert_equal %w(that this), extras.map(&:to_s).sort
-  end   
+  end
 
   def test_draw
     assert_equal 0, set.routes.size
@@ -1550,7 +1550,7 @@ class RouteSetTest < Test::Unit::TestCase
     end
     assert_equal 1, set.routes.size
   end
-  
+
   def test_named_draw
     assert_equal 0, set.routes.size
     set.draw do |map|
@@ -1559,7 +1559,7 @@ class RouteSetTest < Test::Unit::TestCase
     assert_equal 1, set.routes.size
     assert_equal set.routes.first, set.named_routes[:hello]
   end
-  
+
   def test_later_named_routes_take_precedence
     set.draw do |map|
       map.hello '/hello/world', :controller => 'a', :action => 'b'
@@ -1591,7 +1591,7 @@ class RouteSetTest < Test::Unit::TestCase
     assert_equal(
       { :controller => 'people', :action => 'index', :use_route => :index, :only_path => false },
       controller.send(:hash_for_index_url))
-    
+
     assert_equal(
       { :controller => 'people', :action => 'show', :id => 5, :use_route => :show, :only_path => true },
       controller.send(:hash_for_show_path, :id => 5)
@@ -1600,10 +1600,10 @@ class RouteSetTest < Test::Unit::TestCase
 
   def test_named_route_url_method
     controller = setup_named_route_test
-    
+
     assert_equal "http://named.route.test/people/5", controller.send(:show_url, :id => 5)
     assert_equal "/people/5", controller.send(:show_path, :id => 5)
-    
+
     assert_equal "http://named.route.test/people", controller.send(:index_url)
     assert_equal "/people", controller.send(:index_path)
 
@@ -1633,17 +1633,17 @@ class RouteSetTest < Test::Unit::TestCase
     assert_equal "http://named.route.test/people?baz=bar#location",
       controller.send(:index_url, :baz => "bar", :anchor => 'location')
   end
-  
+
   def test_named_route_url_method_with_port
     controller = setup_named_route_test
     assert_equal "http://named.route.test:8080/people/5", controller.send(:show_url, 5, :port=>8080)
   end
-  
+
   def test_named_route_url_method_with_host
     controller = setup_named_route_test
     assert_equal "http://some.example.com/people/5", controller.send(:show_url, 5, :host=>"some.example.com")
   end
-  
+
 
   def test_named_route_url_method_with_ordered_parameters
     controller = setup_named_route_test
@@ -1656,13 +1656,13 @@ class RouteSetTest < Test::Unit::TestCase
     assert_equal "http://named.route.test/people/go/7/hello/joe/5?baz=bar",
       controller.send(:multi_url, 7, "hello", 5, :baz => "bar")
   end
-  
+
   def test_named_route_url_method_with_no_positional_arguments
     controller = setup_named_route_test
     assert_equal "http://named.route.test/people?baz=bar",
       controller.send(:index_url, :baz => "bar")
   end
-  
+
   def test_draw_default_route
     ActionController::Routing.with_controllers(['users']) do
       set.draw do |map|
@@ -1686,7 +1686,7 @@ class RouteSetTest < Test::Unit::TestCase
     ActionController::Routing.with_controllers(['users']) do
       set.draw do |map|
         map.connect '/:controller/:action/:id', :controller => 'users'
-      end      
+      end
       assert_equal({:controller => 'users', :action => 'index'}, set.recognize_path('/'))
     end
   end
@@ -1755,7 +1755,7 @@ class RouteSetTest < Test::Unit::TestCase
       set.generate(:controller => 'pages', :action => 'show', :name => 'nor_jamis_and_david')
     end
   end
-  
+
   def test_recognize_with_encoded_id_and_regex
     set.draw do |map|
       map.connect 'page/:id', :controller => 'pages', :action => 'show', :id => /[a-zA-Z0-9\+]+/
@@ -1782,11 +1782,11 @@ class RouteSetTest < Test::Unit::TestCase
     request.method = :get
     assert_nothing_raised { set.recognize(request) }
     assert_equal("index", request.path_parameters[:action])
-    
+
     request.method = :post
     assert_nothing_raised { set.recognize(request) }
     assert_equal("create", request.path_parameters[:action])
-    
+
     request.method = :put
     assert_nothing_raised { set.recognize(request) }
     assert_equal("update", request.path_parameters[:action])
@@ -1826,7 +1826,7 @@ class RouteSetTest < Test::Unit::TestCase
   ensure
     Object.send(:remove_const, :PeopleController)
   end
-  
+
   def test_recognize_with_alias_in_conditions
     Object.const_set(:PeopleController, Class.new)
 
@@ -1859,7 +1859,7 @@ class RouteSetTest < Test::Unit::TestCase
              :controller => 'articles', :action => 'permalink',
              :year => /\d{4}/, :day => /\d{1,2}/, :month => /\d{1,2}/
     end
-  
+
     request.path = "/articles/2005/11/05/a-very-interesting-article"
     request.method = :get
     assert_nothing_raised { set.recognize(request) }
@@ -1868,7 +1868,7 @@ class RouteSetTest < Test::Unit::TestCase
     assert_equal("11", request.path_parameters[:month])
     assert_equal("05", request.path_parameters[:day])
     assert_equal("a-very-interesting-article", request.path_parameters[:title])
-    
+
   ensure
     Object.send(:remove_const, :ArticlesController)
   end
@@ -1882,7 +1882,7 @@ class RouteSetTest < Test::Unit::TestCase
     request.path = '/profile'
 
     set.recognize(request) rescue nil
-    
+
     assert !Object.const_defined?("Profiler__"), "Profiler should not be loaded"
   end
 
@@ -1926,7 +1926,7 @@ class RouteSetTest < Test::Unit::TestCase
     url = set.generate(:controller => "people", :action => "list")
     assert_equal "/people/list", url
   end
-  
+
   def test_root_map
     Object.const_set(:PeopleController, Class.new)
 
@@ -1940,17 +1940,17 @@ class RouteSetTest < Test::Unit::TestCase
   ensure
     Object.send(:remove_const, :PeopleController)
   end
-  
-  
+
+
   def test_namespace
     Object.const_set(:Api, Module.new { |m| m.const_set(:ProductsController, Class.new) })
 
-    set.draw do |map| 
-      
+    set.draw do |map|
+
       map.namespace 'api' do |api|
         api.route 'inventory', :controller => "products", :action => 'inventory'
       end
-      
+
     end
 
     request.path = "/api/inventory"
@@ -1961,17 +1961,17 @@ class RouteSetTest < Test::Unit::TestCase
   ensure
     Object.send(:remove_const, :Api)
   end
-  
+
 
   def test_namespaced_root_map
     Object.const_set(:Api, Module.new { |m| m.const_set(:ProductsController, Class.new) })
 
-    set.draw do |map| 
-      
+    set.draw do |map|
+
       map.namespace 'api' do |api|
-        api.root :controller => "products"       
+        api.root :controller => "products"
       end
-      
+
     end
 
     request.path = "/api"
@@ -2053,7 +2053,7 @@ class RouteSetTest < Test::Unit::TestCase
     url = set.generate({:use_route => :family_connection, :controller => "connection"}, {:controller => 'connection/manage'})
     assert_equal "/connection", url
   end
-  
+
   def test_action_left_off_when_id_is_recalled
     set.draw do |map|
       map.connect ':controller/:action/:id'
@@ -2063,7 +2063,7 @@ class RouteSetTest < Test::Unit::TestCase
       {:controller => 'post', :action => 'show', :id => '10'}
     )
   end
-  
+
   def test_query_params_will_be_shown_when_recalled
     set.draw do |map|
       map.connect 'show_post/:parameter', :controller => 'post', :action => 'show'
@@ -2095,21 +2095,21 @@ class RouteSetTest < Test::Unit::TestCase
     assert_equal '/show_post/10', all.first
     assert_equal '/post/show/10', all.last
   end
-  
+
   def test_named_route_in_nested_resource
     set.draw do |map|
       map.resources :projects do |project|
         project.milestones 'milestones', :controller => 'milestones', :action => 'index'
       end
     end
-    
+
     request.path = "/projects/1/milestones"
     request.method = :get
     assert_nothing_raised { set.recognize(request) }
     assert_equal("milestones", request.path_parameters[:controller])
     assert_equal("index", request.path_parameters[:action])
   end
-  
+
   def test_setting_root_in_namespace_using_symbol
     assert_nothing_raised do
       set.draw do |map|
@@ -2119,7 +2119,7 @@ class RouteSetTest < Test::Unit::TestCase
       end
     end
   end
-  
+
   def test_setting_root_in_namespace_using_string
     assert_nothing_raised do
       set.draw do |map|
@@ -2260,12 +2260,10 @@ class RouteSetTest < Test::Unit::TestCase
     end
     assert_equal({:controller => 'pages', :action => 'show', :name => 'JAMIS'}, set.recognize_path('/page/JAMIS'))
   end
-
-  
 end
 
 class RoutingTest < Test::Unit::TestCase
-  
+
   def test_possible_controllers
     true_controller_paths = ActionController::Routing.controller_paths
 
@@ -2278,7 +2276,7 @@ class RoutingTest < Test::Unit::TestCase
     ActionController::Routing.controller_paths = [
       RAILS_ROOT, RAILS_ROOT + '/app/controllers', RAILS_ROOT + '/vendor/plugins/bad_plugin/lib'
     ]
-    
+
     assert_equal ["admin/user", "plugin", "user"], ActionController::Routing.possible_controllers.sort
   ensure
     if true_controller_paths
@@ -2287,32 +2285,32 @@ class RoutingTest < Test::Unit::TestCase
     ActionController::Routing.use_controllers! nil
     Object.send(:remove_const, :RAILS_ROOT) rescue nil
   end
-  
+
   def test_possible_controllers_are_reset_on_each_load
     true_possible_controllers = ActionController::Routing.possible_controllers
     true_controller_paths = ActionController::Routing.controller_paths
-    
+
     ActionController::Routing.use_controllers! nil
     root = File.dirname(__FILE__) + '/controller_fixtures'
-    
+
     ActionController::Routing.controller_paths = []
     assert_equal [], ActionController::Routing.possible_controllers
-    
+
     ActionController::Routing::Routes.load!
     ActionController::Routing.controller_paths = [
       root, root + '/app/controllers', root + '/vendor/plugins/bad_plugin/lib'
     ]
-    
+
     assert_equal ["admin/user", "plugin", "user"], ActionController::Routing.possible_controllers.sort
   ensure
     ActionController::Routing.controller_paths = true_controller_paths
     ActionController::Routing.use_controllers! true_possible_controllers
     Object.send(:remove_const, :RAILS_ROOT) rescue nil
-    
+
     ActionController::Routing::Routes.clear!
     ActionController::Routing::Routes.load_routes!
   end
-  
+
   def test_with_controllers
     c = %w(admin/accounts admin/users account pages)
     ActionController::Routing.with_controllers c do
@@ -2331,17 +2329,16 @@ class RoutingTest < Test::Unit::TestCase
     paths = ActionController::Routing.normalize_paths(load_paths)
     assert_equal %w(vendor\\rails\\railties\\builtin\\rails_info vendor\\rails\\actionpack\\lib app\\controllers app\\helpers app\\models config .bar lib .), paths
   end
-  
+
   def test_routing_helper_module
     assert_kind_of Module, ActionController::Routing::Helpers
-    
+
     h = ActionController::Routing::Helpers
     c = Class.new
     assert ! c.ancestors.include?(h)
     ActionController::Routing::Routes.install_helpers c
     assert c.ancestors.include?(h)
   end
-
 end
 
 uses_mocha 'route loading' do
@@ -2392,12 +2389,12 @@ uses_mocha 'route loading' do
     end
 
     def test_adding_inflections_forces_reload
-      Inflector::Inflections.instance.expects(:uncountable).with('equipment')
+      ActiveSupport::Inflector::Inflections.instance.expects(:uncountable).with('equipment')
       routes.expects(:reload!)
 
-      Inflector.inflections { |inflect| inflect.uncountable('equipment') }
+      ActiveSupport::Inflector.inflections { |inflect| inflect.uncountable('equipment') }
     end
-    
+
     def test_load_with_configuration
       routes.configuration_file = "foobarbaz"
       File.expects(:stat).returns(@stat)
@@ -2407,9 +2404,8 @@ uses_mocha 'route loading' do
     end
 
     private
-    def routes
-      ActionController::Routing::Routes
-    end
-
+      def routes
+        ActionController::Routing::Routes
+      end
   end
 end
diff --git a/activerecord/lib/active_record/base.rb b/activerecord/lib/active_record/base.rb
index 5351f55..12861fe 100755
--- a/activerecord/lib/active_record/base.rb
+++ b/activerecord/lib/active_record/base.rb
@@ -372,7 +372,7 @@ module ActiveRecord #:nodoc:
     def self.reset_subclasses #:nodoc:
       nonreloadables = []
       subclasses.each do |klass|
-        unless Dependencies.autoloaded? klass
+        unless ActiveSupport::Dependencies.autoloaded? klass
           nonreloadables << klass
           next
         end
diff --git a/activerecord/test/cases/attribute_methods_test.rb b/activerecord/test/cases/attribute_methods_test.rb
index c336fd9..c82be11 100755
--- a/activerecord/test/cases/attribute_methods_test.rb
+++ b/activerecord/test/cases/attribute_methods_test.rb
@@ -145,7 +145,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
       record[:written_on] = utc_time
       assert_equal utc_time, record.written_on # record.written on is equal to (i.e., simultaneous with) utc_time
       assert_kind_of ActiveSupport::TimeWithZone, record.written_on # but is a TimeWithZone
-      assert_equal TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone # and is in the current Time.zone
+      assert_equal ActiveSupport::TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone # and is in the current Time.zone
       assert_equal Time.utc(2007, 12, 31, 16), record.written_on.time # and represents time values adjusted accordingly
     end
   end
@@ -156,7 +156,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
       record   = @target.new
       record.written_on = utc_time
       assert_equal utc_time, record.written_on
-      assert_equal TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
+      assert_equal ActiveSupport::TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
       assert_equal Time.utc(2007, 12, 31, 16), record.written_on.time
     end
   end
@@ -168,7 +168,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
       record   = @target.new
       record.written_on = cst_time
       assert_equal utc_time, record.written_on
-      assert_equal TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
+      assert_equal ActiveSupport::TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
       assert_equal Time.utc(2007, 12, 31, 16), record.written_on.time
     end
   end
@@ -181,7 +181,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
         record   = @target.new
         record.written_on = time_string
         assert_equal Time.zone.parse(time_string), record.written_on
-        assert_equal TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
+        assert_equal ActiveSupport::TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
         assert_equal Time.utc(2007, 12, 31, 16), record.written_on.time
       end
     end
@@ -202,7 +202,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
         record   = @target.new
         record.written_on = time_string
         assert_equal Time.zone.parse(time_string), record.written_on
-        assert_equal TimeZone[timezone_offset], record.written_on.time_zone
+        assert_equal ActiveSupport::TimeZone[timezone_offset], record.written_on.time_zone
         assert_equal Time.utc(2008, 1, 1), record.written_on.time
       end
     end
@@ -214,7 +214,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
       record   = @target.new
       record.written_on = utc_time.in_time_zone
       assert_equal utc_time, record.written_on
-      assert_equal TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
+      assert_equal ActiveSupport::TimeZone["Pacific Time (US & Canada)"], record.written_on.time_zone
       assert_equal Time.utc(2007, 12, 31, 16), record.written_on.time
     end
   end
@@ -228,7 +228,7 @@ class AttributeMethodsTest < ActiveRecord::TestCase
     old_zone  = Time.zone
     old_tz    = ActiveRecord::Base.time_zone_aware_attributes
 
-    Time.zone = zone ? TimeZone[zone] : nil
+    Time.zone = zone ? ActiveSupport::TimeZone[zone] : nil
     ActiveRecord::Base.time_zone_aware_attributes = !zone.nil?
     yield
   ensure
diff --git a/activerecord/test/cases/base_test.rb b/activerecord/test/cases/base_test.rb
index e07ec50..740ab95 100755
--- a/activerecord/test/cases/base_test.rb
+++ b/activerecord/test/cases/base_test.rb
@@ -998,7 +998,7 @@ class BasicsTest < ActiveRecord::TestCase
   def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes
     ActiveRecord::Base.time_zone_aware_attributes = true
     ActiveRecord::Base.default_timezone = :utc
-    Time.zone = TimeZone[-28800]
+    Time.zone = ActiveSupport::TimeZone[-28800]
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
@@ -1016,7 +1016,7 @@ class BasicsTest < ActiveRecord::TestCase
 
   def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes_false
     ActiveRecord::Base.time_zone_aware_attributes = false
-    Time.zone = TimeZone[-28800]
+    Time.zone = ActiveSupport::TimeZone[-28800]
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
@@ -1032,7 +1032,7 @@ class BasicsTest < ActiveRecord::TestCase
   def test_multiparameter_attributes_on_time_with_skip_time_zone_conversion_for_attributes
     ActiveRecord::Base.time_zone_aware_attributes = true
     ActiveRecord::Base.default_timezone = :utc
-    Time.zone = TimeZone[-28800]
+    Time.zone = ActiveSupport::TimeZone[-28800]
     Topic.skip_time_zone_conversion_for_attributes = [:written_on]
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
diff --git a/activerecord/test/cases/inheritance_test.rb b/activerecord/test/cases/inheritance_test.rb
index 2739492..1ff48f6 100755
--- a/activerecord/test/cases/inheritance_test.rb
+++ b/activerecord/test/cases/inheritance_test.rb
@@ -207,11 +207,11 @@ class InheritanceComputeTypeTest < ActiveRecord::TestCase
   fixtures :companies
 
   def setup
-    Dependencies.log_activity = true
+    ActiveSupport::Dependencies.log_activity = true
   end
 
   def teardown
-    Dependencies.log_activity = false
+    ActiveSupport::Dependencies.log_activity = false
     self.class.const_remove :FirmOnTheFly rescue nil
     Firm.const_remove :FirmOnTheFly rescue nil
   end
diff --git a/activerecord/test/cases/multiple_db_test.rb b/activerecord/test/cases/multiple_db_test.rb
index 236e471..eb3e43c 100644
--- a/activerecord/test/cases/multiple_db_test.rb
+++ b/activerecord/test/cases/multiple_db_test.rb
@@ -51,7 +51,7 @@ class MultipleDbTest < ActiveRecord::TestCase
   def test_course_connection_should_survive_dependency_reload
     assert Course.connection
 
-    Dependencies.clear
+    ActiveSupport::Dependencies.clear
     Object.send(:remove_const, :Course)
     require_dependency 'models/course'
 
diff --git a/activesupport/lib/active_support.rb b/activesupport/lib/active_support.rb
index e4cb145..982adfb 100644
--- a/activesupport/lib/active_support.rb
+++ b/activesupport/lib/active_support.rb
@@ -53,3 +53,7 @@ require 'active_support/multibyte'
 require 'active_support/base64'
 
 require 'active_support/time_with_zone'
+
+Inflector = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('Inflector', 'ActiveSupport::Inflector')
+Dependencies = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('Dependencies', 'ActiveSupport::Dependencies')
+TimeZone = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('TimeZone', 'ActiveSupport::TimeZone')
diff --git a/activesupport/lib/active_support/dependencies.rb b/activesupport/lib/active_support/dependencies.rb
index 25225d5..e92b405 100644
--- a/activesupport/lib/active_support/dependencies.rb
+++ b/activesupport/lib/active_support/dependencies.rb
@@ -3,457 +3,461 @@ require 'active_support/core_ext/module/attribute_accessors'
 require 'active_support/core_ext/load_error'
 require 'active_support/core_ext/kernel'
 
-module Dependencies #:nodoc:
-  extend self
-
-  # Should we turn on Ruby warnings on the first load of dependent files?
-  mattr_accessor :warnings_on_first_load
-  self.warnings_on_first_load = false
-
-  # All files ever loaded.
-  mattr_accessor :history
-  self.history = Set.new
-
-  # All files currently loaded.
-  mattr_accessor :loaded
-  self.loaded = Set.new
-
-  # Should we load files or require them?
-  mattr_accessor :mechanism
-  self.mechanism = :load
-
-  # The set of directories from which we may automatically load files. Files
-  # under these directories will be reloaded on each request in development mode,
-  # unless the directory also appears in load_once_paths.
-  mattr_accessor :load_paths
-  self.load_paths = []
-
-  # The set of directories from which automatically loaded constants are loaded
-  # only once. All directories in this set must also be present in +load_paths+.
-  mattr_accessor :load_once_paths
-  self.load_once_paths = []
-
-  # An array of qualified constant names that have been loaded. Adding a name to
-  # this array will cause it to be unloaded the next time Dependencies are cleared.
-  mattr_accessor :autoloaded_constants
-  self.autoloaded_constants = []
-
-  # An array of constant names that need to be unloaded on every request. Used
-  # to allow arbitrary constants to be marked for unloading.
-  mattr_accessor :explicitly_unloadable_constants
-  self.explicitly_unloadable_constants = []
-
-  # Set to true to enable logging of const_missing and file loads
-  mattr_accessor :log_activity
-  self.log_activity = false
-
-  # An internal stack used to record which constants are loaded by any block.
-  mattr_accessor :constant_watch_stack
-  self.constant_watch_stack = []
-
-  def load?
-    mechanism == :load
-  end
-
-  def depend_on(file_name, swallow_load_errors = false)
-    path = search_for_file(file_name)
-    require_or_load(path || file_name)
-  rescue LoadError
-    raise unless swallow_load_errors
-  end
+module ActiveSupport
+  module Dependencies #:nodoc:
+    extend self
+
+    # Should we turn on Ruby warnings on the first load of dependent files?
+    mattr_accessor :warnings_on_first_load
+    self.warnings_on_first_load = false
+
+    # All files ever loaded.
+    mattr_accessor :history
+    self.history = Set.new
+
+    # All files currently loaded.
+    mattr_accessor :loaded
+    self.loaded = Set.new
+
+    # Should we load files or require them?
+    mattr_accessor :mechanism
+    self.mechanism = :load
+
+    # The set of directories from which we may automatically load files. Files
+    # under these directories will be reloaded on each request in development mode,
+    # unless the directory also appears in load_once_paths.
+    mattr_accessor :load_paths
+    self.load_paths = []
+
+    # The set of directories from which automatically loaded constants are loaded
+    # only once. All directories in this set must also be present in +load_paths+.
+    mattr_accessor :load_once_paths
+    self.load_once_paths = []
+
+    # An array of qualified constant names that have been loaded. Adding a name to
+    # this array will cause it to be unloaded the next time Dependencies are cleared.
+    mattr_accessor :autoloaded_constants
+    self.autoloaded_constants = []
+
+    # An array of constant names that need to be unloaded on every request. Used
+    # to allow arbitrary constants to be marked for unloading.
+    mattr_accessor :explicitly_unloadable_constants
+    self.explicitly_unloadable_constants = []
+
+    # Set to true to enable logging of const_missing and file loads
+    mattr_accessor :log_activity
+    self.log_activity = false
+
+    # An internal stack used to record which constants are loaded by any block.
+    mattr_accessor :constant_watch_stack
+    self.constant_watch_stack = []
+
+    def load?
+      mechanism == :load
+    end
 
-  def associate_with(file_name)
-    depend_on(file_name, true)
-  end
+    def depend_on(file_name, swallow_load_errors = false)
+      path = search_for_file(file_name)
+      require_or_load(path || file_name)
+    rescue LoadError
+      raise unless swallow_load_errors
+    end
 
-  def clear
-    log_call
-    loaded.clear
-    remove_unloadable_constants!
-  end
+    def associate_with(file_name)
+      depend_on(file_name, true)
+    end
 
-  def require_or_load(file_name, const_path = nil)
-    log_call file_name, const_path
-    file_name = $1 if file_name =~ /^(.*)\.rb$/
-    expanded = File.expand_path(file_name)
-    return if loaded.include?(expanded)
+    def clear
+      log_call
+      loaded.clear
+      remove_unloadable_constants!
+    end
 
-    # Record that we've seen this file *before* loading it to avoid an
-    # infinite loop with mutual dependencies.
-    loaded << expanded
+    def require_or_load(file_name, const_path = nil)
+      log_call file_name, const_path
+      file_name = $1 if file_name =~ /^(.*)\.rb$/
+      expanded = File.expand_path(file_name)
+      return if loaded.include?(expanded)
 
-    if load?
-      log "loading #{file_name}"
-      begin
-        # Enable warnings iff this file has not been loaded before and
-        # warnings_on_first_load is set.
-        load_args = ["#{file_name}.rb"]
-        load_args << const_path unless const_path.nil?
+      # Record that we've seen this file *before* loading it to avoid an
+      # infinite loop with mutual dependencies.
+      loaded << expanded
 
-        if !warnings_on_first_load or history.include?(expanded)
-          result = load_file(*load_args)
-        else
-          enable_warnings { result = load_file(*load_args) }
+      if load?
+        log "loading #{file_name}"
+        begin
+          # Enable warnings iff this file has not been loaded before and
+          # warnings_on_first_load is set.
+          load_args = ["#{file_name}.rb"]
+          load_args << const_path unless const_path.nil?
+
+          if !warnings_on_first_load or history.include?(expanded)
+            result = load_file(*load_args)
+          else
+            enable_warnings { result = load_file(*load_args) }
+          end
+        rescue Exception
+          loaded.delete expanded
+          raise
         end
-      rescue Exception
-        loaded.delete expanded
-        raise
+      else
+        log "requiring #{file_name}"
+        result = require file_name
       end
-    else
-      log "requiring #{file_name}"
-      result = require file_name
-    end
 
-    # Record history *after* loading so first load gets warnings.
-    history << expanded
-    return result
-  end
+      # Record history *after* loading so first load gets warnings.
+      history << expanded
+      return result
+    end
 
-  # Is the provided constant path defined?
-  def qualified_const_defined?(path)
-    raise NameError, "#{path.inspect} is not a valid constant name!" unless
-      /^(::)?([A-Z]\w*)(::[A-Z]\w*)*$/ =~ path
+    # Is the provided constant path defined?
+    def qualified_const_defined?(path)
+      raise NameError, "#{path.inspect} is not a valid constant name!" unless
+        /^(::)?([A-Z]\w*)(::[A-Z]\w*)*$/ =~ path
 
-    names = path.to_s.split('::')
-    names.shift if names.first.empty?
+      names = path.to_s.split('::')
+      names.shift if names.first.empty?
 
-    # We can't use defined? because it will invoke const_missing for the parent
-    # of the name we are checking.
-    names.inject(Object) do |mod, name|
-      return false unless uninherited_const_defined?(mod, name)
-      mod.const_get name
+      # We can't use defined? because it will invoke const_missing for the parent
+      # of the name we are checking.
+      names.inject(Object) do |mod, name|
+        return false unless uninherited_const_defined?(mod, name)
+        mod.const_get name
+      end
+      return true
     end
-    return true
-  end
 
-  if Module.method(:const_defined?).arity == 1
-    # Does this module define this constant?
-    # Wrapper to accomodate changing Module#const_defined? in Ruby 1.9
-    def uninherited_const_defined?(mod, const)
-      mod.const_defined?(const)
-    end
-  else
-    def uninherited_const_defined?(mod, const) #:nodoc:
-      mod.const_defined?(const, false)
+    if Module.method(:const_defined?).arity == 1
+      # Does this module define this constant?
+      # Wrapper to accomodate changing Module#const_defined? in Ruby 1.9
+      def uninherited_const_defined?(mod, const)
+        mod.const_defined?(const)
+      end
+    else
+      def uninherited_const_defined?(mod, const) #:nodoc:
+        mod.const_defined?(const, false)
+      end
     end
-  end
-
-  # Given +path+, a filesystem path to a ruby file, return an array of constant
-  # paths which would cause Dependencies to attempt to load this file.
-  def loadable_constants_for_path(path, bases = load_paths)
-    path = $1 if path =~ /\A(.*)\.rb\Z/
-    expanded_path = File.expand_path(path)
-
-    bases.collect do |root|
-      expanded_root = File.expand_path(root)
-      next unless %r{\A#{Regexp.escape(expanded_root)}(/|\\)} =~ expanded_path
-
-      nesting = expanded_path[(expanded_root.size)..-1]
-      nesting = nesting[1..-1] if nesting && nesting[0] == ?/
-      next if nesting.blank?
-
-      [
-        nesting.camelize,
-        # Special case: application.rb might define ApplicationControlller.
-        ('ApplicationController' if nesting == 'application')
-      ]
-    end.flatten.compact.uniq
-  end
 
-  # Search for a file in load_paths matching the provided suffix.
-  def search_for_file(path_suffix)
-    path_suffix = path_suffix + '.rb' unless path_suffix.ends_with? '.rb'
-    load_paths.each do |root|
-      path = File.join(root, path_suffix)
-      return path if File.file? path
+    # Given +path+, a filesystem path to a ruby file, return an array of constant
+    # paths which would cause Dependencies to attempt to load this file.
+    def loadable_constants_for_path(path, bases = load_paths)
+      path = $1 if path =~ /\A(.*)\.rb\Z/
+      expanded_path = File.expand_path(path)
+
+      bases.collect do |root|
+        expanded_root = File.expand_path(root)
+        next unless %r{\A#{Regexp.escape(expanded_root)}(/|\\)} =~ expanded_path
+
+        nesting = expanded_path[(expanded_root.size)..-1]
+        nesting = nesting[1..-1] if nesting && nesting[0] == ?/
+        next if nesting.blank?
+
+        [
+          nesting.camelize,
+          # Special case: application.rb might define ApplicationControlller.
+          ('ApplicationController' if nesting == 'application')
+        ]
+      end.flatten.compact.uniq
     end
-    nil # Gee, I sure wish we had first_match ;-)
-  end
 
-  # Does the provided path_suffix correspond to an autoloadable module?
-  # Instead of returning a boolean, the autoload base for this module is returned.
-  def autoloadable_module?(path_suffix)
-    load_paths.each do |load_path|
-      return load_path if File.directory? File.join(load_path, path_suffix)
+    # Search for a file in load_paths matching the provided suffix.
+    def search_for_file(path_suffix)
+      path_suffix = path_suffix + '.rb' unless path_suffix.ends_with? '.rb'
+      load_paths.each do |root|
+        path = File.join(root, path_suffix)
+        return path if File.file? path
+      end
+      nil # Gee, I sure wish we had first_match ;-)
     end
-    nil
-  end
 
-  def load_once_path?(path)
-    load_once_paths.any? { |base| path.starts_with? base }
-  end
-
-  # Attempt to autoload the provided module name by searching for a directory
-  # matching the expect path suffix. If found, the module is created and assigned
-  # to +into+'s constants with the name +const_name+. Provided that the directory
-  # was loaded from a reloadable base path, it is added to the set of constants
-  # that are to be unloaded.
-  def autoload_module!(into, const_name, qualified_name, path_suffix)
-    return nil unless base_path = autoloadable_module?(path_suffix)
-    mod = Module.new
-    into.const_set const_name, mod
-    autoloaded_constants << qualified_name unless load_once_paths.include?(base_path)
-    return mod
-  end
-
-  # Load the file at the provided path. +const_paths+ is a set of qualified
-  # constant names. When loading the file, Dependencies will watch for the
-  # addition of these constants. Each that is defined will be marked as
-  # autoloaded, and will be removed when Dependencies.clear is next called.
-  #
-  # If the second parameter is left off, then Dependencies will construct a set
-  # of names that the file at +path+ may define. See
-  # +loadable_constants_for_path+ for more details.
-  def load_file(path, const_paths = loadable_constants_for_path(path))
-    log_call path, const_paths
-    const_paths = [const_paths].compact unless const_paths.is_a? Array
-    parent_paths = const_paths.collect { |const_path| /(.*)::[^:]+\Z/ =~ const_path ? $1 : :Object }
-
-    result = nil
-    newly_defined_paths = new_constants_in(*parent_paths) do
-      result = load_without_new_constant_marking path
+    # Does the provided path_suffix correspond to an autoloadable module?
+    # Instead of returning a boolean, the autoload base for this module is returned.
+    def autoloadable_module?(path_suffix)
+      load_paths.each do |load_path|
+        return load_path if File.directory? File.join(load_path, path_suffix)
+      end
+      nil
     end
 
-    autoloaded_constants.concat newly_defined_paths unless load_once_path?(path)
-    autoloaded_constants.uniq!
-    log "loading #{path} defined #{newly_defined_paths * ', '}" unless newly_defined_paths.empty?
-    return result
-  end
+    def load_once_path?(path)
+      load_once_paths.any? { |base| path.starts_with? base }
+    end
 
-  # Return the constant path for the provided parent and constant name.
-  def qualified_name_for(mod, name)
-    mod_name = to_constant_name mod
-    (%w(Object Kernel).include? mod_name) ? name.to_s : "#{mod_name}::#{name}"
-  end
+    # Attempt to autoload the provided module name by searching for a directory
+    # matching the expect path suffix. If found, the module is created and assigned
+    # to +into+'s constants with the name +const_name+. Provided that the directory
+    # was loaded from a reloadable base path, it is added to the set of constants
+    # that are to be unloaded.
+    def autoload_module!(into, const_name, qualified_name, path_suffix)
+      return nil unless base_path = autoloadable_module?(path_suffix)
+      mod = Module.new
+      into.const_set const_name, mod
+      autoloaded_constants << qualified_name unless load_once_paths.include?(base_path)
+      return mod
+    end
 
-  # Load the constant named +const_name+ which is missing from +from_mod+. If
-  # it is not possible to load the constant into from_mod, try its parent module
-  # using const_missing.
-  def load_missing_constant(from_mod, const_name)
-    log_call from_mod, const_name
-    if from_mod == Kernel
-      if ::Object.const_defined?(const_name)
-        log "Returning Object::#{const_name} for Kernel::#{const_name}"
-        return ::Object.const_get(const_name)
-      else
-        log "Substituting Object for Kernel"
-        from_mod = Object
+    # Load the file at the provided path. +const_paths+ is a set of qualified
+    # constant names. When loading the file, Dependencies will watch for the
+    # addition of these constants. Each that is defined will be marked as
+    # autoloaded, and will be removed when Dependencies.clear is next called.
+    #
+    # If the second parameter is left off, then Dependencies will construct a set
+    # of names that the file at +path+ may define. See
+    # +loadable_constants_for_path+ for more details.
+    def load_file(path, const_paths = loadable_constants_for_path(path))
+      log_call path, const_paths
+      const_paths = [const_paths].compact unless const_paths.is_a? Array
+      parent_paths = const_paths.collect { |const_path| /(.*)::[^:]+\Z/ =~ const_path ? $1 : :Object }
+
+      result = nil
+      newly_defined_paths = new_constants_in(*parent_paths) do
+        result = load_without_new_constant_marking path
       end
-    end
 
-    # If we have an anonymous module, all we can do is attempt to load from Object.
-    from_mod = Object if from_mod.name.blank?
+      autoloaded_constants.concat newly_defined_paths unless load_once_path?(path)
+      autoloaded_constants.uniq!
+      log "loading #{path} defined #{newly_defined_paths * ', '}" unless newly_defined_paths.empty?
+      return result
+    end
 
-    unless qualified_const_defined?(from_mod.name) && from_mod.name.constantize.object_id == from_mod.object_id
-      raise ArgumentError, "A copy of #{from_mod} has been removed from the module tree but is still active!"
+    # Return the constant path for the provided parent and constant name.
+    def qualified_name_for(mod, name)
+      mod_name = to_constant_name mod
+      (%w(Object Kernel).include? mod_name) ? name.to_s : "#{mod_name}::#{name}"
     end
 
-    raise ArgumentError, "#{from_mod} is not missing constant #{const_name}!" if uninherited_const_defined?(from_mod, const_name)
+    # Load the constant named +const_name+ which is missing from +from_mod+. If
+    # it is not possible to load the constant into from_mod, try its parent module
+    # using const_missing.
+    def load_missing_constant(from_mod, const_name)
+      log_call from_mod, const_name
+      if from_mod == Kernel
+        if ::Object.const_defined?(const_name)
+          log "Returning Object::#{const_name} for Kernel::#{const_name}"
+          return ::Object.const_get(const_name)
+        else
+          log "Substituting Object for Kernel"
+          from_mod = Object
+        end
+      end
 
-    qualified_name = qualified_name_for from_mod, const_name
-    path_suffix = qualified_name.underscore
-    name_error = NameError.new("uninitialized constant #{qualified_name}")
+      # If we have an anonymous module, all we can do is attempt to load from Object.
+      from_mod = Object if from_mod.name.blank?
 
-    file_path = search_for_file(path_suffix)
-    if file_path && ! loaded.include?(File.expand_path(file_path)) # We found a matching file to load
-      require_or_load file_path
-      raise LoadError, "Expected #{file_path} to define #{qualified_name}" unless uninherited_const_defined?(from_mod, const_name)
-      return from_mod.const_get(const_name)
-    elsif mod = autoload_module!(from_mod, const_name, qualified_name, path_suffix)
-      return mod
-    elsif (parent = from_mod.parent) && parent != from_mod &&
-          ! from_mod.parents.any? { |p| uninherited_const_defined?(p, const_name) }
-      # If our parents do not have a constant named +const_name+ then we are free
-      # to attempt to load upwards. If they do have such a constant, then this
-      # const_missing must be due to from_mod::const_name, which should not
-      # return constants from from_mod's parents.
-      begin
-        return parent.const_missing(const_name)
-      rescue NameError => e
-        raise unless e.missing_name? qualified_name_for(parent, const_name)
+      unless qualified_const_defined?(from_mod.name) && from_mod.name.constantize.object_id == from_mod.object_id
+        raise ArgumentError, "A copy of #{from_mod} has been removed from the module tree but is still active!"
+      end
+
+      raise ArgumentError, "#{from_mod} is not missing constant #{const_name}!" if uninherited_const_defined?(from_mod, const_name)
+
+      qualified_name = qualified_name_for from_mod, const_name
+      path_suffix = qualified_name.underscore
+      name_error = NameError.new("uninitialized constant #{qualified_name}")
+
+      file_path = search_for_file(path_suffix)
+      if file_path && ! loaded.include?(File.expand_path(file_path)) # We found a matching file to load
+        require_or_load file_path
+        raise LoadError, "Expected #{file_path} to define #{qualified_name}" unless uninherited_const_defined?(from_mod, const_name)
+        return from_mod.const_get(const_name)
+      elsif mod = autoload_module!(from_mod, const_name, qualified_name, path_suffix)
+        return mod
+      elsif (parent = from_mod.parent) && parent != from_mod &&
+            ! from_mod.parents.any? { |p| uninherited_const_defined?(p, const_name) }
+        # If our parents do not have a constant named +const_name+ then we are free
+        # to attempt to load upwards. If they do have such a constant, then this
+        # const_missing must be due to from_mod::const_name, which should not
+        # return constants from from_mod's parents.
+        begin
+          return parent.const_missing(const_name)
+        rescue NameError => e
+          raise unless e.missing_name? qualified_name_for(parent, const_name)
+          raise name_error
+        end
+      else
         raise name_error
       end
-    else
-      raise name_error
     end
-  end
 
-  # Remove the constants that have been autoloaded, and those that have been
-  # marked for unloading.
-  def remove_unloadable_constants!
-    autoloaded_constants.each { |const| remove_constant const }
-    autoloaded_constants.clear
-    explicitly_unloadable_constants.each { |const| remove_constant const }
-  end
+    # Remove the constants that have been autoloaded, and those that have been
+    # marked for unloading.
+    def remove_unloadable_constants!
+      autoloaded_constants.each { |const| remove_constant const }
+      autoloaded_constants.clear
+      explicitly_unloadable_constants.each { |const| remove_constant const }
+    end
 
-  # Determine if the given constant has been automatically loaded.
-  def autoloaded?(desc)
-    # No name => anonymous module.
-    return false if desc.is_a?(Module) && desc.name.blank?
-    name = to_constant_name desc
-    return false unless qualified_const_defined? name
-    return autoloaded_constants.include?(name)
-  end
+    # Determine if the given constant has been automatically loaded.
+    def autoloaded?(desc)
+      # No name => anonymous module.
+      return false if desc.is_a?(Module) && desc.name.blank?
+      name = to_constant_name desc
+      return false unless qualified_const_defined? name
+      return autoloaded_constants.include?(name)
+    end
 
-  # Will the provided constant descriptor be unloaded?
-  def will_unload?(const_desc)
-    autoloaded?(desc) ||
-      explicitly_unloadable_constants.include?(to_constant_name(const_desc))
-  end
+    # Will the provided constant descriptor be unloaded?
+    def will_unload?(const_desc)
+      autoloaded?(desc) ||
+        explicitly_unloadable_constants.include?(to_constant_name(const_desc))
+    end
 
-  # Mark the provided constant name for unloading. This constant will be
-  # unloaded on each request, not just the next one.
-  def mark_for_unload(const_desc)
-    name = to_constant_name const_desc
-    if explicitly_unloadable_constants.include? name
-      return false
-    else
-      explicitly_unloadable_constants << name
-      return true
+    # Mark the provided constant name for unloading. This constant will be
+    # unloaded on each request, not just the next one.
+    def mark_for_unload(const_desc)
+      name = to_constant_name const_desc
+      if explicitly_unloadable_constants.include? name
+        return false
+      else
+        explicitly_unloadable_constants << name
+        return true
+      end
     end
-  end
 
-  # Run the provided block and detect the new constants that were loaded during
-  # its execution. Constants may only be regarded as 'new' once -- so if the
-  # block calls +new_constants_in+ again, then the constants defined within the
-  # inner call will not be reported in this one.
-  #
-  # If the provided block does not run to completion, and instead raises an
-  # exception, any new constants are regarded as being only partially defined
-  # and will be removed immediately.
-  def new_constants_in(*descs)
-    log_call(*descs)
-
-    # Build the watch frames. Each frame is a tuple of
-    #   [module_name_as_string, constants_defined_elsewhere]
-    watch_frames = descs.collect do |desc|
-      if desc.is_a? Module
-        mod_name = desc.name
-        initial_constants = desc.local_constant_names
-      elsif desc.is_a?(String) || desc.is_a?(Symbol)
-        mod_name = desc.to_s
-
-        # Handle the case where the module has yet to be defined.
-        initial_constants = if qualified_const_defined?(mod_name)
-          mod_name.constantize.local_constant_names
+    # Run the provided block and detect the new constants that were loaded during
+    # its execution. Constants may only be regarded as 'new' once -- so if the
+    # block calls +new_constants_in+ again, then the constants defined within the
+    # inner call will not be reported in this one.
+    #
+    # If the provided block does not run to completion, and instead raises an
+    # exception, any new constants are regarded as being only partially defined
+    # and will be removed immediately.
+    def new_constants_in(*descs)
+      log_call(*descs)
+
+      # Build the watch frames. Each frame is a tuple of
+      #   [module_name_as_string, constants_defined_elsewhere]
+      watch_frames = descs.collect do |desc|
+        if desc.is_a? Module
+          mod_name = desc.name
+          initial_constants = desc.local_constant_names
+        elsif desc.is_a?(String) || desc.is_a?(Symbol)
+          mod_name = desc.to_s
+
+          # Handle the case where the module has yet to be defined.
+          initial_constants = if qualified_const_defined?(mod_name)
+            mod_name.constantize.local_constant_names
+          else
+           []
+          end
         else
-         []
+          raise Argument, "#{desc.inspect} does not describe a module!"
         end
-      else
-        raise Argument, "#{desc.inspect} does not describe a module!"
-      end
 
-      [mod_name, initial_constants]
-    end
+        [mod_name, initial_constants]
+      end
 
-    constant_watch_stack.concat watch_frames
+      constant_watch_stack.concat watch_frames
 
-    aborting = true
-    begin
-      yield # Now yield to the code that is to define new constants.
-      aborting = false
-    ensure
-      # Find the new constants.
-      new_constants = watch_frames.collect do |mod_name, prior_constants|
-        # Module still doesn't exist? Treat it as if it has no constants.
-        next [] unless qualified_const_defined?(mod_name)
-
-        mod = mod_name.constantize
-        next [] unless mod.is_a? Module
-        new_constants = mod.local_constant_names - prior_constants
-
-        # Make sure no other frames takes credit for these constants.
-        constant_watch_stack.each do |frame_name, constants|
-          constants.concat new_constants if frame_name == mod_name
+      aborting = true
+      begin
+        yield # Now yield to the code that is to define new constants.
+        aborting = false
+      ensure
+        # Find the new constants.
+        new_constants = watch_frames.collect do |mod_name, prior_constants|
+          # Module still doesn't exist? Treat it as if it has no constants.
+          next [] unless qualified_const_defined?(mod_name)
+
+          mod = mod_name.constantize
+          next [] unless mod.is_a? Module
+          new_constants = mod.local_constant_names - prior_constants
+
+          # Make sure no other frames takes credit for these constants.
+          constant_watch_stack.each do |frame_name, constants|
+            constants.concat new_constants if frame_name == mod_name
+          end
+
+          new_constants.collect do |suffix|
+            mod_name == "Object" ? suffix : "#{mod_name}::#{suffix}"
+          end
+        end.flatten
+
+        log "New constants: #{new_constants * ', '}"
+
+        if aborting
+          log "Error during loading, removing partially loaded constants "
+          new_constants.each { |name| remove_constant name }
+          new_constants.clear
         end
+      end
 
-        new_constants.collect do |suffix|
-          mod_name == "Object" ? suffix : "#{mod_name}::#{suffix}"
+      return new_constants
+    ensure
+      # Remove the stack frames that we added.
+      if defined?(watch_frames) && ! watch_frames.blank?
+        frame_ids = watch_frames.collect(&:object_id)
+        constant_watch_stack.delete_if do |watch_frame|
+          frame_ids.include? watch_frame.object_id
         end
-      end.flatten
-
-      log "New constants: #{new_constants * ', '}"
-
-      if aborting
-        log "Error during loading, removing partially loaded constants "
-        new_constants.each { |name| remove_constant name }
-        new_constants.clear
       end
     end
 
-    return new_constants
-  ensure
-    # Remove the stack frames that we added.
-    if defined?(watch_frames) && ! watch_frames.blank?
-      frame_ids = watch_frames.collect(&:object_id)
-      constant_watch_stack.delete_if do |watch_frame|
-        frame_ids.include? watch_frame.object_id
+    class LoadingModule #:nodoc:
+      # Old style environment.rb referenced this method directly.  Please note, it doesn't
+      # actually *do* anything any more.
+      def self.root(*args)
+        if defined?(RAILS_DEFAULT_LOGGER)
+          RAILS_DEFAULT_LOGGER.warn "Your environment.rb uses the old syntax, it may not continue to work in future releases."
+          RAILS_DEFAULT_LOGGER.warn "For upgrade instructions please see: http://manuals.rubyonrails.com/read/book/19"
+        end
       end
     end
-  end
 
-  class LoadingModule #:nodoc:
-    # Old style environment.rb referenced this method directly.  Please note, it doesn't
-    # actually *do* anything any more.
-    def self.root(*args)
-      if defined?(RAILS_DEFAULT_LOGGER)
-        RAILS_DEFAULT_LOGGER.warn "Your environment.rb uses the old syntax, it may not continue to work in future releases."
-        RAILS_DEFAULT_LOGGER.warn "For upgrade instructions please see: http://manuals.rubyonrails.com/read/book/19"
+    # Convert the provided const desc to a qualified constant name (as a string).
+    # A module, class, symbol, or string may be provided.
+    def to_constant_name(desc) #:nodoc:
+      name = case desc
+        when String then desc.starts_with?('::') ? desc[2..-1] : desc
+        when Symbol then desc.to_s
+        when Module
+          raise ArgumentError, "Anonymous modules have no name to be referenced by" if desc.name.blank?
+          desc.name
+        else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
       end
     end
-  end
 
-  # Convert the provided const desc to a qualified constant name (as a string).
-  # A module, class, symbol, or string may be provided.
-  def to_constant_name(desc) #:nodoc:
-    name = case desc
-      when String then desc.starts_with?('::') ? desc[2..-1] : desc
-      when Symbol then desc.to_s
-      when Module
-        raise ArgumentError, "Anonymous modules have no name to be referenced by" if desc.name.blank?
-        desc.name
-      else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
-    end
-  end
+    def remove_constant(const) #:nodoc:
+      return false unless qualified_const_defined? const
 
-  def remove_constant(const) #:nodoc:
-    return false unless qualified_const_defined? const
+      const = $1 if /\A::(.*)\Z/ =~ const.to_s
+      names = const.to_s.split('::')
+      if names.size == 1 # It's under Object
+        parent = Object
+      else
+        parent = (names[0..-2] * '::').constantize
+      end
 
-    const = $1 if /\A::(.*)\Z/ =~ const.to_s
-    names = const.to_s.split('::')
-    if names.size == 1 # It's under Object
-      parent = Object
-    else
-      parent = (names[0..-2] * '::').constantize
+      log "removing constant #{const}"
+      parent.instance_eval { remove_const names.last }
+      return true
     end
 
-    log "removing constant #{const}"
-    parent.instance_eval { remove_const names.last }
-    return true
-  end
-
-protected
-  def log_call(*args)
-    if defined?(RAILS_DEFAULT_LOGGER) && RAILS_DEFAULT_LOGGER && log_activity
-      arg_str = args.collect(&:inspect) * ', '
-      /in `([a-z_\?\!]+)'/ =~ caller(1).first
-      selector = $1 || '<unknown>'
-      log "called #{selector}(#{arg_str})"
+  protected
+    def log_call(*args)
+      if defined?(RAILS_DEFAULT_LOGGER) && RAILS_DEFAULT_LOGGER && log_activity
+        arg_str = args.collect(&:inspect) * ', '
+        /in `([a-z_\?\!]+)'/ =~ caller(1).first
+        selector = $1 || '<unknown>'
+        log "called #{selector}(#{arg_str})"
+      end
     end
-  end
 
-  def log(msg)
-    if defined?(RAILS_DEFAULT_LOGGER) && RAILS_DEFAULT_LOGGER && log_activity
-      RAILS_DEFAULT_LOGGER.debug "Dependencies: #{msg}"
+    def log(msg)
+      if defined?(RAILS_DEFAULT_LOGGER) && RAILS_DEFAULT_LOGGER && log_activity
+        RAILS_DEFAULT_LOGGER.debug "Dependencies: #{msg}"
+      end
     end
   end
-
 end
 
+
+# TODO: move to core_ext
+
 Object.instance_eval do
-  define_method(:require_or_load)     { |file_name| Dependencies.require_or_load(file_name) } unless Object.respond_to?(:require_or_load)
-  define_method(:require_dependency)  { |file_name| Dependencies.depend_on(file_name) }       unless Object.respond_to?(:require_dependency)
-  define_method(:require_association) { |file_name| Dependencies.associate_with(file_name) }  unless Object.respond_to?(:require_association)
+  define_method(:require_or_load)     { |file_name| ActiveSupport::Dependencies.require_or_load(file_name) } unless Object.respond_to?(:require_or_load)
+  define_method(:require_dependency)  { |file_name| ActiveSupport::Dependencies.depend_on(file_name) }       unless Object.respond_to?(:require_dependency)
+  define_method(:require_association) { |file_name| ActiveSupport::Dependencies.associate_with(file_name) }  unless Object.respond_to?(:require_association)
 end
 
 class Module #:nodoc:
@@ -463,7 +467,7 @@ class Module #:nodoc:
   # Use const_missing to autoload associations so we don't have to
   # require_association when using single-table inheritance.
   def const_missing(class_id)
-    Dependencies.load_missing_constant self, class_id
+    ActiveSupport::Dependencies.load_missing_constant self, class_id
   end
 
   def unloadable(const_desc = self)
@@ -479,15 +483,15 @@ class Class
     else
       begin
         begin
-          Dependencies.load_missing_constant self, const_name
+          ActiveSupport::Dependencies.load_missing_constant self, const_name
         rescue NameError
           parent.send :const_missing, const_name
         end
       rescue NameError => e
         # Make sure that the name we are missing is the one that caused the error
-        parent_qualified_name = Dependencies.qualified_name_for parent, const_name
+        parent_qualified_name = ActiveSupport::Dependencies.qualified_name_for parent, const_name
         raise unless e.missing_name? parent_qualified_name
-        qualified_name = Dependencies.qualified_name_for self, const_name
+        qualified_name = ActiveSupport::Dependencies.qualified_name_for self, const_name
         raise NameError.new("uninitialized constant #{qualified_name}").copy_blame!(e)
       end
     end
@@ -498,14 +502,14 @@ class Object
   alias_method :load_without_new_constant_marking, :load
 
   def load(file, *extras) #:nodoc:
-    Dependencies.new_constants_in(Object) { super }
+    ActiveSupport::Dependencies.new_constants_in(Object) { super }
   rescue Exception => exception  # errors from loading file
     exception.blame_file! file
     raise
   end
 
   def require(file, *extras) #:nodoc:
-    Dependencies.new_constants_in(Object) { super }
+    ActiveSupport::Dependencies.new_constants_in(Object) { super }
   rescue Exception => exception  # errors from required file
     exception.blame_file! file
     raise
@@ -525,7 +529,7 @@ class Object
   # Returns true if the constant was not previously marked for unloading, false
   # otherwise.
   def unloadable(const_desc)
-    Dependencies.mark_for_unload const_desc
+    ActiveSupport::Dependencies.mark_for_unload const_desc
   end
 end
 
diff --git a/activesupport/lib/active_support/deprecation.rb b/activesupport/lib/active_support/deprecation.rb
index 6aa379b..39afa0f 100644
--- a/activesupport/lib/active_support/deprecation.rb
+++ b/activesupport/lib/active_support/deprecation.rb
@@ -144,17 +144,11 @@ module ActiveSupport
         end
     end
 
-    # Stand-in for @request, @attributes, @params, etc which emits deprecation
-    # warnings on any method call (except #inspect).
-    class DeprecatedInstanceVariableProxy #:nodoc:
+    class DeprecationProxy #:nodoc:
       silence_warnings do
         instance_methods.each { |m| undef_method m unless m =~ /^__/ }
       end
 
-      def initialize(instance, method, var = "@#{method}")
-        @instance, @method, @var = instance, method, var
-      end
-
       # Don't give a deprecation warning on inspect since test/unit and error
       # logs rely on it for diagnostics.
       def inspect
@@ -166,7 +160,16 @@ module ActiveSupport
           warn caller, called, args
           target.__send__(called, *args, &block)
         end
+    end
 
+    # Stand-in for @request, @attributes, @params, etc which emits deprecation
+    # warnings on any method call (except #inspect).
+    class DeprecatedInstanceVariableProxy < DeprecationProxy #:nodoc:
+      def initialize(instance, method, var = "@#{method}")
+        @instance, @method, @var = instance, method, var
+      end
+
+      private
         def target
           @instance.__send__(@method)
         end
@@ -176,6 +179,21 @@ module ActiveSupport
         end
     end
 
+    class DeprecatedConstantProxy < DeprecationProxy #:nodoc:
+      def initialize(old_const, new_const)
+        @old_const = old_const
+        @new_const = new_const
+      end
+
+      private
+        def target
+          @new_const.to_s.constantize
+        end
+
+        def warn(callstack, called, args)
+          ActiveSupport::Deprecation.warn("#{@old_const} is deprecated! Use #{@new_const} instead.", callstack)
+        end
+    end
   end
 end
 
diff --git a/activesupport/lib/active_support/inflections.rb b/activesupport/lib/active_support/inflections.rb
index 967722c..b6d2769 100644
--- a/activesupport/lib/active_support/inflections.rb
+++ b/activesupport/lib/active_support/inflections.rb
@@ -1,53 +1,55 @@
-Inflector.inflections do |inflect|
-  inflect.plural(/$/, 's')
-  inflect.plural(/s$/i, 's')
-  inflect.plural(/(ax|test)is$/i, '\1es')
-  inflect.plural(/(octop|vir)us$/i, '\1i')
-  inflect.plural(/(alias|status)$/i, '\1es')
-  inflect.plural(/(bu)s$/i, '\1ses')
-  inflect.plural(/(buffal|tomat)o$/i, '\1oes')
-  inflect.plural(/([ti])um$/i, '\1a')
-  inflect.plural(/sis$/i, 'ses')
-  inflect.plural(/(?:([^f])fe|([lr])f)$/i, '\1\2ves')
-  inflect.plural(/(hive)$/i, '\1s')
-  inflect.plural(/([^aeiouy]|qu)y$/i, '\1ies')
-  inflect.plural(/(x|ch|ss|sh)$/i, '\1es')
-  inflect.plural(/(matr|vert|ind)(?:ix|ex)$/i, '\1ices')
-  inflect.plural(/([m|l])ouse$/i, '\1ice')
-  inflect.plural(/^(ox)$/i, '\1en')
-  inflect.plural(/(quiz)$/i, '\1zes')
+module ActiveSupport
+  Inflector.inflections do |inflect|
+    inflect.plural(/$/, 's')
+    inflect.plural(/s$/i, 's')
+    inflect.plural(/(ax|test)is$/i, '\1es')
+    inflect.plural(/(octop|vir)us$/i, '\1i')
+    inflect.plural(/(alias|status)$/i, '\1es')
+    inflect.plural(/(bu)s$/i, '\1ses')
+    inflect.plural(/(buffal|tomat)o$/i, '\1oes')
+    inflect.plural(/([ti])um$/i, '\1a')
+    inflect.plural(/sis$/i, 'ses')
+    inflect.plural(/(?:([^f])fe|([lr])f)$/i, '\1\2ves')
+    inflect.plural(/(hive)$/i, '\1s')
+    inflect.plural(/([^aeiouy]|qu)y$/i, '\1ies')
+    inflect.plural(/(x|ch|ss|sh)$/i, '\1es')
+    inflect.plural(/(matr|vert|ind)(?:ix|ex)$/i, '\1ices')
+    inflect.plural(/([m|l])ouse$/i, '\1ice')
+    inflect.plural(/^(ox)$/i, '\1en')
+    inflect.plural(/(quiz)$/i, '\1zes')
 
-  inflect.singular(/s$/i, '')
-  inflect.singular(/(n)ews$/i, '\1ews')
-  inflect.singular(/([ti])a$/i, '\1um')
-  inflect.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '\1\2sis')
-  inflect.singular(/(^analy)ses$/i, '\1sis')
-  inflect.singular(/([^f])ves$/i, '\1fe')
-  inflect.singular(/(hive)s$/i, '\1')
-  inflect.singular(/(tive)s$/i, '\1')
-  inflect.singular(/([lr])ves$/i, '\1f')
-  inflect.singular(/([^aeiouy]|qu)ies$/i, '\1y')
-  inflect.singular(/(s)eries$/i, '\1eries')
-  inflect.singular(/(m)ovies$/i, '\1ovie')
-  inflect.singular(/(x|ch|ss|sh)es$/i, '\1')
-  inflect.singular(/([m|l])ice$/i, '\1ouse')
-  inflect.singular(/(bus)es$/i, '\1')
-  inflect.singular(/(o)es$/i, '\1')
-  inflect.singular(/(shoe)s$/i, '\1')
-  inflect.singular(/(cris|ax|test)es$/i, '\1is')
-  inflect.singular(/(octop|vir)i$/i, '\1us')
-  inflect.singular(/(alias|status)es$/i, '\1')
-  inflect.singular(/^(ox)en/i, '\1')
-  inflect.singular(/(vert|ind)ices$/i, '\1ex')
-  inflect.singular(/(matr)ices$/i, '\1ix')
-  inflect.singular(/(quiz)zes$/i, '\1')
+    inflect.singular(/s$/i, '')
+    inflect.singular(/(n)ews$/i, '\1ews')
+    inflect.singular(/([ti])a$/i, '\1um')
+    inflect.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '\1\2sis')
+    inflect.singular(/(^analy)ses$/i, '\1sis')
+    inflect.singular(/([^f])ves$/i, '\1fe')
+    inflect.singular(/(hive)s$/i, '\1')
+    inflect.singular(/(tive)s$/i, '\1')
+    inflect.singular(/([lr])ves$/i, '\1f')
+    inflect.singular(/([^aeiouy]|qu)ies$/i, '\1y')
+    inflect.singular(/(s)eries$/i, '\1eries')
+    inflect.singular(/(m)ovies$/i, '\1ovie')
+    inflect.singular(/(x|ch|ss|sh)es$/i, '\1')
+    inflect.singular(/([m|l])ice$/i, '\1ouse')
+    inflect.singular(/(bus)es$/i, '\1')
+    inflect.singular(/(o)es$/i, '\1')
+    inflect.singular(/(shoe)s$/i, '\1')
+    inflect.singular(/(cris|ax|test)es$/i, '\1is')
+    inflect.singular(/(octop|vir)i$/i, '\1us')
+    inflect.singular(/(alias|status)es$/i, '\1')
+    inflect.singular(/^(ox)en/i, '\1')
+    inflect.singular(/(vert|ind)ices$/i, '\1ex')
+    inflect.singular(/(matr)ices$/i, '\1ix')
+    inflect.singular(/(quiz)zes$/i, '\1')
 
-  inflect.irregular('person', 'people')
-  inflect.irregular('man', 'men')
-  inflect.irregular('child', 'children')
-  inflect.irregular('sex', 'sexes')
-  inflect.irregular('move', 'moves')
-  inflect.irregular('cow', 'kine')
+    inflect.irregular('person', 'people')
+    inflect.irregular('man', 'men')
+    inflect.irregular('child', 'children')
+    inflect.irregular('sex', 'sexes')
+    inflect.irregular('move', 'moves')
+    inflect.irregular('cow', 'kine')
 
-  inflect.uncountable(%w(equipment information rice money species series fish sheep))
+    inflect.uncountable(%w(equipment information rice money species series fish sheep))
+  end
 end
diff --git a/activesupport/lib/active_support/inflector.rb b/activesupport/lib/active_support/inflector.rb
index 0fd4432..e536fd5 100644
--- a/activesupport/lib/active_support/inflector.rb
+++ b/activesupport/lib/active_support/inflector.rb
@@ -1,305 +1,307 @@
 require 'singleton'
 
-# The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,
-# and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept
-# in inflections.rb.
-#
-# The Rails core team has stated patches for the inflections library will not be accepted
-# in order to avoid breaking legacy applications which may be relying on errant inflections.
-# If you discover an incorrect inflection and require it for your application, you'll need
-# to correct it yourself (explained below).
-module Inflector
-  # A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional
-  # inflection rules. Examples:
+module ActiveSupport
+  # The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,
+  # and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept
+  # in inflections.rb.
   #
-  #   Inflector.inflections do |inflect|
-  #     inflect.plural /^(ox)$/i, '\1\2en'
-  #     inflect.singular /^(ox)en/i, '\1'
-  #
-  #     inflect.irregular 'octopus', 'octopi'
-  #
-  #     inflect.uncountable "equipment"
-  #   end
-  #
-  # New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the
-  # pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may
-  # already have been loaded.
-  class Inflections
-    include Singleton
+  # The Rails core team has stated patches for the inflections library will not be accepted
+  # in order to avoid breaking legacy applications which may be relying on errant inflections.
+  # If you discover an incorrect inflection and require it for your application, you'll need
+  # to correct it yourself (explained below).
+  module Inflector
+    # A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional
+    # inflection rules. Examples:
+    #
+    #   Inflector.inflections do |inflect|
+    #     inflect.plural /^(ox)$/i, '\1\2en'
+    #     inflect.singular /^(ox)en/i, '\1'
+    #
+    #     inflect.irregular 'octopus', 'octopi'
+    #
+    #     inflect.uncountable "equipment"
+    #   end
+    #
+    # New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the
+    # pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may
+    # already have been loaded.
+    class Inflections
+      include Singleton
 
-    attr_reader :plurals, :singulars, :uncountables
+      attr_reader :plurals, :singulars, :uncountables
 
-    def initialize
-      @plurals, @singulars, @uncountables = [], [], []
-    end
+      def initialize
+        @plurals, @singulars, @uncountables = [], [], []
+      end
 
-    # Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.
-    # The replacement should always be a string that may include references to the matched data from the rule.
-    def plural(rule, replacement)
-      @plurals.insert(0, [rule, replacement])
-    end
+      # Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.
+      # The replacement should always be a string that may include references to the matched data from the rule.
+      def plural(rule, replacement)
+        @plurals.insert(0, [rule, replacement])
+      end
+
+      # Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.
+      # The replacement should always be a string that may include references to the matched data from the rule.
+      def singular(rule, replacement)
+        @singulars.insert(0, [rule, replacement])
+      end
+
+      # Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used
+      # for strings, not regular expressions. You simply pass the irregular in singular and plural form.
+      #
+      # Examples:
+      #   irregular 'octopus', 'octopi'
+      #   irregular 'person', 'people'
+      def irregular(singular, plural)
+        if singular[0,1].upcase == plural[0,1].upcase
+          plural(Regexp.new("(#{singular[0,1]})#{singular[1..-1]}$", "i"), '\1' + plural[1..-1])
+          singular(Regexp.new("(#{plural[0,1]})#{plural[1..-1]}$", "i"), '\1' + singular[1..-1])
+        else
+          plural(Regexp.new("#{singular[0,1].upcase}(?i)#{singular[1..-1]}$"), plural[0,1].upcase + plural[1..-1])
+          plural(Regexp.new("#{singular[0,1].downcase}(?i)#{singular[1..-1]}$"), plural[0,1].downcase + plural[1..-1])
+          singular(Regexp.new("#{plural[0,1].upcase}(?i)#{plural[1..-1]}$"), singular[0,1].upcase + singular[1..-1])
+          singular(Regexp.new("#{plural[0,1].downcase}(?i)#{plural[1..-1]}$"), singular[0,1].downcase + singular[1..-1])
+        end
+      end
+
+      # Add uncountable words that shouldn't be attempted inflected.
+      #
+      # Examples:
+      #   uncountable "money"
+      #   uncountable "money", "information"
+      #   uncountable %w( money information rice )
+      def uncountable(*words)
+        (@uncountables << words).flatten!
+      end
 
-    # Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.
-    # The replacement should always be a string that may include references to the matched data from the rule.
-    def singular(rule, replacement)
-      @singulars.insert(0, [rule, replacement])
+      # Clears the loaded inflections within a given scope (default is <tt>:all</tt>).
+      # Give the scope as a symbol of the inflection type, the options are: <tt>:plurals</tt>,
+      # <tt>:singulars</tt>, <tt>:uncountables</tt>.
+      #
+      # Examples:
+      #   clear :all
+      #   clear :plurals
+      def clear(scope = :all)
+        case scope
+          when :all
+            @plurals, @singulars, @uncountables = [], [], []
+          else
+            instance_variable_set "@#{scope}", []
+        end
+      end
     end
 
-    # Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used
-    # for strings, not regular expressions. You simply pass the irregular in singular and plural form.
+    extend self
+
+    # Yields a singleton instance of Inflector::Inflections so you can specify additional
+    # inflector rules.
     #
-    # Examples:
-    #   irregular 'octopus', 'octopi'
-    #   irregular 'person', 'people'
-    def irregular(singular, plural)
-      if singular[0,1].upcase == plural[0,1].upcase
-        plural(Regexp.new("(#{singular[0,1]})#{singular[1..-1]}$", "i"), '\1' + plural[1..-1])
-        singular(Regexp.new("(#{plural[0,1]})#{plural[1..-1]}$", "i"), '\1' + singular[1..-1])
+    # Example:
+    #   Inflector.inflections do |inflect|
+    #     inflect.uncountable "rails"
+    #   end
+    def inflections
+      if block_given?
+        yield Inflections.instance
       else
-        plural(Regexp.new("#{singular[0,1].upcase}(?i)#{singular[1..-1]}$"), plural[0,1].upcase + plural[1..-1])
-        plural(Regexp.new("#{singular[0,1].downcase}(?i)#{singular[1..-1]}$"), plural[0,1].downcase + plural[1..-1])
-        singular(Regexp.new("#{plural[0,1].upcase}(?i)#{plural[1..-1]}$"), singular[0,1].upcase + singular[1..-1])
-        singular(Regexp.new("#{plural[0,1].downcase}(?i)#{plural[1..-1]}$"), singular[0,1].downcase + singular[1..-1])       
+        Inflections.instance
       end
     end
 
-    # Add uncountable words that shouldn't be attempted inflected.
+    # Returns the plural form of the word in the string.
     #
-    # Examples:
-    #   uncountable "money"
-    #   uncountable "money", "information"
-    #   uncountable %w( money information rice )
-    def uncountable(*words)
-      (@uncountables << words).flatten!
-    end
+    # Examples
+    #   "post".pluralize #=> "posts"
+    #   "octopus".pluralize #=> "octopi"
+    #   "sheep".pluralize #=> "sheep"
+    #   "words".pluralize #=> "words"
+    #   "the blue mailman".pluralize #=> "the blue mailmen"
+    #   "CamelOctopus".pluralize #=> "CamelOctopi"
+    def pluralize(word)
+      result = word.to_s.dup
 
-    # Clears the loaded inflections within a given scope (default is <tt>:all</tt>).
-    # Give the scope as a symbol of the inflection type, the options are: <tt>:plurals</tt>,
-    # <tt>:singulars</tt>, <tt>:uncountables</tt>.
-    #
-    # Examples:
-    #   clear :all
-    #   clear :plurals
-    def clear(scope = :all)
-      case scope
-        when :all
-          @plurals, @singulars, @uncountables = [], [], []
-        else
-          instance_variable_set "@#{scope}", []
+      if word.empty? || inflections.uncountables.include?(result.downcase)
+        result
+      else
+        inflections.plurals.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }
+        result
       end
     end
-  end
 
-  extend self
+    # The reverse of pluralize, returns the singular form of a word in a string.
+    #
+    # Examples
+    #   "posts".singularize #=> "post"
+    #   "octopi".singularize #=> "octopus"
+    #   "sheep".singluarize #=> "sheep"
+    #   "word".singluarize #=> "word"
+    #   "the blue mailmen".singularize #=> "the blue mailman"
+    #   "CamelOctopi".singularize #=> "CamelOctopus"
+    def singularize(word)
+      result = word.to_s.dup
 
-  # Yields a singleton instance of Inflector::Inflections so you can specify additional
-  # inflector rules.
-  #
-  # Example:
-  #   Inflector.inflections do |inflect|
-  #     inflect.uncountable "rails"
-  #   end
-  def inflections
-    if block_given?
-      yield Inflections.instance
-    else
-      Inflections.instance
+      if inflections.uncountables.include?(result.downcase)
+        result
+      else
+        inflections.singulars.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }
+        result
+      end
     end
-  end
 
-  # Returns the plural form of the word in the string.
-  #
-  # Examples
-  #   "post".pluralize #=> "posts"
-  #   "octopus".pluralize #=> "octopi"
-  #   "sheep".pluralize #=> "sheep"
-  #   "words".pluralize #=> "words"
-  #   "the blue mailman".pluralize #=> "the blue mailmen"
-  #   "CamelOctopus".pluralize #=> "CamelOctopi"
-  def pluralize(word)
-    result = word.to_s.dup
-
-    if word.empty? || inflections.uncountables.include?(result.downcase)
-      result
-    else
-      inflections.plurals.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }
-      result
+    # By default, camelize converts strings to UpperCamelCase. If the argument to camelize
+    # is set to ":lower" then camelize produces lowerCamelCase.
+    #
+    # camelize will also convert '/' to '::' which is useful for converting paths to namespaces
+    #
+    # Examples
+    #   "active_record".camelize #=> "ActiveRecord"
+    #   "active_record".camelize(:lower) #=> "activeRecord"
+    #   "active_record/errors".camelize #=> "ActiveRecord::Errors"
+    #   "active_record/errors".camelize(:lower) #=> "activeRecord::Errors"
+    def camelize(lower_case_and_underscored_word, first_letter_in_uppercase = true)
+      if first_letter_in_uppercase
+        lower_case_and_underscored_word.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
+      else
+        lower_case_and_underscored_word.first + camelize(lower_case_and_underscored_word)[1..-1]
+      end
     end
-  end
-
-  # The reverse of pluralize, returns the singular form of a word in a string.
-  #
-  # Examples
-  #   "posts".singularize #=> "post"
-  #   "octopi".singularize #=> "octopus"
-  #   "sheep".singluarize #=> "sheep"
-  #   "word".singluarize #=> "word"
-  #   "the blue mailmen".singularize #=> "the blue mailman"
-  #   "CamelOctopi".singularize #=> "CamelOctopus"
-  def singularize(word)
-    result = word.to_s.dup
 
-    if inflections.uncountables.include?(result.downcase)
-      result
-    else
-      inflections.singulars.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }
-      result
+    # Capitalizes all the words and replaces some characters in the string to create
+    # a nicer looking title. Titleize is meant for creating pretty output. It is not
+    # used in the Rails internals.
+    #
+    # titleize is also aliased as as titlecase
+    #
+    # Examples
+    #   "man from the boondocks".titleize #=> "Man From The Boondocks"
+    #   "x-men: the last stand".titleize #=> "X Men: The Last Stand"
+    def titleize(word)
+      humanize(underscore(word)).gsub(/\b('?[a-z])/) { $1.capitalize }
     end
-  end
 
-  # By default, camelize converts strings to UpperCamelCase. If the argument to camelize
-  # is set to ":lower" then camelize produces lowerCamelCase.
-  #
-  # camelize will also convert '/' to '::' which is useful for converting paths to namespaces
-  #
-  # Examples
-  #   "active_record".camelize #=> "ActiveRecord"
-  #   "active_record".camelize(:lower) #=> "activeRecord"
-  #   "active_record/errors".camelize #=> "ActiveRecord::Errors"
-  #   "active_record/errors".camelize(:lower) #=> "activeRecord::Errors"
-  def camelize(lower_case_and_underscored_word, first_letter_in_uppercase = true)
-    if first_letter_in_uppercase
-      lower_case_and_underscored_word.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
-    else
-      lower_case_and_underscored_word.first + camelize(lower_case_and_underscored_word)[1..-1]
+    # The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.
+    #
+    # Changes '::' to '/' to convert namespaces to paths.
+    #
+    # Examples
+    #   "ActiveRecord".underscore #=> "active_record"
+    #   "ActiveRecord::Errors".underscore #=> active_record/errors
+    def underscore(camel_cased_word)
+      camel_cased_word.to_s.gsub(/::/, '/').
+        gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
+        gsub(/([a-z\d])([A-Z])/,'\1_\2').
+        tr("-", "_").
+        downcase
     end
-  end
 
-  # Capitalizes all the words and replaces some characters in the string to create
-  # a nicer looking title. Titleize is meant for creating pretty output. It is not
-  # used in the Rails internals.
-  #
-  # titleize is also aliased as as titlecase
-  #
-  # Examples
-  #   "man from the boondocks".titleize #=> "Man From The Boondocks"
-  #   "x-men: the last stand".titleize #=> "X Men: The Last Stand"
-  def titleize(word)
-    humanize(underscore(word)).gsub(/\b('?[a-z])/) { $1.capitalize }
-  end
-
-  # The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.
-  #
-  # Changes '::' to '/' to convert namespaces to paths.
-  #
-  # Examples
-  #   "ActiveRecord".underscore #=> "active_record"
-  #   "ActiveRecord::Errors".underscore #=> active_record/errors
-  def underscore(camel_cased_word)
-    camel_cased_word.to_s.gsub(/::/, '/').
-      gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
-      gsub(/([a-z\d])([A-Z])/,'\1_\2').
-      tr("-", "_").
-      downcase
-  end
+    # Replaces underscores with dashes in the string.
+    #
+    # Example
+    #   "puni_puni" #=> "puni-puni"
+    def dasherize(underscored_word)
+      underscored_word.gsub(/_/, '-')
+    end
 
-  # Replaces underscores with dashes in the string.
-  #
-  # Example
-  #   "puni_puni" #=> "puni-puni"
-  def dasherize(underscored_word)
-    underscored_word.gsub(/_/, '-')
-  end
+    # Capitalizes the first word and turns underscores into spaces and strips _id.
+    # Like titleize, this is meant for creating pretty output.
+    #
+    # Examples
+    #   "employee_salary" #=> "Employee salary"
+    #   "author_id" #=> "Author"
+    def humanize(lower_case_and_underscored_word)
+      lower_case_and_underscored_word.to_s.gsub(/_id$/, "").gsub(/_/, " ").capitalize
+    end
 
-  # Capitalizes the first word and turns underscores into spaces and strips _id.
-  # Like titleize, this is meant for creating pretty output.
-  #
-  # Examples
-  #   "employee_salary" #=> "Employee salary"
-  #   "author_id" #=> "Author"
-  def humanize(lower_case_and_underscored_word)
-    lower_case_and_underscored_word.to_s.gsub(/_id$/, "").gsub(/_/, " ").capitalize
-  end
+    # Removes the module part from the expression in the string
+    #
+    # Examples
+    #   "ActiveRecord::CoreExtensions::String::Inflections".demodulize #=> "Inflections"
+    #   "Inflections".demodulize #=> "Inflections"
+    def demodulize(class_name_in_module)
+      class_name_in_module.to_s.gsub(/^.*::/, '')
+    end
 
-  # Removes the module part from the expression in the string
-  #
-  # Examples
-  #   "ActiveRecord::CoreExtensions::String::Inflections".demodulize #=> "Inflections"
-  #   "Inflections".demodulize #=> "Inflections"
-  def demodulize(class_name_in_module)
-    class_name_in_module.to_s.gsub(/^.*::/, '')
-  end
+    # Create the name of a table like Rails does for models to table names. This method
+    # uses the pluralize method on the last word in the string.
+    #
+    # Examples
+    #   "RawScaledScorer".tableize #=> "raw_scaled_scorers"
+    #   "egg_and_ham".tableize #=> "egg_and_hams"
+    #   "fancyCategory".tableize #=> "fancy_categories"
+    def tableize(class_name)
+      pluralize(underscore(class_name))
+    end
 
-  # Create the name of a table like Rails does for models to table names. This method
-  # uses the pluralize method on the last word in the string.
-  #
-  # Examples
-  #   "RawScaledScorer".tableize #=> "raw_scaled_scorers"
-  #   "egg_and_ham".tableize #=> "egg_and_hams"
-  #   "fancyCategory".tableize #=> "fancy_categories"
-  def tableize(class_name)
-    pluralize(underscore(class_name))
-  end
+    # Create a class name from a plural table name like Rails does for table names to models.
+    # Note that this returns a string and not a Class. (To convert to an actual class
+    # follow classify with constantize.)
+    #
+    # Examples
+    #   "egg_and_hams".classify #=> "EggAndHam"
+    #   "posts".classify #=> "Post"
+    #
+    # Singular names are not handled correctly
+    #   "business".classify #=> "Busines"
+    def classify(table_name)
+      # strip out any leading schema name
+      camelize(singularize(table_name.to_s.sub(/.*\./, '')))
+    end
 
-  # Create a class name from a plural table name like Rails does for table names to models.
-  # Note that this returns a string and not a Class. (To convert to an actual class
-  # follow classify with constantize.)
-  #
-  # Examples
-  #   "egg_and_hams".classify #=> "EggAndHam"
-  #   "posts".classify #=> "Post"
-  #
-  # Singular names are not handled correctly
-  #   "business".classify #=> "Busines"
-  def classify(table_name)
-    # strip out any leading schema name
-    camelize(singularize(table_name.to_s.sub(/.*\./, '')))
-  end
+    # Creates a foreign key name from a class name.
+    # +separate_class_name_and_id_with_underscore+ sets whether
+    # the method should put '_' between the name and 'id'.
+    #
+    # Examples
+    #   "Message".foreign_key #=> "message_id"
+    #   "Message".foreign_key(false) #=> "messageid"
+    #   "Admin::Post".foreign_key #=> "post_id"
+    def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)
+      underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id")
+    end
 
-  # Creates a foreign key name from a class name.
-  # +separate_class_name_and_id_with_underscore+ sets whether
-  # the method should put '_' between the name and 'id'.
-  #
-  # Examples
-  #   "Message".foreign_key #=> "message_id"
-  #   "Message".foreign_key(false) #=> "messageid"
-  #   "Admin::Post".foreign_key #=> "post_id"
-  def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)
-    underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id")
-  end
+    # Tries to find a constant with the name specified in the argument string:
+    #
+    #   "Module".constantize     # => Module
+    #   "Test::Unit".constantize # => Test::Unit
+    #
+    # The name is assumed to be the one of a top-level constant, no matter whether
+    # it starts with "::" or not. No lexical context is taken into account:
+    #
+    #   C = 'outside'
+    #   module M
+    #     C = 'inside'
+    #     C               # => 'inside'
+    #     "C".constantize # => 'outside', same as ::C
+    #   end
+    #
+    # NameError is raised when the name is not in CamelCase or the constant is
+    # unknown.
+    def constantize(camel_cased_word)
+      unless /\A(?:::)?([A-Z]\w*(?:::[A-Z]\w*)*)\z/ =~ camel_cased_word
+        raise NameError, "#{camel_cased_word.inspect} is not a valid constant name!"
+      end
 
-  # Tries to find a constant with the name specified in the argument string:
-  #
-  #   "Module".constantize     # => Module
-  #   "Test::Unit".constantize # => Test::Unit
-  #
-  # The name is assumed to be the one of a top-level constant, no matter whether
-  # it starts with "::" or not. No lexical context is taken into account:
-  #
-  #   C = 'outside'
-  #   module M
-  #     C = 'inside'
-  #     C               # => 'inside'
-  #     "C".constantize # => 'outside', same as ::C
-  #   end
-  #
-  # NameError is raised when the name is not in CamelCase or the constant is
-  # unknown.
-  def constantize(camel_cased_word)
-    unless /\A(?:::)?([A-Z]\w*(?:::[A-Z]\w*)*)\z/ =~ camel_cased_word
-      raise NameError, "#{camel_cased_word.inspect} is not a valid constant name!"
+      Object.module_eval("::#{$1}", __FILE__, __LINE__)
     end
 
-    Object.module_eval("::#{$1}", __FILE__, __LINE__)
-  end
-
-  # Ordinalize turns a number into an ordinal string used to denote the
-  # position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
-  #
-  # Examples
-  #   ordinalize(1)     # => "1st"
-  #   ordinalize(2)     # => "2nd"
-  #   ordinalize(1002)  # => "1002nd"
-  #   ordinalize(1003)  # => "1003rd"
-  def ordinalize(number)
-    if (11..13).include?(number.to_i % 100)
-      "#{number}th"
-    else
-      case number.to_i % 10
-        when 1; "#{number}st"
-        when 2; "#{number}nd"
-        when 3; "#{number}rd"
-        else    "#{number}th"
+    # Ordinalize turns a number into an ordinal string used to denote the
+    # position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
+    #
+    # Examples
+    #   ordinalize(1)     # => "1st"
+    #   ordinalize(2)     # => "2nd"
+    #   ordinalize(1002)  # => "1002nd"
+    #   ordinalize(1003)  # => "1003rd"
+    def ordinalize(number)
+      if (11..13).include?(number.to_i % 100)
+        "#{number}th"
+      else
+        case number.to_i % 10
+          when 1; "#{number}st"
+          when 2; "#{number}nd"
+          when 3; "#{number}rd"
+          else    "#{number}th"
+        end
       end
     end
   end
diff --git a/activesupport/lib/active_support/ordered_options.rb b/activesupport/lib/active_support/ordered_options.rb
index 306376e..b0ada10 100644
--- a/activesupport/lib/active_support/ordered_options.rb
+++ b/activesupport/lib/active_support/ordered_options.rb
@@ -1,17 +1,19 @@
-class OrderedOptions < ActiveSupport::OrderedHash #:nodoc:
-  def []=(key, value)
-    super(key.to_sym, value)
-  end
+module ActiveSupport
+  class OrderedOptions < OrderedHash #:nodoc:
+    def []=(key, value)
+      super(key.to_sym, value)
+    end
 
-  def [](key)
-    super(key.to_sym)
-  end
+    def [](key)
+      super(key.to_sym)
+    end
 
-  def method_missing(name, *args)
-    if name.to_s =~ /(.*)=$/
-      self[$1.to_sym] = args.first
-    else
-      self[name]
+    def method_missing(name, *args)
+      if name.to_s =~ /(.*)=$/
+        self[$1.to_sym] = args.first
+      else
+        self[name]
+      end
     end
   end
 end
diff --git a/activesupport/lib/active_support/values/time_zone.rb b/activesupport/lib/active_support/values/time_zone.rb
index 5340b5e..fb21b7f 100644
--- a/activesupport/lib/active_support/values/time_zone.rb
+++ b/activesupport/lib/active_support/values/time_zone.rb
@@ -1,394 +1,396 @@
-# The TimeZone class serves as a wrapper around TZInfo::Timezone instances. It allows us to do the following:
-#
-#   * limit the set of zones provided by TZInfo to a meaningful subset of 142 zones
-#   * retrieve and display zones with a friendlier name (e.g., "Eastern Time (US & Canada)" instead of "America/New_York")
-#   * lazily load TZInfo::Timezone instances only when they're needed
-#   * create ActiveSupport::TimeWithZone instances via TimeZone #local, #parse, #at and #now methods
-# 
-# If you set config.time_zone in the Rails Initializer, you can access this TimeZone object via Time.zone:
-#
-#   # environment.rb:
-#   Rails::Initializer.run do |config|
-#     config.time_zone = "Eastern Time (US & Canada)"
-#   end
-#
-#   Time.zone       # => #<TimeZone:0x514834...>
-#   Time.zone.name  # => "Eastern Time (US & Canada)"
-#   Time.zone.now   # => Sun, 18 May 2008 14:30:44 EDT -04:00
-#
-# The version of TZInfo bundled with ActiveSupport only includes the definitions necessary to support the zones 
-# defined by the TimeZone class. If you need to use zones that aren't defined by TimeZone, you'll need to install the TZInfo gem
-# (if a recent version of the gem is installed locally, this will be used instead of the bundled version.)
-class TimeZone
-  unless const_defined?(:MAPPING)
-    # Keys are Rails TimeZone names, values are TZInfo identifiers
-    MAPPING = {
-      "International Date Line West" => "Pacific/Midway",
-      "Midway Island"                => "Pacific/Midway",
-      "Samoa"                        => "Pacific/Pago_Pago",
-      "Hawaii"                       => "Pacific/Honolulu",
-      "Alaska"                       => "America/Juneau",
-      "Pacific Time (US & Canada)"   => "America/Los_Angeles",
-      "Tijuana"                      => "America/Tijuana",
-      "Mountain Time (US & Canada)"  => "America/Denver",
-      "Arizona"                      => "America/Phoenix",
-      "Chihuahua"                    => "America/Chihuahua",
-      "Mazatlan"                     => "America/Mazatlan",
-      "Central Time (US & Canada)"   => "America/Chicago",
-      "Saskatchewan"                 => "America/Regina",
-      "Guadalajara"                  => "America/Mexico_City",
-      "Mexico City"                  => "America/Mexico_City",
-      "Monterrey"                    => "America/Monterrey",
-      "Central America"              => "America/Guatemala",
-      "Eastern Time (US & Canada)"   => "America/New_York",
-      "Indiana (East)"               => "America/Indiana/Indianapolis",
-      "Bogota"                       => "America/Bogota",
-      "Lima"                         => "America/Lima",
-      "Quito"                        => "America/Lima",
-      "Atlantic Time (Canada)"       => "America/Halifax",
-      "Caracas"                      => "America/Caracas",
-      "La Paz"                       => "America/La_Paz",
-      "Santiago"                     => "America/Santiago",
-      "Newfoundland"                 => "America/St_Johns",
-      "Brasilia"                     => "America/Argentina/Buenos_Aires",
-      "Buenos Aires"                 => "America/Argentina/Buenos_Aires",
-      "Georgetown"                   => "America/Argentina/San_Juan",
-      "Greenland"                    => "America/Godthab",
-      "Mid-Atlantic"                 => "Atlantic/South_Georgia",
-      "Azores"                       => "Atlantic/Azores",
-      "Cape Verde Is."               => "Atlantic/Cape_Verde",
-      "Dublin"                       => "Europe/Dublin",
-      "Edinburgh"                    => "Europe/Dublin",
-      "Lisbon"                       => "Europe/Lisbon",
-      "London"                       => "Europe/London",
-      "Casablanca"                   => "Africa/Casablanca",
-      "Monrovia"                     => "Africa/Monrovia",
-      "UTC"                          => "Etc/UTC",
-      "Belgrade"                     => "Europe/Belgrade",
-      "Bratislava"                   => "Europe/Bratislava",
-      "Budapest"                     => "Europe/Budapest",
-      "Ljubljana"                    => "Europe/Ljubljana",
-      "Prague"                       => "Europe/Prague",
-      "Sarajevo"                     => "Europe/Sarajevo",
-      "Skopje"                       => "Europe/Skopje",
-      "Warsaw"                       => "Europe/Warsaw",
-      "Zagreb"                       => "Europe/Zagreb",
-      "Brussels"                     => "Europe/Brussels",
-      "Copenhagen"                   => "Europe/Copenhagen",
-      "Madrid"                       => "Europe/Madrid",
-      "Paris"                        => "Europe/Paris",
-      "Amsterdam"                    => "Europe/Amsterdam",
-      "Berlin"                       => "Europe/Berlin",
-      "Bern"                         => "Europe/Berlin",
-      "Rome"                         => "Europe/Rome",
-      "Stockholm"                    => "Europe/Stockholm",
-      "Vienna"                       => "Europe/Vienna",
-      "West Central Africa"          => "Africa/Algiers",
-      "Bucharest"                    => "Europe/Bucharest",
-      "Cairo"                        => "Africa/Cairo",
-      "Helsinki"                     => "Europe/Helsinki",
-      "Kyev"                         => "Europe/Kiev",
-      "Riga"                         => "Europe/Riga",
-      "Sofia"                        => "Europe/Sofia",
-      "Tallinn"                      => "Europe/Tallinn",
-      "Vilnius"                      => "Europe/Vilnius",
-      "Athens"                       => "Europe/Athens",
-      "Istanbul"                     => "Europe/Istanbul",
-      "Minsk"                        => "Europe/Minsk",
-      "Jerusalem"                    => "Asia/Jerusalem",
-      "Harare"                       => "Africa/Harare",
-      "Pretoria"                     => "Africa/Johannesburg",
-      "Moscow"                       => "Europe/Moscow",
-      "St. Petersburg"               => "Europe/Moscow",
-      "Volgograd"                    => "Europe/Moscow",
-      "Kuwait"                       => "Asia/Kuwait",
-      "Riyadh"                       => "Asia/Riyadh",
-      "Nairobi"                      => "Africa/Nairobi",
-      "Baghdad"                      => "Asia/Baghdad",
-      "Tehran"                       => "Asia/Tehran",
-      "Abu Dhabi"                    => "Asia/Muscat",
-      "Muscat"                       => "Asia/Muscat",
-      "Baku"                         => "Asia/Baku",
-      "Tbilisi"                      => "Asia/Tbilisi",
-      "Yerevan"                      => "Asia/Yerevan",
-      "Kabul"                        => "Asia/Kabul",
-      "Ekaterinburg"                 => "Asia/Yekaterinburg",
-      "Islamabad"                    => "Asia/Karachi",
-      "Karachi"                      => "Asia/Karachi",
-      "Tashkent"                     => "Asia/Tashkent",
-      "Chennai"                      => "Asia/Kolkata",
-      "Kolkata"                      => "Asia/Kolkata",
-      "Mumbai"                       => "Asia/Kolkata",
-      "New Delhi"                    => "Asia/Kolkata",
-      "Kathmandu"                    => "Asia/Katmandu",
-      "Astana"                       => "Asia/Dhaka",
-      "Dhaka"                        => "Asia/Dhaka",
-      "Sri Jayawardenepura"          => "Asia/Dhaka",
-      "Almaty"                       => "Asia/Almaty",
-      "Novosibirsk"                  => "Asia/Novosibirsk",
-      "Rangoon"                      => "Asia/Rangoon",
-      "Bangkok"                      => "Asia/Bangkok",
-      "Hanoi"                        => "Asia/Bangkok",
-      "Jakarta"                      => "Asia/Jakarta",
-      "Krasnoyarsk"                  => "Asia/Krasnoyarsk",
-      "Beijing"                      => "Asia/Shanghai",
-      "Chongqing"                    => "Asia/Chongqing",
-      "Hong Kong"                    => "Asia/Hong_Kong",
-      "Urumqi"                       => "Asia/Urumqi",
-      "Kuala Lumpur"                 => "Asia/Kuala_Lumpur",
-      "Singapore"                    => "Asia/Singapore",
-      "Taipei"                       => "Asia/Taipei",
-      "Perth"                        => "Australia/Perth",
-      "Irkutsk"                      => "Asia/Irkutsk",
-      "Ulaan Bataar"                 => "Asia/Ulaanbaatar",
-      "Seoul"                        => "Asia/Seoul",
-      "Osaka"                        => "Asia/Tokyo",
-      "Sapporo"                      => "Asia/Tokyo",
-      "Tokyo"                        => "Asia/Tokyo",
-      "Yakutsk"                      => "Asia/Yakutsk",
-      "Darwin"                       => "Australia/Darwin",
-      "Adelaide"                     => "Australia/Adelaide",
-      "Canberra"                     => "Australia/Melbourne",
-      "Melbourne"                    => "Australia/Melbourne",
-      "Sydney"                       => "Australia/Sydney",
-      "Brisbane"                     => "Australia/Brisbane",
-      "Hobart"                       => "Australia/Hobart",
-      "Vladivostok"                  => "Asia/Vladivostok",
-      "Guam"                         => "Pacific/Guam",
-      "Port Moresby"                 => "Pacific/Port_Moresby",
-      "Magadan"                      => "Asia/Magadan",
-      "Solomon Is."                  => "Asia/Magadan",
-      "New Caledonia"                => "Pacific/Noumea",
-      "Fiji"                         => "Pacific/Fiji",
-      "Kamchatka"                    => "Asia/Kamchatka",
-      "Marshall Is."                 => "Pacific/Majuro",
-      "Auckland"                     => "Pacific/Auckland",
-      "Wellington"                   => "Pacific/Auckland",
-      "Nuku'alofa"                   => "Pacific/Tongatapu"
-    }.each { |name, zone| name.freeze; zone.freeze }
-    MAPPING.freeze
-  end
-
-  include Comparable
-  attr_reader :name
-
-  # Create a new TimeZone object with the given name and offset. The
-  # offset is the number of seconds that this time zone is offset from UTC
-  # (GMT). Seconds were chosen as the offset unit because that is the unit that
-  # Ruby uses to represent time zone offsets (see Time#utc_offset).
-  def initialize(name, utc_offset, tzinfo = nil)
-    @name = name
-    @utc_offset = utc_offset
-    @tzinfo = tzinfo
-  end
+module ActiveSupport
+  # The TimeZone class serves as a wrapper around TZInfo::Timezone instances. It allows us to do the following:
+  #
+  #   * limit the set of zones provided by TZInfo to a meaningful subset of 142 zones
+  #   * retrieve and display zones with a friendlier name (e.g., "Eastern Time (US & Canada)" instead of "America/New_York")
+  #   * lazily load TZInfo::Timezone instances only when they're needed
+  #   * create ActiveSupport::TimeWithZone instances via TimeZone #local, #parse, #at and #now methods
+  # 
+  # If you set config.time_zone in the Rails Initializer, you can access this TimeZone object via Time.zone:
+  #
+  #   # environment.rb:
+  #   Rails::Initializer.run do |config|
+  #     config.time_zone = "Eastern Time (US & Canada)"
+  #   end
+  #
+  #   Time.zone       # => #<TimeZone:0x514834...>
+  #   Time.zone.name  # => "Eastern Time (US & Canada)"
+  #   Time.zone.now   # => Sun, 18 May 2008 14:30:44 EDT -04:00
+  #
+  # The version of TZInfo bundled with ActiveSupport only includes the definitions necessary to support the zones 
+  # defined by the TimeZone class. If you need to use zones that aren't defined by TimeZone, you'll need to install the TZInfo gem
+  # (if a recent version of the gem is installed locally, this will be used instead of the bundled version.)
+  class TimeZone
+    unless const_defined?(:MAPPING)
+      # Keys are Rails TimeZone names, values are TZInfo identifiers
+      MAPPING = {
+        "International Date Line West" => "Pacific/Midway",
+        "Midway Island"                => "Pacific/Midway",
+        "Samoa"                        => "Pacific/Pago_Pago",
+        "Hawaii"                       => "Pacific/Honolulu",
+        "Alaska"                       => "America/Juneau",
+        "Pacific Time (US & Canada)"   => "America/Los_Angeles",
+        "Tijuana"                      => "America/Tijuana",
+        "Mountain Time (US & Canada)"  => "America/Denver",
+        "Arizona"                      => "America/Phoenix",
+        "Chihuahua"                    => "America/Chihuahua",
+        "Mazatlan"                     => "America/Mazatlan",
+        "Central Time (US & Canada)"   => "America/Chicago",
+        "Saskatchewan"                 => "America/Regina",
+        "Guadalajara"                  => "America/Mexico_City",
+        "Mexico City"                  => "America/Mexico_City",
+        "Monterrey"                    => "America/Monterrey",
+        "Central America"              => "America/Guatemala",
+        "Eastern Time (US & Canada)"   => "America/New_York",
+        "Indiana (East)"               => "America/Indiana/Indianapolis",
+        "Bogota"                       => "America/Bogota",
+        "Lima"                         => "America/Lima",
+        "Quito"                        => "America/Lima",
+        "Atlantic Time (Canada)"       => "America/Halifax",
+        "Caracas"                      => "America/Caracas",
+        "La Paz"                       => "America/La_Paz",
+        "Santiago"                     => "America/Santiago",
+        "Newfoundland"                 => "America/St_Johns",
+        "Brasilia"                     => "America/Argentina/Buenos_Aires",
+        "Buenos Aires"                 => "America/Argentina/Buenos_Aires",
+        "Georgetown"                   => "America/Argentina/San_Juan",
+        "Greenland"                    => "America/Godthab",
+        "Mid-Atlantic"                 => "Atlantic/South_Georgia",
+        "Azores"                       => "Atlantic/Azores",
+        "Cape Verde Is."               => "Atlantic/Cape_Verde",
+        "Dublin"                       => "Europe/Dublin",
+        "Edinburgh"                    => "Europe/Dublin",
+        "Lisbon"                       => "Europe/Lisbon",
+        "London"                       => "Europe/London",
+        "Casablanca"                   => "Africa/Casablanca",
+        "Monrovia"                     => "Africa/Monrovia",
+        "UTC"                          => "Etc/UTC",
+        "Belgrade"                     => "Europe/Belgrade",
+        "Bratislava"                   => "Europe/Bratislava",
+        "Budapest"                     => "Europe/Budapest",
+        "Ljubljana"                    => "Europe/Ljubljana",
+        "Prague"                       => "Europe/Prague",
+        "Sarajevo"                     => "Europe/Sarajevo",
+        "Skopje"                       => "Europe/Skopje",
+        "Warsaw"                       => "Europe/Warsaw",
+        "Zagreb"                       => "Europe/Zagreb",
+        "Brussels"                     => "Europe/Brussels",
+        "Copenhagen"                   => "Europe/Copenhagen",
+        "Madrid"                       => "Europe/Madrid",
+        "Paris"                        => "Europe/Paris",
+        "Amsterdam"                    => "Europe/Amsterdam",
+        "Berlin"                       => "Europe/Berlin",
+        "Bern"                         => "Europe/Berlin",
+        "Rome"                         => "Europe/Rome",
+        "Stockholm"                    => "Europe/Stockholm",
+        "Vienna"                       => "Europe/Vienna",
+        "West Central Africa"          => "Africa/Algiers",
+        "Bucharest"                    => "Europe/Bucharest",
+        "Cairo"                        => "Africa/Cairo",
+        "Helsinki"                     => "Europe/Helsinki",
+        "Kyev"                         => "Europe/Kiev",
+        "Riga"                         => "Europe/Riga",
+        "Sofia"                        => "Europe/Sofia",
+        "Tallinn"                      => "Europe/Tallinn",
+        "Vilnius"                      => "Europe/Vilnius",
+        "Athens"                       => "Europe/Athens",
+        "Istanbul"                     => "Europe/Istanbul",
+        "Minsk"                        => "Europe/Minsk",
+        "Jerusalem"                    => "Asia/Jerusalem",
+        "Harare"                       => "Africa/Harare",
+        "Pretoria"                     => "Africa/Johannesburg",
+        "Moscow"                       => "Europe/Moscow",
+        "St. Petersburg"               => "Europe/Moscow",
+        "Volgograd"                    => "Europe/Moscow",
+        "Kuwait"                       => "Asia/Kuwait",
+        "Riyadh"                       => "Asia/Riyadh",
+        "Nairobi"                      => "Africa/Nairobi",
+        "Baghdad"                      => "Asia/Baghdad",
+        "Tehran"                       => "Asia/Tehran",
+        "Abu Dhabi"                    => "Asia/Muscat",
+        "Muscat"                       => "Asia/Muscat",
+        "Baku"                         => "Asia/Baku",
+        "Tbilisi"                      => "Asia/Tbilisi",
+        "Yerevan"                      => "Asia/Yerevan",
+        "Kabul"                        => "Asia/Kabul",
+        "Ekaterinburg"                 => "Asia/Yekaterinburg",
+        "Islamabad"                    => "Asia/Karachi",
+        "Karachi"                      => "Asia/Karachi",
+        "Tashkent"                     => "Asia/Tashkent",
+        "Chennai"                      => "Asia/Kolkata",
+        "Kolkata"                      => "Asia/Kolkata",
+        "Mumbai"                       => "Asia/Kolkata",
+        "New Delhi"                    => "Asia/Kolkata",
+        "Kathmandu"                    => "Asia/Katmandu",
+        "Astana"                       => "Asia/Dhaka",
+        "Dhaka"                        => "Asia/Dhaka",
+        "Sri Jayawardenepura"          => "Asia/Dhaka",
+        "Almaty"                       => "Asia/Almaty",
+        "Novosibirsk"                  => "Asia/Novosibirsk",
+        "Rangoon"                      => "Asia/Rangoon",
+        "Bangkok"                      => "Asia/Bangkok",
+        "Hanoi"                        => "Asia/Bangkok",
+        "Jakarta"                      => "Asia/Jakarta",
+        "Krasnoyarsk"                  => "Asia/Krasnoyarsk",
+        "Beijing"                      => "Asia/Shanghai",
+        "Chongqing"                    => "Asia/Chongqing",
+        "Hong Kong"                    => "Asia/Hong_Kong",
+        "Urumqi"                       => "Asia/Urumqi",
+        "Kuala Lumpur"                 => "Asia/Kuala_Lumpur",
+        "Singapore"                    => "Asia/Singapore",
+        "Taipei"                       => "Asia/Taipei",
+        "Perth"                        => "Australia/Perth",
+        "Irkutsk"                      => "Asia/Irkutsk",
+        "Ulaan Bataar"                 => "Asia/Ulaanbaatar",
+        "Seoul"                        => "Asia/Seoul",
+        "Osaka"                        => "Asia/Tokyo",
+        "Sapporo"                      => "Asia/Tokyo",
+        "Tokyo"                        => "Asia/Tokyo",
+        "Yakutsk"                      => "Asia/Yakutsk",
+        "Darwin"                       => "Australia/Darwin",
+        "Adelaide"                     => "Australia/Adelaide",
+        "Canberra"                     => "Australia/Melbourne",
+        "Melbourne"                    => "Australia/Melbourne",
+        "Sydney"                       => "Australia/Sydney",
+        "Brisbane"                     => "Australia/Brisbane",
+        "Hobart"                       => "Australia/Hobart",
+        "Vladivostok"                  => "Asia/Vladivostok",
+        "Guam"                         => "Pacific/Guam",
+        "Port Moresby"                 => "Pacific/Port_Moresby",
+        "Magadan"                      => "Asia/Magadan",
+        "Solomon Is."                  => "Asia/Magadan",
+        "New Caledonia"                => "Pacific/Noumea",
+        "Fiji"                         => "Pacific/Fiji",
+        "Kamchatka"                    => "Asia/Kamchatka",
+        "Marshall Is."                 => "Pacific/Majuro",
+        "Auckland"                     => "Pacific/Auckland",
+        "Wellington"                   => "Pacific/Auckland",
+        "Nuku'alofa"                   => "Pacific/Tongatapu"
+      }.each { |name, zone| name.freeze; zone.freeze }
+      MAPPING.freeze
+    end
 
-  def utc_offset
-    @utc_offset ||= tzinfo.current_period.utc_offset
-  end
+    include Comparable
+    attr_reader :name
 
-  # Returns the offset of this time zone as a formatted string, of the
-  # format "+HH:MM".
-  def formatted_offset(colon=true, alternate_utc_string = nil)
-    utc_offset == 0 && alternate_utc_string || utc_offset.to_utc_offset_s(colon)
-  end
+    # Create a new TimeZone object with the given name and offset. The
+    # offset is the number of seconds that this time zone is offset from UTC
+    # (GMT). Seconds were chosen as the offset unit because that is the unit that
+    # Ruby uses to represent time zone offsets (see Time#utc_offset).
+    def initialize(name, utc_offset, tzinfo = nil)
+      @name = name
+      @utc_offset = utc_offset
+      @tzinfo = tzinfo
+    end
 
-  # Compare this time zone to the parameter. The two are comapred first on
-  # their offsets, and then by name.
-  def <=>(zone)
-    result = (utc_offset <=> zone.utc_offset)
-    result = (name <=> zone.name) if result == 0
-    result
-  end
+    def utc_offset
+      @utc_offset ||= tzinfo.current_period.utc_offset
+    end
 
-  # Returns a textual representation of this time zone.
-  def to_s
-    "(UTC#{formatted_offset}) #{name}"
-  end
+    # Returns the offset of this time zone as a formatted string, of the
+    # format "+HH:MM".
+    def formatted_offset(colon=true, alternate_utc_string = nil)
+      utc_offset == 0 && alternate_utc_string || utc_offset.to_utc_offset_s(colon)
+    end
 
-  # Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from given values. Example:
-  #
-  #   Time.zone = "Hawaii"                      # => "Hawaii"
-  #   Time.zone.local(2007, 2, 1, 15, 30, 45)   # => Thu, 01 Feb 2007 15:30:45 HST -10:00
-  def local(*args)
-    time = Time.utc_time(*args)
-    ActiveSupport::TimeWithZone.new(nil, self, time)
-  end
+    # Compare this time zone to the parameter. The two are comapred first on
+    # their offsets, and then by name.
+    def <=>(zone)
+      result = (utc_offset <=> zone.utc_offset)
+      result = (name <=> zone.name) if result == 0
+      result
+    end
 
-  # Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from number of seconds since the Unix epoch. Example:
-  #
-  #   Time.zone = "Hawaii"        # => "Hawaii"
-  #   Time.utc(2000).to_f         # => 946684800.0
-  #   Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00
-  def at(secs)
-    utc = Time.at(secs).utc rescue DateTime.civil(1970).since(secs)
-    utc.in_time_zone(self)
-  end
+    # Returns a textual representation of this time zone.
+    def to_s
+      "(UTC#{formatted_offset}) #{name}"
+    end
 
-  # Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from parsed string. Example:
-  #
-  #   Time.zone = "Hawaii"                      # => "Hawaii"
-  #   Time.zone.parse('1999-12-31 14:00:00')    # => Fri, 31 Dec 1999 14:00:00 HST -10:00
-  #
-  # If upper components are missing from the string, they are supplied from TimeZone#now:
-  #
-  #   Time.zone.now                 # => Fri, 31 Dec 1999 14:00:00 HST -10:00
-  #   Time.zone.parse('22:30:00')   # => Fri, 31 Dec 1999 22:30:00 HST -10:00
-  def parse(str, now=now)
-    date_parts = Date._parse(str)
-    return if date_parts.blank?
-    time = Time.parse(str, now) rescue DateTime.parse(str)
-    if date_parts[:offset].nil?
+    # Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from given values. Example:
+    #
+    #   Time.zone = "Hawaii"                      # => "Hawaii"
+    #   Time.zone.local(2007, 2, 1, 15, 30, 45)   # => Thu, 01 Feb 2007 15:30:45 HST -10:00
+    def local(*args)
+      time = Time.utc_time(*args)
       ActiveSupport::TimeWithZone.new(nil, self, time)
-    else
-      time.in_time_zone(self)
     end
-  end
 
-  # Returns an ActiveSupport::TimeWithZone instance representing the current time
-  # in the time zone represented by +self+. Example:
-  #
-  #   Time.zone = 'Hawaii'  # => "Hawaii"
-  #   Time.zone.now         # => Wed, 23 Jan 2008 20:24:27 HST -10:00
-  def now
-    Time.now.utc.in_time_zone(self)
-  end
+    # Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from number of seconds since the Unix epoch. Example:
+    #
+    #   Time.zone = "Hawaii"        # => "Hawaii"
+    #   Time.utc(2000).to_f         # => 946684800.0
+    #   Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00
+    def at(secs)
+      utc = Time.at(secs).utc rescue DateTime.civil(1970).since(secs)
+      utc.in_time_zone(self)
+    end
 
-  # Return the current date in this time zone.
-  def today
-    tzinfo.now.to_date
-  end
+    # Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from parsed string. Example:
+    #
+    #   Time.zone = "Hawaii"                      # => "Hawaii"
+    #   Time.zone.parse('1999-12-31 14:00:00')    # => Fri, 31 Dec 1999 14:00:00 HST -10:00
+    #
+    # If upper components are missing from the string, they are supplied from TimeZone#now:
+    #
+    #   Time.zone.now                 # => Fri, 31 Dec 1999 14:00:00 HST -10:00
+    #   Time.zone.parse('22:30:00')   # => Fri, 31 Dec 1999 22:30:00 HST -10:00
+    def parse(str, now=now)
+      date_parts = Date._parse(str)
+      return if date_parts.blank?
+      time = Time.parse(str, now) rescue DateTime.parse(str)
+      if date_parts[:offset].nil?
+        ActiveSupport::TimeWithZone.new(nil, self, time)
+      else
+        time.in_time_zone(self)
+      end
+    end
 
-  # Adjust the given time to the simultaneous time in the time zone represented by +self+. Returns a
-  # Time.utc() instance -- if you want an ActiveSupport::TimeWithZone instance, use Time#in_time_zone() instead.
-  def utc_to_local(time)
-    tzinfo.utc_to_local(time)
-  end
+    # Returns an ActiveSupport::TimeWithZone instance representing the current time
+    # in the time zone represented by +self+. Example:
+    #
+    #   Time.zone = 'Hawaii'  # => "Hawaii"
+    #   Time.zone.now         # => Wed, 23 Jan 2008 20:24:27 HST -10:00
+    def now
+      Time.now.utc.in_time_zone(self)
+    end
 
-  # Adjust the given time to the simultaneous time in UTC. Returns a Time.utc() instance.
-  def local_to_utc(time, dst=true)
-    tzinfo.local_to_utc(time, dst)
-  end
+    # Return the current date in this time zone.
+    def today
+      tzinfo.now.to_date
+    end
 
-  # Available so that TimeZone instances respond like TZInfo::Timezone instances
-  def period_for_utc(time)
-    tzinfo.period_for_utc(time)
-  end
+    # Adjust the given time to the simultaneous time in the time zone represented by +self+. Returns a
+    # Time.utc() instance -- if you want an ActiveSupport::TimeWithZone instance, use Time#in_time_zone() instead.
+    def utc_to_local(time)
+      tzinfo.utc_to_local(time)
+    end
 
-  # Available so that TimeZone instances respond like TZInfo::Timezone instances
-  def period_for_local(time, dst=true)
-    tzinfo.period_for_local(time, dst)
-  end
+    # Adjust the given time to the simultaneous time in UTC. Returns a Time.utc() instance.
+    def local_to_utc(time, dst=true)
+      tzinfo.local_to_utc(time, dst)
+    end
 
-  # TODO: Preload instead of lazy load for thread safety
-  def tzinfo
-    @tzinfo ||= TZInfo::Timezone.get(MAPPING[name])
-  end
+    # Available so that TimeZone instances respond like TZInfo::Timezone instances
+    def period_for_utc(time)
+      tzinfo.period_for_utc(time)
+    end
 
-  unless const_defined?(:ZONES)
-    ZONES = []
-    ZONES_MAP = {}
-    [[-39_600, "International Date Line West", "Midway Island", "Samoa" ],
-     [-36_000, "Hawaii" ],
-     [-32_400, "Alaska" ],
-     [-28_800, "Pacific Time (US & Canada)", "Tijuana" ],
-     [-25_200, "Mountain Time (US & Canada)", "Chihuahua", "Mazatlan",
-               "Arizona" ],
-     [-21_600, "Central Time (US & Canada)", "Saskatchewan", "Guadalajara",
-               "Mexico City", "Monterrey", "Central America" ],
-     [-18_000, "Eastern Time (US & Canada)", "Indiana (East)", "Bogota",
-               "Lima", "Quito" ],
-     [-14_400, "Atlantic Time (Canada)", "Caracas", "La Paz", "Santiago" ],
-     [-12_600, "Newfoundland" ],
-     [-10_800, "Brasilia", "Buenos Aires", "Georgetown", "Greenland" ],
-     [ -7_200, "Mid-Atlantic" ],
-     [ -3_600, "Azores", "Cape Verde Is." ],
-     [      0, "Dublin", "Edinburgh", "Lisbon", "London", "Casablanca",
-               "Monrovia", "UTC" ],
-     [  3_600, "Belgrade", "Bratislava", "Budapest", "Ljubljana", "Prague",
-               "Sarajevo", "Skopje", "Warsaw", "Zagreb", "Brussels",
-               "Copenhagen", "Madrid", "Paris", "Amsterdam", "Berlin",
-               "Bern", "Rome", "Stockholm", "Vienna",
-               "West Central Africa" ],
-     [  7_200, "Bucharest", "Cairo", "Helsinki", "Kyev", "Riga", "Sofia",
-               "Tallinn", "Vilnius", "Athens", "Istanbul", "Minsk",
-               "Jerusalem", "Harare", "Pretoria" ],
-     [ 10_800, "Moscow", "St. Petersburg", "Volgograd", "Kuwait", "Riyadh",
-               "Nairobi", "Baghdad" ],
-     [ 12_600, "Tehran" ],
-     [ 14_400, "Abu Dhabi", "Muscat", "Baku", "Tbilisi", "Yerevan" ],
-     [ 16_200, "Kabul" ],
-     [ 18_000, "Ekaterinburg", "Islamabad", "Karachi", "Tashkent" ],
-     [ 19_800, "Chennai", "Kolkata", "Mumbai", "New Delhi" ],
-     [ 20_700, "Kathmandu" ],
-     [ 21_600, "Astana", "Dhaka", "Sri Jayawardenepura", "Almaty",
-               "Novosibirsk" ],
-     [ 23_400, "Rangoon" ],
-     [ 25_200, "Bangkok", "Hanoi", "Jakarta", "Krasnoyarsk" ],
-     [ 28_800, "Beijing", "Chongqing", "Hong Kong", "Urumqi",
-               "Kuala Lumpur", "Singapore", "Taipei", "Perth", "Irkutsk",
-               "Ulaan Bataar" ],
-     [ 32_400, "Seoul", "Osaka", "Sapporo", "Tokyo", "Yakutsk" ],
-     [ 34_200, "Darwin", "Adelaide" ],
-     [ 36_000, "Canberra", "Melbourne", "Sydney", "Brisbane", "Hobart",
-               "Vladivostok", "Guam", "Port Moresby" ],
-     [ 39_600, "Magadan", "Solomon Is.", "New Caledonia" ],
-     [ 43_200, "Fiji", "Kamchatka", "Marshall Is.", "Auckland",
-               "Wellington" ],
-     [ 46_800, "Nuku'alofa" ]].
-    each do |offset, *places|
-      places.each do |place|
-        place.freeze
-        zone = new(place, offset)
-        ZONES << zone
-        ZONES_MAP[place] = zone
-      end
+    # Available so that TimeZone instances respond like TZInfo::Timezone instances
+    def period_for_local(time, dst=true)
+      tzinfo.period_for_local(time, dst)
     end
-    ZONES.sort!
-    ZONES.freeze
-    ZONES_MAP.freeze
 
-    US_ZONES = ZONES.find_all { |z| z.name =~ /US|Arizona|Indiana|Hawaii|Alaska/ }
-    US_ZONES.freeze
-  end
+    # TODO: Preload instead of lazy load for thread safety
+    def tzinfo
+      @tzinfo ||= TZInfo::Timezone.get(MAPPING[name])
+    end
 
-  class << self
-    alias_method :create, :new
+    unless const_defined?(:ZONES)
+      ZONES = []
+      ZONES_MAP = {}
+      [[-39_600, "International Date Line West", "Midway Island", "Samoa" ],
+       [-36_000, "Hawaii" ],
+       [-32_400, "Alaska" ],
+       [-28_800, "Pacific Time (US & Canada)", "Tijuana" ],
+       [-25_200, "Mountain Time (US & Canada)", "Chihuahua", "Mazatlan",
+                 "Arizona" ],
+       [-21_600, "Central Time (US & Canada)", "Saskatchewan", "Guadalajara",
+                 "Mexico City", "Monterrey", "Central America" ],
+       [-18_000, "Eastern Time (US & Canada)", "Indiana (East)", "Bogota",
+                 "Lima", "Quito" ],
+       [-14_400, "Atlantic Time (Canada)", "Caracas", "La Paz", "Santiago" ],
+       [-12_600, "Newfoundland" ],
+       [-10_800, "Brasilia", "Buenos Aires", "Georgetown", "Greenland" ],
+       [ -7_200, "Mid-Atlantic" ],
+       [ -3_600, "Azores", "Cape Verde Is." ],
+       [      0, "Dublin", "Edinburgh", "Lisbon", "London", "Casablanca",
+                 "Monrovia", "UTC" ],
+       [  3_600, "Belgrade", "Bratislava", "Budapest", "Ljubljana", "Prague",
+                 "Sarajevo", "Skopje", "Warsaw", "Zagreb", "Brussels",
+                 "Copenhagen", "Madrid", "Paris", "Amsterdam", "Berlin",
+                 "Bern", "Rome", "Stockholm", "Vienna",
+                 "West Central Africa" ],
+       [  7_200, "Bucharest", "Cairo", "Helsinki", "Kyev", "Riga", "Sofia",
+                 "Tallinn", "Vilnius", "Athens", "Istanbul", "Minsk",
+                 "Jerusalem", "Harare", "Pretoria" ],
+       [ 10_800, "Moscow", "St. Petersburg", "Volgograd", "Kuwait", "Riyadh",
+                 "Nairobi", "Baghdad" ],
+       [ 12_600, "Tehran" ],
+       [ 14_400, "Abu Dhabi", "Muscat", "Baku", "Tbilisi", "Yerevan" ],
+       [ 16_200, "Kabul" ],
+       [ 18_000, "Ekaterinburg", "Islamabad", "Karachi", "Tashkent" ],
+       [ 19_800, "Chennai", "Kolkata", "Mumbai", "New Delhi" ],
+       [ 20_700, "Kathmandu" ],
+       [ 21_600, "Astana", "Dhaka", "Sri Jayawardenepura", "Almaty",
+                 "Novosibirsk" ],
+       [ 23_400, "Rangoon" ],
+       [ 25_200, "Bangkok", "Hanoi", "Jakarta", "Krasnoyarsk" ],
+       [ 28_800, "Beijing", "Chongqing", "Hong Kong", "Urumqi",
+                 "Kuala Lumpur", "Singapore", "Taipei", "Perth", "Irkutsk",
+                 "Ulaan Bataar" ],
+       [ 32_400, "Seoul", "Osaka", "Sapporo", "Tokyo", "Yakutsk" ],
+       [ 34_200, "Darwin", "Adelaide" ],
+       [ 36_000, "Canberra", "Melbourne", "Sydney", "Brisbane", "Hobart",
+                 "Vladivostok", "Guam", "Port Moresby" ],
+       [ 39_600, "Magadan", "Solomon Is.", "New Caledonia" ],
+       [ 43_200, "Fiji", "Kamchatka", "Marshall Is.", "Auckland",
+                 "Wellington" ],
+       [ 46_800, "Nuku'alofa" ]].
+      each do |offset, *places|
+        places.each do |place|
+          place.freeze
+          zone = new(place, offset)
+          ZONES << zone
+          ZONES_MAP[place] = zone
+        end
+      end
+      ZONES.sort!
+      ZONES.freeze
+      ZONES_MAP.freeze
 
-    # Return a TimeZone instance with the given name, or +nil+ if no
-    # such TimeZone instance exists. (This exists to support the use of
-    # this class with the #composed_of macro.)
-    def new(name)
-      self[name]
+      US_ZONES = ZONES.find_all { |z| z.name =~ /US|Arizona|Indiana|Hawaii|Alaska/ }
+      US_ZONES.freeze
     end
 
-    # Return an array of all TimeZone objects. There are multiple
-    # TimeZone objects per time zone, in many cases, to make it easier
-    # for users to find their own time zone.
-    def all
-      ZONES
-    end
+    class << self
+      alias_method :create, :new
 
-    # Locate a specific time zone object. If the argument is a string, it
-    # is interpreted to mean the name of the timezone to locate. If it is a
-    # numeric value it is either the hour offset, or the second offset, of the
-    # timezone to find. (The first one with that offset will be returned.)
-    # Returns +nil+ if no such time zone is known to the system.
-    def [](arg)
-      case arg
-        when String
-          ZONES_MAP[arg]
-        when Numeric, ActiveSupport::Duration
-          arg *= 3600 if arg.abs <= 13
-          all.find { |z| z.utc_offset == arg.to_i }
-        else
-          raise ArgumentError, "invalid argument to TimeZone[]: #{arg.inspect}"
+      # Return a TimeZone instance with the given name, or +nil+ if no
+      # such TimeZone instance exists. (This exists to support the use of
+      # this class with the #composed_of macro.)
+      def new(name)
+        self[name]
+      end
+
+      # Return an array of all TimeZone objects. There are multiple
+      # TimeZone objects per time zone, in many cases, to make it easier
+      # for users to find their own time zone.
+      def all
+        ZONES
       end
-    end
 
-    # A convenience method for returning a collection of TimeZone objects
-    # for time zones in the USA.
-    def us_zones
-      US_ZONES
+      # Locate a specific time zone object. If the argument is a string, it
+      # is interpreted to mean the name of the timezone to locate. If it is a
+      # numeric value it is either the hour offset, or the second offset, of the
+      # timezone to find. (The first one with that offset will be returned.)
+      # Returns +nil+ if no such time zone is known to the system.
+      def [](arg)
+        case arg
+          when String
+            ZONES_MAP[arg]
+          when Numeric, ActiveSupport::Duration
+            arg *= 3600 if arg.abs <= 13
+            all.find { |z| z.utc_offset == arg.to_i }
+          else
+            raise ArgumentError, "invalid argument to TimeZone[]: #{arg.inspect}"
+        end
+      end
+
+      # A convenience method for returning a collection of TimeZone objects
+      # for time zones in the USA.
+      def us_zones
+        US_ZONES
+      end
     end
   end
 end
diff --git a/activesupport/test/core_ext/date_ext_test.rb b/activesupport/test/core_ext/date_ext_test.rb
index 5925ae3..aa9c160 100644
--- a/activesupport/test/core_ext/date_ext_test.rb
+++ b/activesupport/test/core_ext/date_ext_test.rb
@@ -171,7 +171,7 @@ class DateExtCalculationsTest < Test::Unit::TestCase
 
   def test_last_month_on_31st
     assert_equal Date.new(2004, 2, 29), Date.new(2004, 3, 31).last_month
-  end  
+  end
 
   def test_yesterday_constructor
     assert_equal Date.today - 1, Date.yesterday
@@ -196,7 +196,7 @@ class DateExtCalculationsTest < Test::Unit::TestCase
   def test_end_of_day
     assert_equal Time.local(2005,2,21,23,59,59), Date.new(2005,2,21).end_of_day
   end
-  
+
   def test_xmlschema
     with_env_tz 'US/Eastern' do
       assert_match(/^1980-02-28T00:00:00-05:?00$/, Date.new(1980, 2, 28).xmlschema)
@@ -208,7 +208,7 @@ class DateExtCalculationsTest < Test::Unit::TestCase
       end
     end
   end
-  
+
   uses_mocha 'TestDateCurrent' do
     def test_current_returns_date_today_when_zone_default_not_set
       with_env_tz 'US/Central' do
@@ -217,10 +217,10 @@ class DateExtCalculationsTest < Test::Unit::TestCase
         assert_equal Date.new(1999, 12, 31), Date.current
       end
     end
-    
+
     def test_current_returns_time_zone_today_when_zone_default_set
       silence_warnings do # silence warnings raised by tzinfo gem
-        Time.zone_default = TimeZone['Eastern Time (US & Canada)']
+        Time.zone_default = ActiveSupport::TimeZone['Eastern Time (US & Canada)']
         with_env_tz 'US/Central' do
           Time.stubs(:now).returns Time.local(1999, 12, 31, 23)
           assert_equal Date.new(1999, 12, 31), Date.today
@@ -238,5 +238,5 @@ class DateExtCalculationsTest < Test::Unit::TestCase
       yield
     ensure
       old_tz ? ENV['TZ'] = old_tz : ENV.delete('TZ')
-    end  
+    end
 end
diff --git a/activesupport/test/core_ext/date_time_ext_test.rb b/activesupport/test/core_ext/date_time_ext_test.rb
index ed45daf..854a3a0 100644
--- a/activesupport/test/core_ext/date_time_ext_test.rb
+++ b/activesupport/test/core_ext/date_time_ext_test.rb
@@ -219,14 +219,14 @@ class DateTimeExtCalculationsTest < Test::Unit::TestCase
       assert_equal Rational(-6, 24), DateTime.local_offset
     end
   end
-  
+
   def test_utc?
     assert_equal true, DateTime.civil(2005, 2, 21, 10, 11, 12).utc?
     assert_equal true, DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc?
     assert_equal false, DateTime.civil(2005, 2, 21, 10, 11, 12, 0.25).utc?
     assert_equal false, DateTime.civil(2005, 2, 21, 10, 11, 12, -0.25).utc?
   end
-  
+
   def test_utc_offset
     assert_equal 0, DateTime.civil(2005, 2, 21, 10, 11, 12).utc_offset
     assert_equal 0, DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc_offset
@@ -234,7 +234,7 @@ class DateTimeExtCalculationsTest < Test::Unit::TestCase
     assert_equal( -21600, DateTime.civil(2005, 2, 21, 10, 11, 12, -0.25).utc_offset )
     assert_equal( -18000, DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24)).utc_offset )
   end
-  
+
   def test_utc
     assert_equal DateTime.civil(2005, 2, 21, 16, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc
     assert_equal DateTime.civil(2005, 2, 21, 15, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24)).utc
@@ -242,37 +242,37 @@ class DateTimeExtCalculationsTest < Test::Unit::TestCase
     assert_equal DateTime.civil(2005, 2, 21, 9, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(1, 24)).utc
     assert_equal DateTime.civil(2005, 2, 21, 9, 11, 12, 0), DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(1, 24)).getutc
   end
-  
+
   def test_formatted_offset_with_utc
     assert_equal '+00:00', DateTime.civil(2000).formatted_offset
     assert_equal '+0000', DateTime.civil(2000).formatted_offset(false)
     assert_equal 'UTC', DateTime.civil(2000).formatted_offset(true, 'UTC')
   end
-  
+
   def test_formatted_offset_with_local
     dt = DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-5, 24))
     assert_equal '-05:00', dt.formatted_offset
     assert_equal '-0500', dt.formatted_offset(false)
   end
-  
+
   def test_compare_with_time
     assert_equal  1, DateTime.civil(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59)
     assert_equal  0, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0)
     assert_equal(-1, DateTime.civil(2000) <=> Time.utc(2000, 1, 1, 0, 0, 1))
   end
-  
+
   def test_compare_with_datetime
     assert_equal  1, DateTime.civil(2000) <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
     assert_equal  0, DateTime.civil(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
     assert_equal(-1, DateTime.civil(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
   end
-  
+
   def test_compare_with_time_with_zone
-    assert_equal  1, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(1999, 12, 31, 23, 59, 59), TimeZone['UTC'] )
-    assert_equal  0, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 0), TimeZone['UTC'] )
-    assert_equal(-1, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 1), TimeZone['UTC'] ))
+    assert_equal  1, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(1999, 12, 31, 23, 59, 59), ActiveSupport::TimeZone['UTC'] )
+    assert_equal  0, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone['UTC'] )
+    assert_equal(-1, DateTime.civil(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 1), ActiveSupport::TimeZone['UTC'] ))
   end
-  
+
   def test_to_f
     assert_equal 946684800.0, DateTime.civil(2000).to_f
     assert_equal 946684800.0, DateTime.civil(1999,12,31,19,0,0,Rational(-5,24)).to_f
diff --git a/activesupport/test/core_ext/duration_test.rb b/activesupport/test/core_ext/duration_test.rb
index 7b17fe7..f802ed8 100644
--- a/activesupport/test/core_ext/duration_test.rb
+++ b/activesupport/test/core_ext/duration_test.rb
@@ -29,7 +29,7 @@ class DurationTest < Test::Unit::TestCase
       flunk("ArgumentError should be raised, but we got #{$!.class} instead")
     end
   end
-  
+
   uses_mocha 'TestDurationSinceAndAgoWithCurrentTime' do
     def test_since_and_ago_anchored_to_time_now_when_time_zone_default_not_set
       Time.zone_default = nil
@@ -43,10 +43,10 @@ class DurationTest < Test::Unit::TestCase
         assert_equal Time.local(1999,12,31,23,59,55), 5.seconds.ago
       end
     end
-    
+
     def test_since_and_ago_anchored_to_time_zone_now_when_time_zone_default_set
       silence_warnings do # silence warnings raised by tzinfo gem
-        Time.zone_default = TimeZone['Eastern Time (US & Canada)']
+        Time.zone_default = ActiveSupport::TimeZone['Eastern Time (US & Canada)']
         with_env_tz 'US/Eastern' do
           Time.stubs(:now).returns Time.local(2000)
           # since
@@ -63,7 +63,7 @@ class DurationTest < Test::Unit::TestCase
       Time.zone_default = nil
     end
   end
-  
+
   protected
     def with_env_tz(new_tz = 'US/Eastern')
       old_tz, ENV['TZ'] = ENV['TZ'], new_tz
diff --git a/activesupport/test/core_ext/time_ext_test.rb b/activesupport/test/core_ext/time_ext_test.rb
index e53b719..17a0968 100644
--- a/activesupport/test/core_ext/time_ext_test.rb
+++ b/activesupport/test/core_ext/time_ext_test.rb
@@ -449,7 +449,7 @@ class TimeExtCalculationsTest < Test::Unit::TestCase
     assert_equal "17:44",                           time.to_s(:time)
     assert_equal "February 21, 2005 17:44",         time.to_s(:long)
     assert_equal "February 21st, 2005 17:44",       time.to_s(:long_ordinal)
-    with_env_tz "UTC" do 
+    with_env_tz "UTC" do
       assert_equal "Mon, 21 Feb 2005 17:44:30 +0000", time.to_s(:rfc822)
     end
   end
@@ -505,13 +505,13 @@ class TimeExtCalculationsTest < Test::Unit::TestCase
     assert_equal 30, Time.days_in_month(11, 2005)
     assert_equal 31, Time.days_in_month(12, 2005)
   end
-  
+
   uses_mocha 'TestTimeDaysInMonthWithoutYearArg' do
     def test_days_in_month_feb_in_common_year_without_year_arg
       Time.stubs(:now).returns(Time.utc(2007))
       assert_equal 28, Time.days_in_month(2)
     end
-  
+
     def test_days_in_month_feb_in_leap_year_without_year_arg
       Time.stubs(:now).returns(Time.utc(2008))
       assert_equal 29, Time.days_in_month(2)
@@ -559,13 +559,13 @@ class TimeExtCalculationsTest < Test::Unit::TestCase
   def test_acts_like_time
     assert Time.new.acts_like_time?
   end
-  
+
   def test_formatted_offset_with_utc
     assert_equal '+00:00', Time.utc(2000).formatted_offset
     assert_equal '+0000', Time.utc(2000).formatted_offset(false)
     assert_equal 'UTC', Time.utc(2000).formatted_offset(true, 'UTC')
   end
-  
+
   def test_formatted_offset_with_local
     with_env_tz 'US/Eastern' do
       assert_equal '-05:00', Time.local(2000).formatted_offset
@@ -574,27 +574,27 @@ class TimeExtCalculationsTest < Test::Unit::TestCase
       assert_equal '-0400', Time.local(2000, 7).formatted_offset(false)
     end
   end
-  
+
   def test_compare_with_time
     assert_equal  1, Time.utc(2000) <=> Time.utc(1999, 12, 31, 23, 59, 59, 999)
     assert_equal  0, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0)
     assert_equal(-1, Time.utc(2000) <=> Time.utc(2000, 1, 1, 0, 0, 0, 001))
   end
-  
+
   def test_compare_with_datetime
     assert_equal  1, Time.utc(2000) <=> DateTime.civil(1999, 12, 31, 23, 59, 59)
     assert_equal  0, Time.utc(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 0)
     assert_equal(-1, Time.utc(2000) <=> DateTime.civil(2000, 1, 1, 0, 0, 1))
   end
-  
+
   def test_compare_with_time_with_zone
-    assert_equal  1, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(1999, 12, 31, 23, 59, 59), TimeZone['UTC'] )
-    assert_equal  0, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 0), TimeZone['UTC'] )
-    assert_equal(-1, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 1), TimeZone['UTC'] ))
+    assert_equal  1, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(1999, 12, 31, 23, 59, 59), ActiveSupport::TimeZone['UTC'] )
+    assert_equal  0, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone['UTC'] )
+    assert_equal(-1, Time.utc(2000) <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 1), ActiveSupport::TimeZone['UTC'] ))
   end
-  
+
   def test_minus_with_time_with_zone
-    assert_equal  86_400.0, Time.utc(2000, 1, 2) - ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), TimeZone['UTC'] )
+    assert_equal  86_400.0, Time.utc(2000, 1, 2) - ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), ActiveSupport::TimeZone['UTC'] )
   end
 
   def test_time_created_with_local_constructor_cannot_represent_times_during_hour_skipped_by_dst
@@ -608,7 +608,7 @@ class TimeExtCalculationsTest < Test::Unit::TestCase
 
   def test_case_equality
     assert Time === Time.utc(2000)
-    assert Time === ActiveSupport::TimeWithZone.new(Time.utc(2000), TimeZone['UTC'])
+    assert Time === ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone['UTC'])
     assert_equal false, Time === DateTime.civil(2000)
   end
 
diff --git a/activesupport/test/core_ext/time_with_zone_test.rb b/activesupport/test/core_ext/time_with_zone_test.rb
index c373bca..ad615ae 100644
--- a/activesupport/test/core_ext/time_with_zone_test.rb
+++ b/activesupport/test/core_ext/time_with_zone_test.rb
@@ -1,10 +1,9 @@
 require 'abstract_unit'
-  
-class TimeWithZoneTest < Test::Unit::TestCase
 
+class TimeWithZoneTest < Test::Unit::TestCase
   def setup
     @utc = Time.utc(2000, 1, 1, 0)
-    @time_zone = TimeZone['Eastern Time (US & Canada)']
+    @time_zone = ActiveSupport::TimeZone['Eastern Time (US & Canada)']
     @twz = ActiveSupport::TimeWithZone.new(@utc, @time_zone)
   end
 
@@ -21,114 +20,114 @@ class TimeWithZoneTest < Test::Unit::TestCase
   def test_time_zone
     assert_equal @time_zone, @twz.time_zone
   end
-  
+
   def test_in_time_zone
     Time.use_zone 'Alaska' do
-      assert_equal ActiveSupport::TimeWithZone.new(@utc, TimeZone['Alaska']), @twz.in_time_zone
+      assert_equal ActiveSupport::TimeWithZone.new(@utc, ActiveSupport::TimeZone['Alaska']), @twz.in_time_zone
     end
   end
 
   def test_in_time_zone_with_argument
-    assert_equal ActiveSupport::TimeWithZone.new(@utc, TimeZone['Alaska']), @twz.in_time_zone('Alaska')
+    assert_equal ActiveSupport::TimeWithZone.new(@utc, ActiveSupport::TimeZone['Alaska']), @twz.in_time_zone('Alaska')
   end
-  
+
   def test_in_time_zone_with_new_zone_equal_to_old_zone_does_not_create_new_object
-    assert_equal @twz.object_id, @twz.in_time_zone(TimeZone['Eastern Time (US & Canada)']).object_id
+    assert_equal @twz.object_id, @twz.in_time_zone(ActiveSupport::TimeZone['Eastern Time (US & Canada)']).object_id
   end
 
   def test_utc?
     assert_equal false, @twz.utc?
-    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), TimeZone['UTC']).utc?
+    assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone['UTC']).utc?
   end
-    
+
   def test_formatted_offset
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal '-05:00', @twz.formatted_offset
       assert_equal '-04:00', ActiveSupport::TimeWithZone.new(Time.utc(2000, 6), @time_zone).formatted_offset #dst
     end
   end
-    
+
   def test_dst?
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal false, @twz.dst?
       assert_equal true, ActiveSupport::TimeWithZone.new(Time.utc(2000, 6), @time_zone).dst?
     end
   end
-    
+
   def test_zone
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal 'EST', @twz.zone
       assert_equal 'EDT', ActiveSupport::TimeWithZone.new(Time.utc(2000, 6), @time_zone).zone #dst
     end
   end
-    
+
   def test_to_json
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal "\"1999/12/31 19:00:00 -0500\"", @twz.to_json
     end
   end
-  
+
   def test_to_json_with_use_standard_json_time_format_config_set_to_true
     old, ActiveSupport.use_standard_json_time_format = ActiveSupport.use_standard_json_time_format, true
     assert_equal "\"1999-12-31T19:00:00-05:00\"", @twz.to_json
   ensure
     ActiveSupport.use_standard_json_time_format = old
   end
-    
+
   def test_strftime
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal '1999-12-31 19:00:00 EST -0500', @twz.strftime('%Y-%m-%d %H:%M:%S %Z %z')
     end
   end
-    
+
   def test_inspect
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal 'Fri, 31 Dec 1999 19:00:00 EST -05:00', @twz.inspect
     end
   end
-    
+
   def test_to_s
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal '1999-12-31 19:00:00 -0500', @twz.to_s
     end
   end
-    
+
   def test_to_s_db
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal '2000-01-01 00:00:00', @twz.to_s(:db)
     end
   end
-    
+
   def test_xmlschema
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal "1999-12-31T19:00:00-05:00", @twz.xmlschema
     end
   end
-  
+
   def test_to_yaml
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal "--- 1999-12-31 19:00:00 -05:00\n", @twz.to_yaml
     end
   end
-  
+
   def test_ruby_to_yaml
     silence_warnings do
       assert_equal "--- \n:twz: 2000-01-01 00:00:00 Z\n", {:twz => @twz}.to_yaml
     end
   end
-  
+
   def test_httpdate
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal 'Sat, 01 Jan 2000 00:00:00 GMT', @twz.httpdate
     end
   end
-  
+
   def test_rfc2822
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal "Fri, 31 Dec 1999 19:00:00 -0500", @twz.rfc2822
     end
   end
-  
+
   def test_compare_with_time
     assert_equal  1, @twz <=> Time.utc(1999, 12, 31, 23, 59, 59)
     assert_equal  0, @twz <=> Time.utc(2000, 1, 1, 0, 0, 0)
@@ -142,27 +141,27 @@ class TimeWithZoneTest < Test::Unit::TestCase
   end
 
   def test_compare_with_time_with_zone
-    assert_equal  1, @twz <=> ActiveSupport::TimeWithZone.new( Time.utc(1999, 12, 31, 23, 59, 59), TimeZone['UTC'] )
-    assert_equal  0, @twz <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 0), TimeZone['UTC'] )
-    assert_equal(-1, @twz <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 1), TimeZone['UTC'] ))
+    assert_equal  1, @twz <=> ActiveSupport::TimeWithZone.new( Time.utc(1999, 12, 31, 23, 59, 59), ActiveSupport::TimeZone['UTC'] )
+    assert_equal  0, @twz <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 0), ActiveSupport::TimeZone['UTC'] )
+    assert_equal(-1, @twz <=> ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 0, 0, 1), ActiveSupport::TimeZone['UTC'] ))
   end
-  
+
   def test_between?
     assert @twz.between?(Time.utc(1999,12,31,23,59,59), Time.utc(2000,1,1,0,0,1))
     assert_equal false, @twz.between?(Time.utc(2000,1,1,0,0,1), Time.utc(2000,1,1,0,0,2))
   end
-  
+
   def test_eql?
     assert @twz.eql?(Time.utc(2000))
-    assert @twz.eql?( ActiveSupport::TimeWithZone.new(Time.utc(2000), TimeZone["Hawaii"]) )
+    assert @twz.eql?( ActiveSupport::TimeWithZone.new(Time.utc(2000), ActiveSupport::TimeZone["Hawaii"]) )
   end
-    
+
   def test_plus_with_integer
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal Time.utc(1999, 12, 31, 19, 0 ,5), (@twz + 5).time
     end
   end
-    
+
   def test_plus_with_integer_when_self_wraps_datetime
     silence_warnings do # silence warnings raised by tzinfo gem
       datetime = DateTime.civil(2000, 1, 1, 0)
@@ -170,26 +169,26 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal DateTime.civil(1999, 12, 31, 19, 0 ,5), (twz + 5).time
     end
   end
-  
+
   def test_plus_when_crossing_time_class_limit
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(Time.utc(2038, 1, 19), @time_zone)
       assert_equal [0, 0, 19, 19, 1, 2038], (twz + 86_400).to_a[0,6]
     end
   end
-    
+
   def test_plus_with_duration
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal Time.utc(2000, 1, 5, 19, 0 ,0), (@twz + 5.days).time
     end
   end
-    
+
   def test_minus_with_integer
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal Time.utc(1999, 12, 31, 18, 59 ,55), (@twz - 5).time
     end
   end
-  
+
   def test_minus_with_integer_when_self_wraps_datetime
     silence_warnings do # silence warnings raised by tzinfo gem
       datetime = DateTime.civil(2000, 1, 1, 0)
@@ -197,24 +196,24 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal DateTime.civil(1999, 12, 31, 18, 59 ,55), (twz - 5).time
     end
   end
-    
+
   def test_minus_with_duration
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal Time.utc(1999, 12, 26, 19, 0 ,0), (@twz - 5.days).time
     end
   end
-  
+
   def test_minus_with_time
-    assert_equal  86_400.0,  ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2), TimeZone['UTC'] ) - Time.utc(2000, 1, 1)
-    assert_equal  86_400.0,  ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2), TimeZone['Hawaii'] ) - Time.utc(2000, 1, 1)
+    assert_equal  86_400.0,  ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2), ActiveSupport::TimeZone['UTC'] ) - Time.utc(2000, 1, 1)
+    assert_equal  86_400.0,  ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2), ActiveSupport::TimeZone['Hawaii'] ) - Time.utc(2000, 1, 1)
   end
-  
+
   def test_minus_with_time_with_zone
-    twz1 = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), TimeZone['UTC'] )
-    twz2 = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2), TimeZone['UTC'] )
+    twz1 = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), ActiveSupport::TimeZone['UTC'] )
+    twz2 = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2), ActiveSupport::TimeZone['UTC'] )
     assert_equal  86_400.0,  twz2 - twz1
   end
-  
+
   def test_plus_and_minus_enforce_spring_dst_rules
     silence_warnings do # silence warnings raised by tzinfo gem
       utc = Time.utc(2006,4,2,6,59,59) # == Apr 2 2006 01:59:59 EST; i.e., 1 second before daylight savings start
@@ -232,7 +231,7 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal 'EST', twz.zone
     end
   end
-  
+
   def test_plus_and_minus_enforce_fall_dst_rules
     silence_warnings do # silence warnings raised by tzinfo gem
       utc = Time.utc(2006,10,29,5,59,59) # == Oct 29 2006 01:59:59 EST; i.e., 1 second before daylight savings end
@@ -250,25 +249,25 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal 'EDT', twz.zone
     end
   end
-  
+
   def test_to_a
     silence_warnings do # silence warnings raised by tzinfo gem
-      assert_equal [45, 30, 5, 1, 2, 2000, 2, 32, false, "HST"], ActiveSupport::TimeWithZone.new( Time.utc(2000, 2, 1, 15, 30, 45), TimeZone['Hawaii'] ).to_a
+      assert_equal [45, 30, 5, 1, 2, 2000, 2, 32, false, "HST"], ActiveSupport::TimeWithZone.new( Time.utc(2000, 2, 1, 15, 30, 45), ActiveSupport::TimeZone['Hawaii'] ).to_a
     end
   end
-  
+
   def test_to_f
-    result = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), TimeZone['Hawaii'] ).to_f
+    result = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), ActiveSupport::TimeZone['Hawaii'] ).to_f
     assert_equal 946684800.0, result
     assert result.is_a?(Float)
   end
-  
+
   def test_to_i
-    result = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), TimeZone['Hawaii'] ).to_i
+    result = ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1), ActiveSupport::TimeZone['Hawaii'] ).to_i
     assert_equal 946684800, result
     assert result.is_a?(Integer)
   end
-    
+
   def test_to_time
     assert_equal @twz, @twz.to_time
   end
@@ -276,55 +275,55 @@ class TimeWithZoneTest < Test::Unit::TestCase
   def test_to_date
     silence_warnings do # silence warnings raised by tzinfo gem
       # 1 sec before midnight Jan 1 EST
-      assert_equal Date.new(1999, 12, 31), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 4, 59, 59), TimeZone['Eastern Time (US & Canada)'] ).to_date
+      assert_equal Date.new(1999, 12, 31), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 4, 59, 59), ActiveSupport::TimeZone['Eastern Time (US & Canada)'] ).to_date
       # midnight Jan 1 EST
-      assert_equal Date.new(2000,  1,  1), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 5,  0,  0), TimeZone['Eastern Time (US & Canada)'] ).to_date
+      assert_equal Date.new(2000,  1,  1), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 1, 5,  0,  0), ActiveSupport::TimeZone['Eastern Time (US & Canada)'] ).to_date
       # 1 sec before midnight Jan 2 EST
-      assert_equal Date.new(2000,  1,  1), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2, 4, 59, 59), TimeZone['Eastern Time (US & Canada)'] ).to_date
+      assert_equal Date.new(2000,  1,  1), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2, 4, 59, 59), ActiveSupport::TimeZone['Eastern Time (US & Canada)'] ).to_date
       # midnight Jan 2 EST
-      assert_equal Date.new(2000,  1,  2), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2, 5,  0,  0), TimeZone['Eastern Time (US & Canada)'] ).to_date
+      assert_equal Date.new(2000,  1,  2), ActiveSupport::TimeWithZone.new( Time.utc(2000, 1, 2, 5,  0,  0), ActiveSupport::TimeZone['Eastern Time (US & Canada)'] ).to_date
     end
   end
-  
+
   def test_to_datetime
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal DateTime.civil(1999, 12, 31, 19, 0, 0, Rational(-18_000, 86_400)),  @twz.to_datetime
     end
   end
-    
+
   def test_acts_like_time
     assert @twz.acts_like?(:time)
     assert ActiveSupport::TimeWithZone.new(DateTime.civil(2000), @time_zone).acts_like?(:time)
   end
-  
+
   def test_acts_like_date
     assert_equal false, @twz.acts_like?(:date)
     assert_equal false, ActiveSupport::TimeWithZone.new(DateTime.civil(2000), @time_zone).acts_like?(:date)
   end
-  
+
   def test_is_a
     assert @twz.is_a?(Time)
     assert @twz.kind_of?(Time)
     assert @twz.is_a?(ActiveSupport::TimeWithZone)
   end
-    
+
   def test_method_missing_with_time_return_value
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_instance_of ActiveSupport::TimeWithZone, @twz.months_since(1)
       assert_equal Time.utc(2000, 1, 31, 19, 0 ,0), @twz.months_since(1).time
     end
   end
-  
+
   def test_marshal_dump_and_load
     silence_warnings do # silence warnings raised by tzinfo gem
       marshal_str = Marshal.dump(@twz)
       mtime = Marshal.load(marshal_str)
       assert_equal Time.utc(2000, 1, 1, 0), mtime.utc
-      assert_equal TimeZone['Eastern Time (US & Canada)'], mtime.time_zone
+      assert_equal ActiveSupport::TimeZone['Eastern Time (US & Canada)'], mtime.time_zone
       assert_equal Time.utc(1999, 12, 31, 19), mtime.time
     end
   end
-  
+
   def test_marshal_dump_and_load_with_tzinfo_identifier
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(@utc, TZInfo::Timezone.get('America/New_York'))
@@ -335,14 +334,14 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal Time.utc(1999, 12, 31, 19), mtime.time
     end
   end
-  
+
   def test_method_missing_with_non_time_return_value
     silence_warnings do # silence warnings raised by tzinfo gem
       @twz.time.expects(:foo).returns('bar')
       assert_equal 'bar', @twz.foo
     end
   end
-  
+
   def test_date_part_value_methods
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(Time.utc(1999,12,31,19,18,17,500), @time_zone)
@@ -356,14 +355,14 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal 500, twz.usec
     end
   end
-  
+
   def test_usec_returns_0_when_datetime_is_wrapped
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(DateTime.civil(2000), @time_zone)
       assert_equal 0, twz.usec
     end
   end
-  
+
   def test_utc_to_local_conversion_saves_period_in_instance_variable
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_nil @twz.instance_variable_get('@period')
@@ -371,14 +370,14 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_kind_of TZInfo::TimezonePeriod, @twz.instance_variable_get('@period')
     end
   end
-  
+
   def test_instance_created_with_local_time_returns_correct_utc_time
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(1999, 12, 31, 19))
       assert_equal Time.utc(2000), twz.utc
     end
   end
-  
+
   def test_instance_created_with_local_time_enforces_spring_dst_rules
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006,4,2,2)) # first second of DST
@@ -387,7 +386,7 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal 'EDT', twz.zone
     end
   end
-  
+
   def test_instance_created_with_local_time_enforces_fall_dst_rules
     silence_warnings do # silence warnings raised by tzinfo gem
       twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006,10,29,1)) # 1AM can be either DST or non-DST; we'll pick DST
@@ -396,14 +395,14 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal 'EDT', twz.zone
     end
   end
-  
+
   def test_ruby_19_weekday_name_query_methods
     ruby_19_or_greater = RUBY_VERSION >= '1.9'
     %w(sunday? monday? tuesday? wednesday? thursday? friday? saturday?).each do |name|
       assert_equal ruby_19_or_greater, @twz.respond_to?(name)
     end
   end
-  
+
   def test_utc_to_local_conversion_with_far_future_datetime
     silence_warnings do # silence warnings raised by tzinfo gem
       assert_equal [0,0,19,31,12,2049], ActiveSupport::TimeWithZone.new(DateTime.civil(2050), @time_zone).to_a[0,6]
@@ -415,7 +414,7 @@ class TimeWithZoneTest < Test::Unit::TestCase
       assert_equal DateTime.civil(2050).to_f, ActiveSupport::TimeWithZone.new(nil, @time_zone, DateTime.civil(2049,12,31,19)).to_f
     end
   end
-  
+
   def test_change
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Mon, 31 Dec 2001 19:00:00 EST -05:00", @twz.change(:year => 2001).inspect
@@ -426,7 +425,7 @@ class TimeWithZoneTest < Test::Unit::TestCase
     assert_equal "Fri, 31 Dec 1999 19:15:00 EST -05:00", @twz.change(:min => 15).inspect
     assert_equal "Fri, 31 Dec 1999 19:00:30 EST -05:00", @twz.change(:sec => 30).inspect
   end
-  
+
   def test_advance
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Mon, 31 Dec 2001 19:00:00 EST -05:00", @twz.advance(:years => 2).inspect
@@ -436,77 +435,77 @@ class TimeWithZoneTest < Test::Unit::TestCase
     assert_equal "Fri, 31 Dec 1999 19:15:00 EST -05:00", @twz.advance(:minutes => 15).inspect
     assert_equal "Fri, 31 Dec 1999 19:00:30 EST -05:00", @twz.advance(:seconds => 30).inspect
   end
-  
+
   def beginning_of_year
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Fri, 01 Jan 1999 00:00:00 EST -05:00", @twz.beginning_of_year.inspect
   end
-  
+
   def end_of_year
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Fri, 31 Dec 1999 23:59:59 EST -05:00", @twz.end_of_year.inspect
   end
-  
+
   def beginning_of_month
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Fri, 01 Dec 1999 00:00:00 EST -05:00", @twz.beginning_of_month.inspect
   end
-  
+
   def end_of_month
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Fri, 31 Dec 1999 23:59:59 EST -05:00", @twz.end_of_month.inspect
   end
-  
+
   def beginning_of_day
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Fri, 31 Dec 1999 00:00:00 EST -05:00", @twz.beginning_of_day.inspect
   end
-  
+
   def end_of_day
     assert_equal "Fri, 31 Dec 1999 19:00:00 EST -05:00", @twz.inspect
     assert_equal "Fri, 31 Dec 1999 23:59:59 EST -05:00", @twz.end_of_day.inspect
   end
-  
+
   def test_since
     assert_equal "Fri, 31 Dec 1999 19:00:01 EST -05:00", @twz.since(1).inspect
   end
-  
+
   def test_ago
     assert_equal "Fri, 31 Dec 1999 18:59:59 EST -05:00", @twz.ago(1).inspect
   end
-  
+
   def test_seconds_since_midnight
     assert_equal 19 * 60 * 60, @twz.seconds_since_midnight
   end
-  
+
   def test_advance_1_year_from_leap_day
     twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2004,2,29))
     assert_equal "Mon, 28 Feb 2005 00:00:00 EST -05:00", twz.advance(:years => 1).inspect
     assert_equal "Mon, 28 Feb 2005 00:00:00 EST -05:00", twz.years_since(1).inspect
     assert_equal "Mon, 28 Feb 2005 00:00:00 EST -05:00", (twz + 1.year).inspect
   end
-  
+
   def test_advance_1_month_from_last_day_of_january
     twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2005,1,31))
     assert_equal "Mon, 28 Feb 2005 00:00:00 EST -05:00", twz.advance(:months => 1).inspect
     assert_equal "Mon, 28 Feb 2005 00:00:00 EST -05:00", twz.months_since(1).inspect
     assert_equal "Mon, 28 Feb 2005 00:00:00 EST -05:00", (twz + 1.month).inspect
   end
-  
+
   def test_advance_1_month_from_last_day_of_january_during_leap_year
     twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2000,1,31))
     assert_equal "Tue, 29 Feb 2000 00:00:00 EST -05:00", twz.advance(:months => 1).inspect
     assert_equal "Tue, 29 Feb 2000 00:00:00 EST -05:00", twz.months_since(1).inspect
     assert_equal "Tue, 29 Feb 2000 00:00:00 EST -05:00", (twz + 1.month).inspect
   end
-  
+
   def test_advance_1_month_into_spring_dst_gap
     twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006,3,2,2))
     assert_equal "Sun, 02 Apr 2006 03:00:00 EDT -04:00", twz.advance(:months => 1).inspect
     assert_equal "Sun, 02 Apr 2006 03:00:00 EDT -04:00", twz.months_since(1).inspect
     assert_equal "Sun, 02 Apr 2006 03:00:00 EDT -04:00", (twz + 1.month).inspect
   end
-  
+
   def test_advance_1_second_into_spring_dst_gap
     twz = ActiveSupport::TimeWithZone.new(nil, @time_zone, Time.utc(2006,4,2,1,59,59))
     assert_equal "Sun, 02 Apr 2006 03:00:00 EDT -04:00", twz.advance(:seconds => 1).inspect
@@ -519,11 +518,11 @@ class TimeWithZoneMethodsForTimeAndDateTimeTest < Test::Unit::TestCase
   def setup
     @t, @dt = Time.utc(2000), DateTime.civil(2000)
   end
-  
+
   def teardown
     Time.zone = nil
   end
-  
+
   def test_in_time_zone
     silence_warnings do # silence warnings raised by tzinfo gem
       Time.use_zone 'Alaska' do
@@ -554,7 +553,7 @@ class TimeWithZoneMethodsForTimeAndDateTimeTest < Test::Unit::TestCase
       end
     end
   end
-  
+
   def test_in_time_zone_with_time_local_instance
     silence_warnings do # silence warnings raised by tzinfo gem
       with_env_tz 'US/Eastern' do
@@ -563,85 +562,85 @@ class TimeWithZoneMethodsForTimeAndDateTimeTest < Test::Unit::TestCase
       end
     end
   end
-  
+
   def test_use_zone
     Time.zone = 'Alaska'
     Time.use_zone 'Hawaii' do
-      assert_equal TimeZone['Hawaii'], Time.zone
+      assert_equal ActiveSupport::TimeZone['Hawaii'], Time.zone
     end
-    assert_equal TimeZone['Alaska'], Time.zone
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
   end
-  
+
   def test_use_zone_with_exception_raised
     Time.zone = 'Alaska'
     assert_raises RuntimeError do
       Time.use_zone('Hawaii') { raise RuntimeError }
     end
-    assert_equal TimeZone['Alaska'], Time.zone
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
   end
-  
+
   def test_time_zone_getter_and_setter
-    Time.zone = TimeZone['Alaska']
-    assert_equal TimeZone['Alaska'], Time.zone
+    Time.zone = ActiveSupport::TimeZone['Alaska']
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
     Time.zone = 'Alaska'
-    assert_equal TimeZone['Alaska'], Time.zone
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
     Time.zone = -9.hours
-    assert_equal TimeZone['Alaska'], Time.zone
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
     Time.zone = nil
     assert_equal nil, Time.zone
   end
-  
+
   def test_time_zone_getter_and_setter_with_zone_default
-    Time.zone_default = TimeZone['Alaska']
-    assert_equal TimeZone['Alaska'], Time.zone
-    Time.zone = TimeZone['Hawaii']
-    assert_equal TimeZone['Hawaii'], Time.zone
+    Time.zone_default = ActiveSupport::TimeZone['Alaska']
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
+    Time.zone = ActiveSupport::TimeZone['Hawaii']
+    assert_equal ActiveSupport::TimeZone['Hawaii'], Time.zone
     Time.zone = nil
-    assert_equal TimeZone['Alaska'], Time.zone
+    assert_equal ActiveSupport::TimeZone['Alaska'], Time.zone
   ensure
     Time.zone_default = nil
   end
-  
+
   def test_time_zone_setter_is_thread_safe
     Time.use_zone 'Paris' do
       t1 = Thread.new { Time.zone = 'Alaska' }.join
       t2 = Thread.new { Time.zone = 'Hawaii' }.join
       assert t1.stop?, "Thread 1 did not finish running"
       assert t2.stop?, "Thread 2 did not finish running"
-      assert_equal TimeZone['Paris'], Time.zone
-      assert_equal TimeZone['Alaska'], t1[:time_zone]
-      assert_equal TimeZone['Hawaii'], t2[:time_zone]
+      assert_equal ActiveSupport::TimeZone['Paris'], Time.zone
+      assert_equal ActiveSupport::TimeZone['Alaska'], t1[:time_zone]
+      assert_equal ActiveSupport::TimeZone['Hawaii'], t2[:time_zone]
     end
   end
-  
+
   def test_time_zone_setter_with_tzinfo_timezone_object_wraps_in_rails_time_zone
     silence_warnings do # silence warnings raised by tzinfo gem
       tzinfo = TZInfo::Timezone.get('America/New_York')
       Time.zone = tzinfo
-      assert_kind_of TimeZone, Time.zone
+      assert_kind_of ActiveSupport::TimeZone, Time.zone
       assert_equal tzinfo, Time.zone.tzinfo
       assert_equal 'America/New_York', Time.zone.name
       assert_equal(-18_000, Time.zone.utc_offset)
     end
   end
-  
+
   def test_time_zone_setter_with_tzinfo_timezone_identifier_does_lookup_and_wraps_in_rails_time_zone
     silence_warnings do # silence warnings raised by tzinfo gem
       Time.zone = 'America/New_York'
-      assert_kind_of TimeZone, Time.zone
+      assert_kind_of ActiveSupport::TimeZone, Time.zone
       assert_equal 'America/New_York', Time.zone.tzinfo.name
       assert_equal 'America/New_York', Time.zone.name
       assert_equal(-18_000, Time.zone.utc_offset)
     end
   end
-  
+
   def test_time_zone_setter_with_non_identifying_argument_returns_nil
     Time.zone = 'foo'
     assert_equal nil, Time.zone
     Time.zone = -15.hours
     assert_equal nil, Time.zone
   end
-  
+
   uses_mocha 'TestTimeCurrent' do
     def test_current_returns_time_now_when_zone_default_not_set
       with_env_tz 'US/Eastern' do
@@ -650,10 +649,10 @@ class TimeWithZoneMethodsForTimeAndDateTimeTest < Test::Unit::TestCase
         assert_equal Time.local(2000), Time.current
       end
     end
-    
+
     def test_current_returns_time_zone_now_when_zone_default_set
       silence_warnings do # silence warnings raised by tzinfo gem
-        Time.zone_default = TimeZone['Eastern Time (US & Canada)']
+        Time.zone_default = ActiveSupport::TimeZone['Eastern Time (US & Canada)']
         with_env_tz 'US/Eastern' do
           Time.stubs(:now).returns Time.local(2000)
           assert_equal true, Time.current.is_a?(ActiveSupport::TimeWithZone)
@@ -665,7 +664,7 @@ class TimeWithZoneMethodsForTimeAndDateTimeTest < Test::Unit::TestCase
       Time.zone_default = nil
     end
   end
-  
+
   protected
     def with_env_tz(new_tz = 'US/Eastern')
       old_tz, ENV['TZ'] = ENV['TZ'], new_tz
diff --git a/activesupport/test/dependencies_test.rb b/activesupport/test/dependencies_test.rb
index 1e19e12..02472bf 100644
--- a/activesupport/test/dependencies_test.rb
+++ b/activesupport/test/dependencies_test.rb
@@ -15,31 +15,31 @@ end
 
 class DependenciesTest < Test::Unit::TestCase
   def teardown
-    Dependencies.clear
+    ActiveSupport::Dependencies.clear
   end
 
   def with_loading(*from)
-    old_mechanism, Dependencies.mechanism = Dependencies.mechanism, :load
+    old_mechanism, ActiveSupport::Dependencies.mechanism = ActiveSupport::Dependencies.mechanism, :load
     dir = File.dirname(__FILE__)
-    prior_load_paths = Dependencies.load_paths
-    Dependencies.load_paths = from.collect { |f| "#{dir}/#{f}" }
+    prior_load_paths = ActiveSupport::Dependencies.load_paths
+    ActiveSupport::Dependencies.load_paths = from.collect { |f| "#{dir}/#{f}" }
     yield
   ensure
-    Dependencies.load_paths = prior_load_paths
-    Dependencies.mechanism = old_mechanism
-    Dependencies.explicitly_unloadable_constants = []
+    ActiveSupport::Dependencies.load_paths = prior_load_paths
+    ActiveSupport::Dependencies.mechanism = old_mechanism
+    ActiveSupport::Dependencies.explicitly_unloadable_constants = []
   end
 
   def test_tracking_loaded_files
     require_dependency 'dependencies/service_one'
     require_dependency 'dependencies/service_two'
-    assert_equal 2, Dependencies.loaded.size
+    assert_equal 2, ActiveSupport::Dependencies.loaded.size
   end
 
   def test_tracking_identical_loaded_files
     require_dependency 'dependencies/service_one'
     require_dependency 'dependencies/service_one'
-    assert_equal 1, Dependencies.loaded.size
+    assert_equal 1, ActiveSupport::Dependencies.loaded.size
   end
 
   def test_missing_dependency_raises_missing_source_file
@@ -64,46 +64,46 @@ class DependenciesTest < Test::Unit::TestCase
         end
         assert_equal count + 1, $raises_exception_load_count
 
-        assert !Dependencies.loaded.include?(filename)
-        assert !Dependencies.history.include?(filename)
+        assert !ActiveSupport::Dependencies.loaded.include?(filename)
+        assert !ActiveSupport::Dependencies.history.include?(filename)
       end
     end
   end
 
   def test_warnings_should_be_enabled_on_first_load
     with_loading 'dependencies' do
-      old_warnings, Dependencies.warnings_on_first_load = Dependencies.warnings_on_first_load, true
+      old_warnings, ActiveSupport::Dependencies.warnings_on_first_load = ActiveSupport::Dependencies.warnings_on_first_load, true
 
       filename = "check_warnings"
       expanded = File.expand_path("test/dependencies/#{filename}")
       $check_warnings_load_count = 0
 
-      assert !Dependencies.loaded.include?(expanded)
-      assert !Dependencies.history.include?(expanded)
+      assert !ActiveSupport::Dependencies.loaded.include?(expanded)
+      assert !ActiveSupport::Dependencies.history.include?(expanded)
 
       silence_warnings { require_dependency filename }
       assert_equal 1, $check_warnings_load_count
       assert_equal true, $checked_verbose, 'On first load warnings should be enabled.'
 
-      assert Dependencies.loaded.include?(expanded)
-      Dependencies.clear
-      assert !Dependencies.loaded.include?(expanded)
-      assert Dependencies.history.include?(expanded)
+      assert ActiveSupport::Dependencies.loaded.include?(expanded)
+      ActiveSupport::Dependencies.clear
+      assert !ActiveSupport::Dependencies.loaded.include?(expanded)
+      assert ActiveSupport::Dependencies.history.include?(expanded)
 
       silence_warnings { require_dependency filename }
       assert_equal 2, $check_warnings_load_count
       assert_equal nil, $checked_verbose, 'After first load warnings should be left alone.'
 
-      assert Dependencies.loaded.include?(expanded)
-      Dependencies.clear
-      assert !Dependencies.loaded.include?(expanded)
-      assert Dependencies.history.include?(expanded)
+      assert ActiveSupport::Dependencies.loaded.include?(expanded)
+      ActiveSupport::Dependencies.clear
+      assert !ActiveSupport::Dependencies.loaded.include?(expanded)
+      assert ActiveSupport::Dependencies.history.include?(expanded)
 
       enable_warnings { require_dependency filename }
       assert_equal 3, $check_warnings_load_count
       assert_equal true, $checked_verbose, 'After first load warnings should be left alone.'
 
-      assert Dependencies.loaded.include?(expanded)
+      assert ActiveSupport::Dependencies.loaded.include?(expanded)
     end
   end
 
@@ -113,7 +113,7 @@ class DependenciesTest < Test::Unit::TestCase
       assert_nothing_raised { require_dependency 'mutual_one' }
       assert_equal 2, $mutual_dependencies_count
 
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
 
       $mutual_dependencies_count = 0
       assert_nothing_raised { require_dependency 'mutual_two' }
@@ -239,7 +239,7 @@ class DependenciesTest < Test::Unit::TestCase
   end
 
   def test_loadable_constants_for_path_should_handle_empty_autoloads
-    assert_equal [], Dependencies.loadable_constants_for_path('hello')
+    assert_equal [], ActiveSupport::Dependencies.loadable_constants_for_path('hello')
   end
 
   def test_loadable_constants_for_path_should_handle_relative_paths
@@ -247,7 +247,7 @@ class DependenciesTest < Test::Unit::TestCase
     relative_root = File.dirname(__FILE__) + '/dependencies'
     ['', '/'].each do |suffix|
       with_loading fake_root + suffix do
-        assert_equal ["A::B"], Dependencies.loadable_constants_for_path(relative_root + '/a/b')
+        assert_equal ["A::B"], ActiveSupport::Dependencies.loadable_constants_for_path(relative_root + '/a/b')
       end
     end
   end
@@ -255,106 +255,106 @@ class DependenciesTest < Test::Unit::TestCase
   def test_loadable_constants_for_path_should_provide_all_results
     fake_root = '/usr/apps/backpack'
     with_loading fake_root, fake_root + '/lib' do
-      root = Dependencies.load_paths.first
-      assert_equal ["Lib::A::B", "A::B"], Dependencies.loadable_constants_for_path(root + '/lib/a/b')
+      root = ActiveSupport::Dependencies.load_paths.first
+      assert_equal ["Lib::A::B", "A::B"], ActiveSupport::Dependencies.loadable_constants_for_path(root + '/lib/a/b')
     end
   end
 
   def test_loadable_constants_for_path_should_uniq_results
     fake_root = '/usr/apps/backpack/lib'
     with_loading fake_root, fake_root + '/' do
-      root = Dependencies.load_paths.first
-      assert_equal ["A::B"], Dependencies.loadable_constants_for_path(root + '/a/b')
+      root = ActiveSupport::Dependencies.load_paths.first
+      assert_equal ["A::B"], ActiveSupport::Dependencies.loadable_constants_for_path(root + '/a/b')
     end
   end
 
   def test_loadable_constants_with_load_path_without_trailing_slash
     path = File.dirname(__FILE__) + '/autoloading_fixtures/class_folder/inline_class.rb'
     with_loading 'autoloading_fixtures/class/' do
-      assert_equal [], Dependencies.loadable_constants_for_path(path)
+      assert_equal [], ActiveSupport::Dependencies.loadable_constants_for_path(path)
     end
   end
 
   def test_qualified_const_defined
-    assert Dependencies.qualified_const_defined?("Object")
-    assert Dependencies.qualified_const_defined?("::Object")
-    assert Dependencies.qualified_const_defined?("::Object::Kernel")
-    assert Dependencies.qualified_const_defined?("::Object::Dependencies")
-    assert Dependencies.qualified_const_defined?("::Test::Unit::TestCase")
+    assert ActiveSupport::Dependencies.qualified_const_defined?("Object")
+    assert ActiveSupport::Dependencies.qualified_const_defined?("::Object")
+    assert ActiveSupport::Dependencies.qualified_const_defined?("::Object::Kernel")
+    assert ActiveSupport::Dependencies.qualified_const_defined?("::Object::ActiveSupport::Dependencies")
+    assert ActiveSupport::Dependencies.qualified_const_defined?("::Test::Unit::TestCase")
   end
 
   def test_qualified_const_defined_should_not_call_method_missing
     ModuleWithMissing.missing_count = 0
-    assert ! Dependencies.qualified_const_defined?("ModuleWithMissing::A")
+    assert ! ActiveSupport::Dependencies.qualified_const_defined?("ModuleWithMissing::A")
     assert_equal 0, ModuleWithMissing.missing_count
-    assert ! Dependencies.qualified_const_defined?("ModuleWithMissing::A::B")
+    assert ! ActiveSupport::Dependencies.qualified_const_defined?("ModuleWithMissing::A::B")
     assert_equal 0, ModuleWithMissing.missing_count
   end
 
   def test_autoloaded?
     with_loading 'autoloading_fixtures' do
-      assert ! Dependencies.autoloaded?("ModuleFolder")
-      assert ! Dependencies.autoloaded?("ModuleFolder::NestedClass")
+      assert ! ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
+      assert ! ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")
 
-      assert Dependencies.autoloaded?(ModuleFolder)
+      assert ActiveSupport::Dependencies.autoloaded?(ModuleFolder)
 
-      assert Dependencies.autoloaded?("ModuleFolder")
-      assert ! Dependencies.autoloaded?("ModuleFolder::NestedClass")
+      assert ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
+      assert ! ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")
 
-      assert Dependencies.autoloaded?(ModuleFolder::NestedClass)
+      assert ActiveSupport::Dependencies.autoloaded?(ModuleFolder::NestedClass)
 
-      assert Dependencies.autoloaded?("ModuleFolder")
-      assert Dependencies.autoloaded?("ModuleFolder::NestedClass")
+      assert ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
+      assert ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")
 
-      assert Dependencies.autoloaded?("::ModuleFolder")
-      assert Dependencies.autoloaded?(:ModuleFolder)
+      assert ActiveSupport::Dependencies.autoloaded?("::ModuleFolder")
+      assert ActiveSupport::Dependencies.autoloaded?(:ModuleFolder)
 
       # Anonymous modules aren't autoloaded.
-      assert !Dependencies.autoloaded?(Module.new)
+      assert !ActiveSupport::Dependencies.autoloaded?(Module.new)
 
       nil_name = Module.new
       def nil_name.name() nil end
-      assert !Dependencies.autoloaded?(nil_name)
+      assert !ActiveSupport::Dependencies.autoloaded?(nil_name)
 
       Object.class_eval { remove_const :ModuleFolder }
     end
   end
 
   def test_qualified_name_for
-    assert_equal "A", Dependencies.qualified_name_for(Object, :A)
-    assert_equal "A", Dependencies.qualified_name_for(:Object, :A)
-    assert_equal "A", Dependencies.qualified_name_for("Object", :A)
-    assert_equal "A", Dependencies.qualified_name_for("::Object", :A)
-    assert_equal "A", Dependencies.qualified_name_for("::Kernel", :A)
+    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for(Object, :A)
+    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for(:Object, :A)
+    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for("Object", :A)
+    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for("::Object", :A)
+    assert_equal "A", ActiveSupport::Dependencies.qualified_name_for("::Kernel", :A)
 
-    assert_equal "Dependencies::A", Dependencies.qualified_name_for(:Dependencies, :A)
-    assert_equal "Dependencies::A", Dependencies.qualified_name_for(Dependencies, :A)
+    assert_equal "ActiveSupport::Dependencies::A", ActiveSupport::Dependencies.qualified_name_for(:'ActiveSupport::Dependencies', :A)
+    assert_equal "ActiveSupport::Dependencies::A", ActiveSupport::Dependencies.qualified_name_for(ActiveSupport::Dependencies, :A)
   end
 
   def test_file_search
     with_loading 'dependencies' do
-      root = Dependencies.load_paths.first
-      assert_equal nil, Dependencies.search_for_file('service_three')
-      assert_equal nil, Dependencies.search_for_file('service_three.rb')
-      assert_equal root + '/service_one.rb', Dependencies.search_for_file('service_one')
-      assert_equal root + '/service_one.rb', Dependencies.search_for_file('service_one.rb')
+      root = ActiveSupport::Dependencies.load_paths.first
+      assert_equal nil, ActiveSupport::Dependencies.search_for_file('service_three')
+      assert_equal nil, ActiveSupport::Dependencies.search_for_file('service_three.rb')
+      assert_equal root + '/service_one.rb', ActiveSupport::Dependencies.search_for_file('service_one')
+      assert_equal root + '/service_one.rb', ActiveSupport::Dependencies.search_for_file('service_one.rb')
     end
   end
 
   def test_file_search_uses_first_in_load_path
     with_loading 'dependencies', 'autoloading_fixtures' do
-      deps, autoload = Dependencies.load_paths
+      deps, autoload = ActiveSupport::Dependencies.load_paths
       assert_match %r/dependencies/, deps
       assert_match %r/autoloading_fixtures/, autoload
 
-      assert_equal deps + '/conflict.rb', Dependencies.search_for_file('conflict')
+      assert_equal deps + '/conflict.rb', ActiveSupport::Dependencies.search_for_file('conflict')
     end
     with_loading 'autoloading_fixtures', 'dependencies' do
-      autoload, deps = Dependencies.load_paths
+      autoload, deps = ActiveSupport::Dependencies.load_paths
       assert_match %r/dependencies/, deps
       assert_match %r/autoloading_fixtures/, autoload
 
-      assert_equal autoload + '/conflict.rb', Dependencies.search_for_file('conflict')
+      assert_equal autoload + '/conflict.rb', ActiveSupport::Dependencies.search_for_file('conflict')
     end
 
   end
@@ -383,7 +383,7 @@ class DependenciesTest < Test::Unit::TestCase
     with_loading 'autoloading_fixtures' do
       require_dependency '././counting_loader'
       assert_equal 1, $counting_loaded_times
-      assert_raises(ArgumentError) { Dependencies.load_missing_constant Object, :CountingLoader }
+      assert_raises(ArgumentError) { ActiveSupport::Dependencies.load_missing_constant Object, :CountingLoader }
       assert_equal 1, $counting_loaded_times
     end
   end
@@ -407,12 +407,12 @@ class DependenciesTest < Test::Unit::TestCase
 
   def test_removal_from_tree_should_be_detected
     with_loading 'dependencies' do
-      root = Dependencies.load_paths.first
+      root = ActiveSupport::Dependencies.load_paths.first
       c = ServiceOne
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
       assert ! defined?(ServiceOne)
       begin
-        Dependencies.load_missing_constant(c, :FakeMissing)
+        ActiveSupport::Dependencies.load_missing_constant(c, :FakeMissing)
         flunk "Expected exception"
       rescue ArgumentError => e
         assert_match %r{ServiceOne has been removed from the module tree}i, e.message
@@ -430,25 +430,25 @@ class DependenciesTest < Test::Unit::TestCase
 
   def test_load_once_paths_do_not_add_to_autoloaded_constants
     with_loading 'autoloading_fixtures' do
-      Dependencies.load_once_paths = Dependencies.load_paths.dup
+      ActiveSupport::Dependencies.load_once_paths = ActiveSupport::Dependencies.load_paths.dup
 
-      assert ! Dependencies.autoloaded?("ModuleFolder")
-      assert ! Dependencies.autoloaded?("ModuleFolder::NestedClass")
-      assert ! Dependencies.autoloaded?(ModuleFolder)
+      assert ! ActiveSupport::Dependencies.autoloaded?("ModuleFolder")
+      assert ! ActiveSupport::Dependencies.autoloaded?("ModuleFolder::NestedClass")
+      assert ! ActiveSupport::Dependencies.autoloaded?(ModuleFolder)
 
       1 if ModuleFolder::NestedClass # 1 if to avoid warning
-      assert ! Dependencies.autoloaded?(ModuleFolder::NestedClass)
+      assert ! ActiveSupport::Dependencies.autoloaded?(ModuleFolder::NestedClass)
     end
   ensure
     Object.class_eval { remove_const :ModuleFolder }
-    Dependencies.load_once_paths = []
+    ActiveSupport::Dependencies.load_once_paths = []
   end
 
   def test_application_should_special_case_application_controller
     with_loading 'autoloading_fixtures' do
       require_dependency 'application'
       assert_equal 10, ApplicationController
-      assert Dependencies.autoloaded?(:ApplicationController)
+      assert ActiveSupport::Dependencies.autoloaded?(:ApplicationController)
     end
   end
 
@@ -463,15 +463,15 @@ class DependenciesTest < Test::Unit::TestCase
   def test_preexisting_constants_are_not_marked_as_autoloaded
     with_loading 'autoloading_fixtures' do
       require_dependency 'e'
-      assert Dependencies.autoloaded?(:E)
-      Dependencies.clear
+      assert ActiveSupport::Dependencies.autoloaded?(:E)
+      ActiveSupport::Dependencies.clear
     end
 
     Object.const_set :E, Class.new
     with_loading 'autoloading_fixtures' do
       require_dependency 'e'
-      assert ! Dependencies.autoloaded?(:E), "E shouldn't be marked autoloaded!"
-      Dependencies.clear
+      assert ! ActiveSupport::Dependencies.autoloaded?(:E), "E shouldn't be marked autoloaded!"
+      ActiveSupport::Dependencies.clear
     end
 
   ensure
@@ -483,11 +483,11 @@ class DependenciesTest < Test::Unit::TestCase
       Object.const_set :M, Module.new
       M.unloadable
 
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
       assert ! defined?(M)
 
       Object.const_set :M, Module.new
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
       assert ! defined?(M), "Dependencies should unload unloadable constants each time"
     end
   end
@@ -508,24 +508,24 @@ class DependenciesTest < Test::Unit::TestCase
   end
 
   def test_new_contants_in_without_constants
-    assert_equal [], (Dependencies.new_constants_in(Object) { })
-    assert Dependencies.constant_watch_stack.empty?
+    assert_equal [], (ActiveSupport::Dependencies.new_constants_in(Object) { })
+    assert ActiveSupport::Dependencies.constant_watch_stack.empty?
   end
 
   def test_new_constants_in_with_a_single_constant
-    assert_equal ["Hello"], Dependencies.new_constants_in(Object) {
+    assert_equal ["Hello"], ActiveSupport::Dependencies.new_constants_in(Object) {
                               Object.const_set :Hello, 10
                             }.map(&:to_s)
-    assert Dependencies.constant_watch_stack.empty?
+    assert ActiveSupport::Dependencies.constant_watch_stack.empty?
   ensure
     Object.class_eval { remove_const :Hello }
   end
 
   def test_new_constants_in_with_nesting
-    outer = Dependencies.new_constants_in(Object) do
+    outer = ActiveSupport::Dependencies.new_constants_in(Object) do
       Object.const_set :OuterBefore, 10
 
-      assert_equal ["Inner"], Dependencies.new_constants_in(Object) {
+      assert_equal ["Inner"], ActiveSupport::Dependencies.new_constants_in(Object) {
                                 Object.const_set :Inner, 20
                               }.map(&:to_s)
 
@@ -533,7 +533,7 @@ class DependenciesTest < Test::Unit::TestCase
     end
 
     assert_equal ["OuterAfter", "OuterBefore"], outer.sort.map(&:to_s)
-    assert Dependencies.constant_watch_stack.empty?
+    assert ActiveSupport::Dependencies.constant_watch_stack.empty?
   ensure
     %w(OuterBefore Inner OuterAfter).each do |name|
       Object.class_eval { remove_const name if const_defined?(name) }
@@ -543,10 +543,10 @@ class DependenciesTest < Test::Unit::TestCase
   def test_new_constants_in_module
     Object.const_set :M, Module.new
 
-    outer = Dependencies.new_constants_in(M) do
+    outer = ActiveSupport::Dependencies.new_constants_in(M) do
       M.const_set :OuterBefore, 10
 
-      inner = Dependencies.new_constants_in(M) do
+      inner = ActiveSupport::Dependencies.new_constants_in(M) do
         M.const_set :Inner, 20
       end
       assert_equal ["M::Inner"], inner
@@ -554,17 +554,17 @@ class DependenciesTest < Test::Unit::TestCase
       M.const_set :OuterAfter, 30
     end
     assert_equal ["M::OuterAfter", "M::OuterBefore"], outer.sort
-    assert Dependencies.constant_watch_stack.empty?
+    assert ActiveSupport::Dependencies.constant_watch_stack.empty?
   ensure
     Object.class_eval { remove_const :M }
   end
 
   def test_new_constants_in_module_using_name
-    outer = Dependencies.new_constants_in(:M) do
+    outer = ActiveSupport::Dependencies.new_constants_in(:M) do
       Object.const_set :M, Module.new
       M.const_set :OuterBefore, 10
 
-      inner = Dependencies.new_constants_in(:M) do
+      inner = ActiveSupport::Dependencies.new_constants_in(:M) do
         M.const_set :Inner, 20
       end
       assert_equal ["M::Inner"], inner
@@ -572,13 +572,13 @@ class DependenciesTest < Test::Unit::TestCase
       M.const_set :OuterAfter, 30
     end
     assert_equal ["M::OuterAfter", "M::OuterBefore"], outer.sort
-    assert Dependencies.constant_watch_stack.empty?
+    assert ActiveSupport::Dependencies.constant_watch_stack.empty?
   ensure
     Object.class_eval { remove_const :M }
   end
 
   def test_new_constants_in_with_inherited_constants
-    m = Dependencies.new_constants_in(:Object) do
+    m = ActiveSupport::Dependencies.new_constants_in(:Object) do
       Object.class_eval { include ModuleWithConstant }
     end
     assert_equal [], m
@@ -586,7 +586,7 @@ class DependenciesTest < Test::Unit::TestCase
 
   def test_new_constants_in_with_illegal_module_name_raises_correct_error
     assert_raises(NameError) do
-      Dependencies.new_constants_in("Illegal-Name") {}
+      ActiveSupport::Dependencies.new_constants_in("Illegal-Name") {}
     end
   end
 
@@ -598,10 +598,10 @@ class DependenciesTest < Test::Unit::TestCase
       require_dependency 'multiple_constant_file'
       assert defined?(MultipleConstantFile)
       assert defined?(SiblingConstant)
-      assert Dependencies.autoloaded?(:MultipleConstantFile)
-      assert Dependencies.autoloaded?(:SiblingConstant)
+      assert ActiveSupport::Dependencies.autoloaded?(:MultipleConstantFile)
+      assert ActiveSupport::Dependencies.autoloaded?(:SiblingConstant)
 
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
 
       assert ! defined?(MultipleConstantFile)
       assert ! defined?(SiblingConstant)
@@ -617,10 +617,10 @@ class DependenciesTest < Test::Unit::TestCase
 
       assert defined?(MultipleConstantFile)
       assert defined?(SiblingConstant)
-      assert Dependencies.autoloaded?(:MultipleConstantFile)
-      assert Dependencies.autoloaded?(:SiblingConstant)
+      assert ActiveSupport::Dependencies.autoloaded?(:MultipleConstantFile)
+      assert ActiveSupport::Dependencies.autoloaded?(:SiblingConstant)
 
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
 
       assert ! defined?(MultipleConstantFile)
       assert ! defined?(SiblingConstant)
@@ -636,10 +636,10 @@ class DependenciesTest < Test::Unit::TestCase
 
       assert defined?(ClassFolder::NestedClass)
       assert defined?(ClassFolder::SiblingClass)
-      assert Dependencies.autoloaded?("ClassFolder::NestedClass")
-      assert Dependencies.autoloaded?("ClassFolder::SiblingClass")
+      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::NestedClass")
+      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::SiblingClass")
 
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
 
       assert ! defined?(ClassFolder::NestedClass)
       assert ! defined?(ClassFolder::SiblingClass)
@@ -655,10 +655,10 @@ class DependenciesTest < Test::Unit::TestCase
 
       assert defined?(ClassFolder::NestedClass)
       assert defined?(ClassFolder::SiblingClass)
-      assert Dependencies.autoloaded?("ClassFolder::NestedClass")
-      assert Dependencies.autoloaded?("ClassFolder::SiblingClass")
+      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::NestedClass")
+      assert ActiveSupport::Dependencies.autoloaded?("ClassFolder::SiblingClass")
 
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
 
       assert ! defined?(ClassFolder::NestedClass)
       assert ! defined?(ClassFolder::SiblingClass)
@@ -673,7 +673,7 @@ class DependenciesTest < Test::Unit::TestCase
         assert !defined?(::RaisesNoMethodError), "::RaisesNoMethodError is defined but it should have failed!"
       end
     end
-  
+
   ensure
     Object.class_eval { remove_const :RaisesNoMethodError if const_defined?(:RaisesNoMethodError) }
   end
@@ -686,7 +686,7 @@ class DependenciesTest < Test::Unit::TestCase
         assert !defined?(::RaisesNoMethodError), "::RaisesNoMethodError is defined but it should have failed!"
       end
     end
-  
+
   ensure
     Object.class_eval { remove_const :RaisesNoMethodError if const_defined?(:RaisesNoMethodError) }
   end
@@ -714,44 +714,44 @@ class DependenciesTest < Test::Unit::TestCase
   ensure
     Object.class_eval { remove_const :RaisesNoMethodError if const_defined?(:RaisesNoMethodError) }
   end
-  
+
   def test_remove_constant_handles_double_colon_at_start
     Object.const_set 'DeleteMe', Module.new
     DeleteMe.const_set 'OrMe', Module.new
-    Dependencies.remove_constant "::DeleteMe::OrMe"
+    ActiveSupport::Dependencies.remove_constant "::DeleteMe::OrMe"
     assert ! defined?(DeleteMe::OrMe)
     assert defined?(DeleteMe)
-    Dependencies.remove_constant "::DeleteMe"
+    ActiveSupport::Dependencies.remove_constant "::DeleteMe"
     assert ! defined?(DeleteMe)
   end
-  
+
   def test_load_once_constants_should_not_be_unloaded
     with_loading 'autoloading_fixtures' do
-      Dependencies.load_once_paths = Dependencies.load_paths
+      ActiveSupport::Dependencies.load_once_paths = ActiveSupport::Dependencies.load_paths
       ::A.to_s
       assert defined?(A)
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
       assert defined?(A)
     end
   ensure
-    Dependencies.load_once_paths = []
+    ActiveSupport::Dependencies.load_once_paths = []
     Object.class_eval { remove_const :A if const_defined?(:A) }
   end
-  
+
   def test_load_once_paths_should_behave_when_recursively_loading
     with_loading 'dependencies', 'autoloading_fixtures' do
-      Dependencies.load_once_paths = [Dependencies.load_paths.last]
+      ActiveSupport::Dependencies.load_once_paths = [ActiveSupport::Dependencies.load_paths.last]
       assert !defined?(CrossSiteDependency)
       assert_nothing_raised { CrossSiteDepender.nil? }
       assert defined?(CrossSiteDependency)
-      assert !Dependencies.autoloaded?(CrossSiteDependency),
+      assert !ActiveSupport::Dependencies.autoloaded?(CrossSiteDependency),
         "CrossSiteDependency shouldn't be marked as autoloaded!"
-      Dependencies.clear
+      ActiveSupport::Dependencies.clear
       assert defined?(CrossSiteDependency),
         "CrossSiteDependency shouldn't have been unloaded!"
     end
   ensure
-    Dependencies.load_once_paths = []
+    ActiveSupport::Dependencies.load_once_paths = []
   end
-  
+
 end
diff --git a/activesupport/test/deprecation_test.rb b/activesupport/test/deprecation_test.rb
index ebfa405..27e9573 100644
--- a/activesupport/test/deprecation_test.rb
+++ b/activesupport/test/deprecation_test.rb
@@ -24,6 +24,11 @@ class Deprecatee
   def d; end
   def e; end
   deprecate :a, :b, :c => :e, :d => "you now need to do something extra for this one"
+
+  module B
+    C = 1
+  end
+  A = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('Deprecatee::A', 'Deprecatee::B::C')
 end
 
 
@@ -83,6 +88,11 @@ class DeprecationTest < Test::Unit::TestCase
     assert_not_deprecated { assert_equal @dtc.request.inspect, @dtc.old_request.inspect }
   end
 
+  def test_deprecated_constant_proxy
+    assert_not_deprecated { Deprecatee::B::C }
+    assert_deprecated('Deprecatee::A') { assert_equal Deprecatee::B::C, Deprecatee::A }
+  end
+
   def test_assert_deprecation_without_match
     assert_deprecated do
       @dtc.partially
diff --git a/activesupport/test/inflector_test.rb b/activesupport/test/inflector_test.rb
index 26af245..e8f82a4 100644
--- a/activesupport/test/inflector_test.rb
+++ b/activesupport/test/inflector_test.rb
@@ -12,188 +12,188 @@ class InflectorTest < Test::Unit::TestCase
   include InflectorTestCases
 
   def test_pluralize_plurals
-    assert_equal "plurals", Inflector.pluralize("plurals")
-    assert_equal "Plurals", Inflector.pluralize("Plurals")
+    assert_equal "plurals", ActiveSupport::Inflector.pluralize("plurals")
+    assert_equal "Plurals", ActiveSupport::Inflector.pluralize("Plurals")
   end
 
   def test_pluralize_empty_string
-    assert_equal "", Inflector.pluralize("")
+    assert_equal "", ActiveSupport::Inflector.pluralize("")
   end
 
   SingularToPlural.each do |singular, plural|
     define_method "test_pluralize_#{singular}" do
-      assert_equal(plural, Inflector.pluralize(singular))
-      assert_equal(plural.capitalize, Inflector.pluralize(singular.capitalize))
+      assert_equal(plural, ActiveSupport::Inflector.pluralize(singular))
+      assert_equal(plural.capitalize, ActiveSupport::Inflector.pluralize(singular.capitalize))
     end
   end
 
   SingularToPlural.each do |singular, plural|
     define_method "test_singularize_#{plural}" do
-      assert_equal(singular, Inflector.singularize(plural))
-      assert_equal(singular.capitalize, Inflector.singularize(plural.capitalize))
+      assert_equal(singular, ActiveSupport::Inflector.singularize(plural))
+      assert_equal(singular.capitalize, ActiveSupport::Inflector.singularize(plural.capitalize))
     end
   end
 
   MixtureToTitleCase.each do |before, titleized|
     define_method "test_titleize_#{before}" do
-      assert_equal(titleized, Inflector.titleize(before))
+      assert_equal(titleized, ActiveSupport::Inflector.titleize(before))
     end
   end
 
   def test_camelize
     CamelToUnderscore.each do |camel, underscore|
-      assert_equal(camel, Inflector.camelize(underscore))
+      assert_equal(camel, ActiveSupport::Inflector.camelize(underscore))
     end
   end
 
   def test_underscore
     CamelToUnderscore.each do |camel, underscore|
-      assert_equal(underscore, Inflector.underscore(camel))
+      assert_equal(underscore, ActiveSupport::Inflector.underscore(camel))
     end
     CamelToUnderscoreWithoutReverse.each do |camel, underscore|
-      assert_equal(underscore, Inflector.underscore(camel))
+      assert_equal(underscore, ActiveSupport::Inflector.underscore(camel))
     end
   end
 
   def test_camelize_with_module
     CamelWithModuleToUnderscoreWithSlash.each do |camel, underscore|
-      assert_equal(camel, Inflector.camelize(underscore))
+      assert_equal(camel, ActiveSupport::Inflector.camelize(underscore))
     end
   end
 
   def test_underscore_with_slashes
     CamelWithModuleToUnderscoreWithSlash.each do |camel, underscore|
-      assert_equal(underscore, Inflector.underscore(camel))
+      assert_equal(underscore, ActiveSupport::Inflector.underscore(camel))
     end
   end
 
   def test_demodulize
-    assert_equal "Account", Inflector.demodulize("MyApplication::Billing::Account")
+    assert_equal "Account", ActiveSupport::Inflector.demodulize("MyApplication::Billing::Account")
   end
 
   def test_foreign_key
     ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|
-      assert_equal(foreign_key, Inflector.foreign_key(klass))
+      assert_equal(foreign_key, ActiveSupport::Inflector.foreign_key(klass))
     end
 
     ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|
-      assert_equal(foreign_key, Inflector.foreign_key(klass, false))
+      assert_equal(foreign_key, ActiveSupport::Inflector.foreign_key(klass, false))
     end
   end
 
   def test_tableize
     ClassNameToTableName.each do |class_name, table_name|
-      assert_equal(table_name, Inflector.tableize(class_name))
+      assert_equal(table_name, ActiveSupport::Inflector.tableize(class_name))
     end
   end
 
   def test_classify
     ClassNameToTableName.each do |class_name, table_name|
-      assert_equal(class_name, Inflector.classify(table_name))
-      assert_equal(class_name, Inflector.classify("table_prefix." + table_name))
+      assert_equal(class_name, ActiveSupport::Inflector.classify(table_name))
+      assert_equal(class_name, ActiveSupport::Inflector.classify("table_prefix." + table_name))
     end
   end
 
   def test_classify_with_symbol
     assert_nothing_raised do
-      assert_equal 'FooBar', Inflector.classify(:foo_bars)
+      assert_equal 'FooBar', ActiveSupport::Inflector.classify(:foo_bars)
     end
   end
 
   def test_classify_with_leading_schema_name
-    assert_equal 'FooBar', Inflector.classify('schema.foo_bar')
+    assert_equal 'FooBar', ActiveSupport::Inflector.classify('schema.foo_bar')
   end
 
   def test_humanize
     UnderscoreToHuman.each do |underscore, human|
-      assert_equal(human, Inflector.humanize(underscore))
+      assert_equal(human, ActiveSupport::Inflector.humanize(underscore))
     end
   end
 
   def test_constantize
-    assert_nothing_raised { assert_equal Ace::Base::Case, Inflector.constantize("Ace::Base::Case") }
-    assert_nothing_raised { assert_equal Ace::Base::Case, Inflector.constantize("::Ace::Base::Case") }
-    assert_nothing_raised { assert_equal InflectorTest, Inflector.constantize("InflectorTest") }
-    assert_nothing_raised { assert_equal InflectorTest, Inflector.constantize("::InflectorTest") }
-    assert_raises(NameError) { Inflector.constantize("UnknownClass") }
-    assert_raises(NameError) { Inflector.constantize("An invalid string") }
-    assert_raises(NameError) { Inflector.constantize("InvalidClass\n") }
+    assert_nothing_raised { assert_equal Ace::Base::Case, ActiveSupport::Inflector.constantize("Ace::Base::Case") }
+    assert_nothing_raised { assert_equal Ace::Base::Case, ActiveSupport::Inflector.constantize("::Ace::Base::Case") }
+    assert_nothing_raised { assert_equal InflectorTest, ActiveSupport::Inflector.constantize("InflectorTest") }
+    assert_nothing_raised { assert_equal InflectorTest, ActiveSupport::Inflector.constantize("::InflectorTest") }
+    assert_raises(NameError) { ActiveSupport::Inflector.constantize("UnknownClass") }
+    assert_raises(NameError) { ActiveSupport::Inflector.constantize("An invalid string") }
+    assert_raises(NameError) { ActiveSupport::Inflector.constantize("InvalidClass\n") }
   end
 
   def test_constantize_does_lexical_lookup
-    assert_raises(NameError) { Inflector.constantize("Ace::Base::InflectorTest") }
+    assert_raises(NameError) { ActiveSupport::Inflector.constantize("Ace::Base::InflectorTest") }
   end
 
   def test_ordinal
     OrdinalNumbers.each do |number, ordinalized|
-      assert_equal(ordinalized, Inflector.ordinalize(number))
+      assert_equal(ordinalized, ActiveSupport::Inflector.ordinalize(number))
     end
   end
 
   def test_dasherize
     UnderscoresToDashes.each do |underscored, dasherized|
-      assert_equal(dasherized, Inflector.dasherize(underscored))
+      assert_equal(dasherized, ActiveSupport::Inflector.dasherize(underscored))
     end
   end
 
   def test_underscore_as_reverse_of_dasherize
     UnderscoresToDashes.each do |underscored, dasherized|
-      assert_equal(underscored, Inflector.underscore(Inflector.dasherize(underscored)))
+      assert_equal(underscored, ActiveSupport::Inflector.underscore(ActiveSupport::Inflector.dasherize(underscored)))
     end
   end
 
   def test_underscore_to_lower_camel
     UnderscoreToLowerCamel.each do |underscored, lower_camel|
-      assert_equal(lower_camel, Inflector.camelize(underscored, false))
+      assert_equal(lower_camel, ActiveSupport::Inflector.camelize(underscored, false))
     end
   end
   
   %w{plurals singulars uncountables}.each do |inflection_type|
     class_eval "
       def test_clear_#{inflection_type}
-        cached_values = Inflector.inflections.#{inflection_type}
-        Inflector.inflections.clear :#{inflection_type}
-        assert Inflector.inflections.#{inflection_type}.empty?, \"#{inflection_type} inflections should be empty after clear :#{inflection_type}\"
-        Inflector.inflections.instance_variable_set :@#{inflection_type}, cached_values
+        cached_values = ActiveSupport::Inflector.inflections.#{inflection_type}
+        ActiveSupport::Inflector.inflections.clear :#{inflection_type}
+        assert ActiveSupport::Inflector.inflections.#{inflection_type}.empty?, \"#{inflection_type} inflections should be empty after clear :#{inflection_type}\"
+        ActiveSupport::Inflector.inflections.instance_variable_set :@#{inflection_type}, cached_values
       end
     "
   end
   
   def test_clear_all
-    cached_values = Inflector.inflections.plurals, Inflector.inflections.singulars, Inflector.inflections.uncountables
-    Inflector.inflections.clear :all
-    assert Inflector.inflections.plurals.empty?
-    assert Inflector.inflections.singulars.empty?
-    assert Inflector.inflections.uncountables.empty?
-    Inflector.inflections.instance_variable_set :@plurals, cached_values[0]
-    Inflector.inflections.instance_variable_set :@singulars, cached_values[1]
-    Inflector.inflections.instance_variable_set :@uncountables, cached_values[2]
+    cached_values = ActiveSupport::Inflector.inflections.plurals, ActiveSupport::Inflector.inflections.singulars, ActiveSupport::Inflector.inflections.uncountables
+    ActiveSupport::Inflector.inflections.clear :all
+    assert ActiveSupport::Inflector.inflections.plurals.empty?
+    assert ActiveSupport::Inflector.inflections.singulars.empty?
+    assert ActiveSupport::Inflector.inflections.uncountables.empty?
+    ActiveSupport::Inflector.inflections.instance_variable_set :@plurals, cached_values[0]
+    ActiveSupport::Inflector.inflections.instance_variable_set :@singulars, cached_values[1]
+    ActiveSupport::Inflector.inflections.instance_variable_set :@uncountables, cached_values[2]
   end
   
   def test_clear_with_default
-    cached_values = Inflector.inflections.plurals, Inflector.inflections.singulars, Inflector.inflections.uncountables
-    Inflector.inflections.clear
-    assert Inflector.inflections.plurals.empty?
-    assert Inflector.inflections.singulars.empty?
-    assert Inflector.inflections.uncountables.empty?
-    Inflector.inflections.instance_variable_set :@plurals, cached_values[0]
-    Inflector.inflections.instance_variable_set :@singulars, cached_values[1]
-    Inflector.inflections.instance_variable_set :@uncountables, cached_values[2]
+    cached_values = ActiveSupport::Inflector.inflections.plurals, ActiveSupport::Inflector.inflections.singulars, ActiveSupport::Inflector.inflections.uncountables
+    ActiveSupport::Inflector.inflections.clear
+    assert ActiveSupport::Inflector.inflections.plurals.empty?
+    assert ActiveSupport::Inflector.inflections.singulars.empty?
+    assert ActiveSupport::Inflector.inflections.uncountables.empty?
+    ActiveSupport::Inflector.inflections.instance_variable_set :@plurals, cached_values[0]
+    ActiveSupport::Inflector.inflections.instance_variable_set :@singulars, cached_values[1]
+    ActiveSupport::Inflector.inflections.instance_variable_set :@uncountables, cached_values[2]
   end
 
   Irregularities.each do |irregularity|
     singular, plural = *irregularity
-    Inflector.inflections do |inflect|
+    ActiveSupport::Inflector.inflections do |inflect|
       define_method("test_irregularity_between_#{singular}_and_#{plural}") do
         inflect.irregular(singular, plural)
-        assert_equal singular, Inflector.singularize(plural)
-        assert_equal plural, Inflector.pluralize(singular)
+        assert_equal singular, ActiveSupport::Inflector.singularize(plural)
+        assert_equal plural, ActiveSupport::Inflector.pluralize(singular)
       end
     end
   end
 
   [ :all, [] ].each do |scope|
-    Inflector.inflections do |inflect|
+    ActiveSupport::Inflector.inflections do |inflect|
       define_method("test_clear_inflections_with_#{scope.kind_of?(Array) ? "no_arguments" : scope}") do
         # save all the inflections
         singulars, plurals, uncountables = inflect.singulars, inflect.plurals, inflect.uncountables
@@ -218,7 +218,7 @@ class InflectorTest < Test::Unit::TestCase
   end
 
   { :singulars => :singular, :plurals => :plural, :uncountables => :uncountable }.each do |scope, method|
-    Inflector.inflections do |inflect|
+    ActiveSupport::Inflector.inflections do |inflect|
       define_method("test_clear_inflections_with_#{scope}") do
         # save the inflections
         values = inflect.send(scope)
diff --git a/activesupport/test/ordered_options_test.rb b/activesupport/test/ordered_options_test.rb
index fb7a58d..e48425c 100644
--- a/activesupport/test/ordered_options_test.rb
+++ b/activesupport/test/ordered_options_test.rb
@@ -2,7 +2,7 @@ require 'abstract_unit'
 
 class OrderedOptionsTest < Test::Unit::TestCase
   def test_usage
-    a = OrderedOptions.new
+    a = ActiveSupport::OrderedOptions.new
 
     assert_nil a[:not_set]
 
@@ -20,7 +20,7 @@ class OrderedOptionsTest < Test::Unit::TestCase
   end
 
   def test_looping
-    a = OrderedOptions.new
+    a = ActiveSupport::OrderedOptions.new
 
     a[:allow_concurreny] = true
     a["else_where"] = 56
@@ -34,7 +34,7 @@ class OrderedOptionsTest < Test::Unit::TestCase
   end
 
   def test_method_access
-    a = OrderedOptions.new
+    a = ActiveSupport::OrderedOptions.new
 
     assert_nil a.not_set
 
diff --git a/activesupport/test/time_zone_test.rb b/activesupport/test/time_zone_test.rb
index 3757ddc..9a565f8 100644
--- a/activesupport/test/time_zone_test.rb
+++ b/activesupport/test/time_zone_test.rb
@@ -1,7 +1,8 @@
 require 'abstract_unit'
 
 class TimeZoneTest < Test::Unit::TestCase
-    
+  TimeZone = ActiveSupport::TimeZone
+
   def test_utc_to_local
     silence_warnings do # silence warnings raised by tzinfo gem
       zone = TimeZone['Eastern Time (US & Canada)']
@@ -17,14 +18,14 @@ class TimeZoneTest < Test::Unit::TestCase
       assert_equal Time.utc(2000, 7, 1, 4), zone.local_to_utc(Time.utc(2000, 7)) # dst offset -0400
     end
   end
-  
+
   def test_period_for_local
     silence_warnings do # silence warnings raised by tzinfo gem
       zone = TimeZone['Eastern Time (US & Canada)']
       assert_instance_of TZInfo::TimezonePeriod, zone.period_for_local(Time.utc(2000))
     end
   end
-  
+
   TimeZone::MAPPING.keys.each do |name|
     define_method("test_map_#{name.downcase.gsub(/[^a-z]/, '_')}_to_tzinfo") do
       silence_warnings do # silence warnings raised by tzinfo gem
@@ -69,7 +70,7 @@ class TimeZoneTest < Test::Unit::TestCase
         assert_equal zone, zone.now.time_zone
       end
     end
-    
+
     def test_now_enforces_spring_dst_rules
       with_env_tz 'US/Eastern' do
         Time.stubs(:now).returns(Time.local(2006,4,2,2)) # 2AM springs forward to 3AM
@@ -78,7 +79,7 @@ class TimeZoneTest < Test::Unit::TestCase
         assert_equal true, zone.now.dst?
       end
     end
-    
+
     def test_now_enforces_fall_dst_rules
       with_env_tz 'US/Eastern' do
         Time.stubs(:now).returns(Time.at(1162098000)) # equivalent to 1AM DST
@@ -87,7 +88,7 @@ class TimeZoneTest < Test::Unit::TestCase
         assert_equal true, zone.now.dst?
       end
     end
-  
+
     def test_today
       Time.stubs(:now).returns(Time.utc(2000, 1, 1, 4, 59, 59)) # 1 sec before midnight Jan 1 EST
       assert_equal Date.new(1999, 12, 31), TimeZone['Eastern Time (US & Canada)'].today
@@ -99,7 +100,7 @@ class TimeZoneTest < Test::Unit::TestCase
       assert_equal Date.new(2000, 1, 2), TimeZone['Eastern Time (US & Canada)'].today
     end
   end
-  
+
   def test_local
     silence_warnings do # silence warnings raised by tzinfo gem
       time = TimeZone["Hawaii"].local(2007, 2, 5, 15, 30, 45)
@@ -142,7 +143,7 @@ class TimeZoneTest < Test::Unit::TestCase
     twz = zone.local(2006,10,29,1)
     assert_equal Time.utc(2006,10,29,1), twz.time
     assert_equal Time.utc(2006,10,29,5), twz.utc
-    assert_equal true, twz.dst? 
+    assert_equal true, twz.dst?
     assert_equal 'EDT', twz.zone
   end
 
@@ -189,7 +190,7 @@ class TimeZoneTest < Test::Unit::TestCase
       assert_equal zone, twz.time_zone
     end
   end
-  
+
   def test_parse_far_future_date_with_time_zone_offset_in_string
     silence_warnings do # silence warnings raised by tzinfo gem
       zone = TimeZone['Eastern Time (US & Canada)']
@@ -198,7 +199,7 @@ class TimeZoneTest < Test::Unit::TestCase
       assert_equal zone, twz.time_zone
     end
   end
-  
+
   def test_parse_returns_nil_when_string_without_date_information_is_passed_in
     silence_warnings do # silence warnings raised by tzinfo gem
       zone = TimeZone['Eastern Time (US & Canada)']
@@ -215,7 +216,7 @@ class TimeZoneTest < Test::Unit::TestCase
       assert_equal Time.utc(1999,12,31,19), twz.time
     end
   end
-  
+
   def test_utc_offset_lazy_loaded_from_tzinfo_when_not_passed_in_to_initialize
     silence_warnings do # silence warnings raised by tzinfo gem
       tzinfo = TZInfo::Timezone.get('America/New_York')
@@ -224,25 +225,25 @@ class TimeZoneTest < Test::Unit::TestCase
       assert_equal(-18_000, zone.utc_offset)
     end
   end
-  
+
   def test_formatted_offset_positive
     zone = TimeZone['Moscow']
     assert_equal "+03:00", zone.formatted_offset
     assert_equal "+0300", zone.formatted_offset(false)
   end
-  
+
   def test_formatted_offset_negative
     zone = TimeZone['Eastern Time (US & Canada)']
     assert_equal "-05:00", zone.formatted_offset
     assert_equal "-0500", zone.formatted_offset(false)
   end
-  
+
   def test_formatted_offset_zero
     zone = TimeZone['London']
     assert_equal "+00:00", zone.formatted_offset
     assert_equal "UTC", zone.formatted_offset(true, 'UTC')
   end
-  
+
   def test_zone_compare
     zone1 = TimeZone['Central Time (US & Canada)'] # offset -0600
     zone2 = TimeZone['Eastern Time (US & Canada)'] # offset -0500
@@ -250,39 +251,39 @@ class TimeZoneTest < Test::Unit::TestCase
     assert zone2 > zone1
     assert zone1 == zone1
   end
-  
+
   def test_to_s
     assert_equal "(UTC+03:00) Moscow", TimeZone['Moscow'].to_s
   end
-  
+
   def test_all_sorted
     all = TimeZone.all
     1.upto( all.length-1 ) do |i|
       assert all[i-1] < all[i]
     end
   end
-  
+
   def test_index
     assert_nil TimeZone["bogus"]
     assert_instance_of TimeZone, TimeZone["Central Time (US & Canada)"]
     assert_instance_of TimeZone, TimeZone[8]
     assert_raises(ArgumentError) { TimeZone[false] }
   end
-  
+
   def test_new
     assert_equal TimeZone["Central Time (US & Canada)"], TimeZone.new("Central Time (US & Canada)")
   end
-  
+
   def test_us_zones
     assert TimeZone.us_zones.include?(TimeZone["Hawaii"])
     assert !TimeZone.us_zones.include?(TimeZone["Kuala Lumpur"])
-  end 
-  
+  end
+
   protected
     def with_env_tz(new_tz = 'US/Eastern')
       old_tz, ENV['TZ'] = ENV['TZ'], new_tz
       yield
     ensure
       old_tz ? ENV['TZ'] = old_tz : ENV.delete('TZ')
-    end  
+    end
 end
-- 
1.5.5.1

