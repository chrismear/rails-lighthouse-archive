<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer" nil="true"></assigned-user-id>
  <attachments-count type="integer">2</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2008-10-27T13:31:15+00:00</created-at>
  <creator-id type="integer">35668</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer">9903</milestone-id>
  <number type="integer">1279</number>
  <permalink>210-associations-cause-memory-leak</permalink>
  <priority type="integer">684</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>invalid</state>
  <tag>2.1 activerecord has_and_belongs_to_many leak memory</tag>
  <title>2.1.0 associations cause memory leak?</title>
  <updated-at type="datetime">2008-12-12T20:45:38+00:00</updated-at>
  <user-id type="integer">35668</user-id>
  <version type="integer">4</version>
  <user-name>onur g&#252;ng&#246;r</user-name>
  <creator-name>onur g&#252;ng&#246;r</creator-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/1279</url>
  <milestone-title>2.x</milestone-title>
  <priority-name nil="true"></priority-name>
  <original-body>Hi,

This is my first bug report so I could be missing something, so please forgive me.

I experience a memory leak when I run the following Rake task. It continues to run for a long time and consumes the memory very fast and as a result slows down.

I suspect that the sentences association (has_and_belongs_to_many) in word.rb is responsible because when I replace sentences_count = word.sentences.size with sentences_count = 0 memory leak is gone.

I found out _why's advice and think this maybe related with it, http://whytheluckystiff.net/articles/theFullyUpturnedBin.html

Additionally, I used the following simple memory profiler http://scottstuff.net/blog/articles/2006/08/17/memory-leak-profiling-with-rails

I will attach the output of this profiler for the two different configurations, one with associations and the other with no associations.


@@@ ruby
desc 'how many times a token set is used.'
task :count_each_word_occurence_roughly =&gt; :environment do

  word_count = 0

  words = Word.find(:all, :order =&gt; &quot;id&quot;)
  words.each do |word|
    parse_tree = word.parse_tree

    parse_tree.root_node.each do |node|
      if node.children.length &gt; 1
        tokens = []
        node.children.each do |child|
          token = Token.find_or_create_by_text(child.name)
          tokens &lt;&lt; token.id
        end
        tokens.sort!
        token_ids = tokens.join(&quot;-&quot;)
        token_set = TokenSet.find_or_initialize_by_token_ids(token_ids)

        sentences_count = word.sentences.size
        if token_set.roughtotal
          token_set.roughtotal += sentences_count
        else
          token_set.roughtotal = sentences_count
        end

        token_set.save
      end
    end

    word_count += 1
    if word_count % 10000 == 0
      print &quot;processed &quot; + word_count.to_s + &quot; words\n&quot;
      GC.start
    end
    # break unless word_count &lt; 2000
  end
end
@@@

@@@ ruby
class Word &lt; ActiveRecord::Base
  
  #  has_many :word_parses
  #  has_many :parses, :through =&gt; :word_parses
  has_and_belongs_to_many :parses, :join_table =&gt; &quot;word_parses&quot;
  
  has_and_belongs_to_many :features, :join_table =&gt; &quot;words_features&quot;, :uniq =&gt; true
  
  has_and_belongs_to_many :sentences, :join_table =&gt; &quot;words_sentences&quot;, :uniq =&gt; true
  
  has_many :spellings

  ...

@@@

@@@ ruby
class Sentence &lt; ActiveRecord::Base

  has_and_belongs_to_many :words, :join_table =&gt; &quot;words_sentences&quot;, :uniq =&gt; true
end
@@@

schema.rb
@@@ ruby
ActiveRecord::Schema.define(:version =&gt; 5) do

  create_table &quot;features&quot;, :force =&gt; true do |t|
    t.text &quot;description&quot;
  end

  create_table &quot;parses&quot;, :force =&gt; true do |t|
    t.text &quot;parse_text&quot;, :null =&gt; false
  end

  add_index &quot;parses&quot;, [&quot;parse_text&quot;], :name =&gt; &quot;parse_text&quot;

  create_table &quot;sentences&quot;, :force =&gt; true do |t|
    t.text &quot;spelling_sequence&quot;,      :null =&gt; false
    t.text &quot;correct_parse_sequence&quot;, :null =&gt; false
  end

  create_table &quot;spellings&quot;, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;, :null =&gt; false
    t.text    &quot;text&quot;,    :null =&gt; false
  end

  add_index &quot;spellings&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;spellings&quot;, [&quot;text&quot;], :name =&gt; &quot;text&quot;

  create_table &quot;token_sets&quot;, :force =&gt; true do |t|
    t.integer  &quot;count&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
    t.text     &quot;token_ids&quot;
  end

  add_index &quot;token_sets&quot;, [&quot;token_ids&quot;], :name =&gt; &quot;token_ids&quot;

  create_table &quot;tokens&quot;, :force =&gt; true do |t|
    t.text     &quot;text&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
  end

  add_index &quot;tokens&quot;, [&quot;text&quot;], :name =&gt; &quot;text&quot;

  create_table &quot;word_parses&quot;, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,  :null =&gt; false
    t.integer &quot;parse_id&quot;, :null =&gt; false
  end

  add_index &quot;word_parses&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;word_parses&quot;, [&quot;parse_id&quot;], :name =&gt; &quot;parse_id&quot;

  create_table &quot;words&quot;, :force =&gt; true do |t|
    t.string &quot;name&quot;, :limit =&gt; 100, :null =&gt; false
  end

  add_index &quot;words&quot;, [&quot;name&quot;], :name =&gt; &quot;name&quot;

  create_table &quot;words_features&quot;, :id =&gt; false, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,    :null =&gt; false
    t.integer &quot;feature_id&quot;, :null =&gt; false
  end

  add_index &quot;words_features&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;words_features&quot;, [&quot;feature_id&quot;], :name =&gt; &quot;feature_id&quot;

  create_table &quot;words_sentences&quot;, :id =&gt; false, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,     :null =&gt; false
    t.integer &quot;sentence_id&quot;, :null =&gt; false
  end

  add_index &quot;words_sentences&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;words_sentences&quot;, [&quot;sentence_id&quot;], :name =&gt; &quot;sentence_id&quot;

end
@@@</original-body>
  <latest-body>Hi,

This is my first bug report so I could be missing something, so please forgive me.

I experience a memory leak when I run the following Rake task. It continues to run for a long time and consumes the memory very fast and as a result slows down.

I suspect that the sentences association (has_and_belongs_to_many) in word.rb is responsible because when I replace sentences_count = word.sentences.size with sentences_count = 0 memory leak is gone.

I found out _why's advice and think this maybe related with it, http://whytheluckystiff.net/articles/theFullyUpturnedBin.html

Additionally, I used the following simple memory profiler http://scottstuff.net/blog/articles/2006/08/17/memory-leak-profiling-with-rails

I will attach the output of this profiler for the two different configurations, one with associations and the other with no associations.


@@@ ruby
desc 'how many times a token set is used.'
task :count_each_word_occurence_roughly =&gt; :environment do

  word_count = 0

  words = Word.find(:all, :order =&gt; &quot;id&quot;)
  words.each do |word|
    parse_tree = word.parse_tree

    parse_tree.root_node.each do |node|
      if node.children.length &gt; 1
        tokens = []
        node.children.each do |child|
          token = Token.find_or_create_by_text(child.name)
          tokens &lt;&lt; token.id
        end
        tokens.sort!
        token_ids = tokens.join(&quot;-&quot;)
        token_set = TokenSet.find_or_initialize_by_token_ids(token_ids)

        sentences_count = word.sentences.size
        if token_set.roughtotal
          token_set.roughtotal += sentences_count
        else
          token_set.roughtotal = sentences_count
        end

        token_set.save
      end
    end

    word_count += 1
    if word_count % 10000 == 0
      print &quot;processed &quot; + word_count.to_s + &quot; words\n&quot;
      GC.start
    end
    # break unless word_count &lt; 2000
  end
end
@@@

@@@ ruby
class Word &lt; ActiveRecord::Base
  
  #  has_many :word_parses
  #  has_many :parses, :through =&gt; :word_parses
  has_and_belongs_to_many :parses, :join_table =&gt; &quot;word_parses&quot;
  
  has_and_belongs_to_many :features, :join_table =&gt; &quot;words_features&quot;, :uniq =&gt; true
  
  has_and_belongs_to_many :sentences, :join_table =&gt; &quot;words_sentences&quot;, :uniq =&gt; true
  
  has_many :spellings

  ...

@@@

@@@ ruby
class Sentence &lt; ActiveRecord::Base

  has_and_belongs_to_many :words, :join_table =&gt; &quot;words_sentences&quot;, :uniq =&gt; true
end
@@@

schema.rb
@@@ ruby
ActiveRecord::Schema.define(:version =&gt; 5) do

  create_table &quot;features&quot;, :force =&gt; true do |t|
    t.text &quot;description&quot;
  end

  create_table &quot;parses&quot;, :force =&gt; true do |t|
    t.text &quot;parse_text&quot;, :null =&gt; false
  end

  add_index &quot;parses&quot;, [&quot;parse_text&quot;], :name =&gt; &quot;parse_text&quot;

  create_table &quot;sentences&quot;, :force =&gt; true do |t|
    t.text &quot;spelling_sequence&quot;,      :null =&gt; false
    t.text &quot;correct_parse_sequence&quot;, :null =&gt; false
  end

  create_table &quot;spellings&quot;, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;, :null =&gt; false
    t.text    &quot;text&quot;,    :null =&gt; false
  end

  add_index &quot;spellings&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;spellings&quot;, [&quot;text&quot;], :name =&gt; &quot;text&quot;

  create_table &quot;token_sets&quot;, :force =&gt; true do |t|
    t.integer  &quot;count&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
    t.text     &quot;token_ids&quot;
  end

  add_index &quot;token_sets&quot;, [&quot;token_ids&quot;], :name =&gt; &quot;token_ids&quot;

  create_table &quot;tokens&quot;, :force =&gt; true do |t|
    t.text     &quot;text&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
  end

  add_index &quot;tokens&quot;, [&quot;text&quot;], :name =&gt; &quot;text&quot;

  create_table &quot;word_parses&quot;, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,  :null =&gt; false
    t.integer &quot;parse_id&quot;, :null =&gt; false
  end

  add_index &quot;word_parses&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;word_parses&quot;, [&quot;parse_id&quot;], :name =&gt; &quot;parse_id&quot;

  create_table &quot;words&quot;, :force =&gt; true do |t|
    t.string &quot;name&quot;, :limit =&gt; 100, :null =&gt; false
  end

  add_index &quot;words&quot;, [&quot;name&quot;], :name =&gt; &quot;name&quot;

  create_table &quot;words_features&quot;, :id =&gt; false, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,    :null =&gt; false
    t.integer &quot;feature_id&quot;, :null =&gt; false
  end

  add_index &quot;words_features&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;words_features&quot;, [&quot;feature_id&quot;], :name =&gt; &quot;feature_id&quot;

  create_table &quot;words_sentences&quot;, :id =&gt; false, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,     :null =&gt; false
    t.integer &quot;sentence_id&quot;, :null =&gt; false
  end

  add_index &quot;words_sentences&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;words_sentences&quot;, [&quot;sentence_id&quot;], :name =&gt; &quot;sentence_id&quot;

end
@@@</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;This is my first bug report so I could be missing something, so
please forgive me.&lt;/p&gt;
&lt;p&gt;I experience a memory leak when I run the following Rake task.
It continues to run for a long time and consumes the memory very
fast and as a result slows down.&lt;/p&gt;
&lt;p&gt;I suspect that the sentences association
(has_and_belongs_to_many) in word.rb is responsible because when I
replace sentences_count = word.sentences.size with sentences_count
= 0 memory leak is gone.&lt;/p&gt;
&lt;p&gt;I found out _why's advice and think this maybe related with it,
&lt;a href=&quot;http://whytheluckystiff.net/articles/theFullyUpturnedBin.html&quot;&gt;http://whytheluckystiff.net/arti...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Additionally, I used the following simple memory profiler
&lt;a href=&quot;http://scottstuff.net/blog/articles/2006/08/17/memory-leak-profiling-with-rails&quot;&gt;
http://scottstuff.net/blog/artic...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I will attach the output of this profiler for the two different
configurations, one with associations and the other with no
associations.&lt;/p&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
desc 'how many times a token set is used.'
task :count_each_word_occurence_roughly =&amp;gt; :environment do

  word_count = 0

  words = Word.find(:all, :order =&amp;gt; &amp;quot;id&amp;quot;)
  words.each do |word|
    parse_tree = word.parse_tree

    parse_tree.root_node.each do |node|
      if node.children.length &amp;gt; 1
        tokens = []
        node.children.each do |child|
          token = Token.find_or_create_by_text(child.name)
          tokens &amp;lt;&amp;lt; token.id
        end
        tokens.sort!
        token_ids = tokens.join(&amp;quot;-&amp;quot;)
        token_set = TokenSet.find_or_initialize_by_token_ids(token_ids)

        sentences_count = word.sentences.size
        if token_set.roughtotal
          token_set.roughtotal += sentences_count
        else
          token_set.roughtotal = sentences_count
        end

        token_set.save
      end
    end

    word_count += 1
    if word_count % 10000 == 0
      print &amp;quot;processed &amp;quot; + word_count.to_s + &amp;quot; words\n&amp;quot;
      GC.start
    end
    # break unless word_count &amp;lt; 2000
  end
end
&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
class Word &amp;lt; ActiveRecord::Base

  #  has_many :word_parses
  #  has_many :parses, :through =&amp;gt; :word_parses
  has_and_belongs_to_many :parses, :join_table =&amp;gt; &amp;quot;word_parses&amp;quot;

  has_and_belongs_to_many :features, :join_table =&amp;gt; &amp;quot;words_features&amp;quot;, :uniq =&amp;gt; true

  has_and_belongs_to_many :sentences, :join_table =&amp;gt; &amp;quot;words_sentences&amp;quot;, :uniq =&amp;gt; true

  has_many :spellings

  ...

&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
class Sentence &amp;lt; ActiveRecord::Base

  has_and_belongs_to_many :words, :join_table =&amp;gt; &amp;quot;words_sentences&amp;quot;, :uniq =&amp;gt; true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;schema.rb&lt;/p&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
ActiveRecord::Schema.define(:version =&amp;gt; 5) do

  create_table &amp;quot;features&amp;quot;, :force =&amp;gt; true do |t|
    t.text &amp;quot;description&amp;quot;
  end

  create_table &amp;quot;parses&amp;quot;, :force =&amp;gt; true do |t|
    t.text &amp;quot;parse_text&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;parses&amp;quot;, [&amp;quot;parse_text&amp;quot;], :name =&amp;gt; &amp;quot;parse_text&amp;quot;

  create_table &amp;quot;sentences&amp;quot;, :force =&amp;gt; true do |t|
    t.text &amp;quot;spelling_sequence&amp;quot;,      :null =&amp;gt; false
    t.text &amp;quot;correct_parse_sequence&amp;quot;, :null =&amp;gt; false
  end

  create_table &amp;quot;spellings&amp;quot;, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;, :null =&amp;gt; false
    t.text    &amp;quot;text&amp;quot;,    :null =&amp;gt; false
  end

  add_index &amp;quot;spellings&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;spellings&amp;quot;, [&amp;quot;text&amp;quot;], :name =&amp;gt; &amp;quot;text&amp;quot;

  create_table &amp;quot;token_sets&amp;quot;, :force =&amp;gt; true do |t|
    t.integer  &amp;quot;count&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;
    t.datetime &amp;quot;updated_at&amp;quot;
    t.text     &amp;quot;token_ids&amp;quot;
  end

  add_index &amp;quot;token_sets&amp;quot;, [&amp;quot;token_ids&amp;quot;], :name =&amp;gt; &amp;quot;token_ids&amp;quot;

  create_table &amp;quot;tokens&amp;quot;, :force =&amp;gt; true do |t|
    t.text     &amp;quot;text&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;
    t.datetime &amp;quot;updated_at&amp;quot;
  end

  add_index &amp;quot;tokens&amp;quot;, [&amp;quot;text&amp;quot;], :name =&amp;gt; &amp;quot;text&amp;quot;

  create_table &amp;quot;word_parses&amp;quot;, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;,  :null =&amp;gt; false
    t.integer &amp;quot;parse_id&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;word_parses&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;word_parses&amp;quot;, [&amp;quot;parse_id&amp;quot;], :name =&amp;gt; &amp;quot;parse_id&amp;quot;

  create_table &amp;quot;words&amp;quot;, :force =&amp;gt; true do |t|
    t.string &amp;quot;name&amp;quot;, :limit =&amp;gt; 100, :null =&amp;gt; false
  end

  add_index &amp;quot;words&amp;quot;, [&amp;quot;name&amp;quot;], :name =&amp;gt; &amp;quot;name&amp;quot;

  create_table &amp;quot;words_features&amp;quot;, :id =&amp;gt; false, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;,    :null =&amp;gt; false
    t.integer &amp;quot;feature_id&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;words_features&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;words_features&amp;quot;, [&amp;quot;feature_id&amp;quot;], :name =&amp;gt; &amp;quot;feature_id&amp;quot;

  create_table &amp;quot;words_sentences&amp;quot;, :id =&amp;gt; false, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;,     :null =&amp;gt; false
    t.integer &amp;quot;sentence_id&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;words_sentences&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;words_sentences&amp;quot;, [&amp;quot;sentence_id&amp;quot;], :name =&amp;gt; &amp;quot;sentence_id&amp;quot;

end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Hi,

This is my first bug report so I could be missing something, so please forgive me.

I experience a memory leak when I run the following Rake task. It continues to run for a long time and consumes the memory very fast and as a result slows down.

I suspect that the sentences association (has_and_belongs_to_many) in word.rb is responsible because when I replace sentences_count = word.sentences.size with sentences_count = 0 memory leak is gone.

I found out _why's advice and think this maybe related with it, http://whytheluckystiff.net/articles/theFullyUpturnedBin.html

Additionally, I used the following simple memory profiler http://scottstuff.net/blog/articles/2006/08/17/memory-leak-profiling-with-rails

I will attach the output of this profiler for the two different configurations, one with associations and the other with no associations.


@@@ ruby
desc 'how many times a token set is used.'
task :count_each_word_occurence_roughly =&gt; :environment do

  word_count = 0

  words = Word.find(:all, :order =&gt; &quot;id&quot;)
  words.each do |word|
    parse_tree = word.parse_tree

    parse_tree.root_node.each do |node|
      if node.children.length &gt; 1
        tokens = []
        node.children.each do |child|
          token = Token.find_or_create_by_text(child.name)
          tokens &lt;&lt; token.id
        end
        tokens.sort!
        token_ids = tokens.join(&quot;-&quot;)
        token_set = TokenSet.find_or_initialize_by_token_ids(token_ids)

        sentences_count = word.sentences.size
        if token_set.roughtotal
          token_set.roughtotal += sentences_count
        else
          token_set.roughtotal = sentences_count
        end

        token_set.save
      end
    end

    word_count += 1
    if word_count % 10000 == 0
      print &quot;processed &quot; + word_count.to_s + &quot; words\n&quot;
      GC.start
    end
    # break unless word_count &lt; 2000
  end
end
@@@

@@@ ruby
class Word &lt; ActiveRecord::Base
  
  #  has_many :word_parses
  #  has_many :parses, :through =&gt; :word_parses
  has_and_belongs_to_many :parses, :join_table =&gt; &quot;word_parses&quot;
  
  has_and_belongs_to_many :features, :join_table =&gt; &quot;words_features&quot;, :uniq =&gt; true
  
  has_and_belongs_to_many :sentences, :join_table =&gt; &quot;words_sentences&quot;, :uniq =&gt; true
  
  has_many :spellings

  ...

@@@

@@@ ruby
class Sentence &lt; ActiveRecord::Base

  has_and_belongs_to_many :words, :join_table =&gt; &quot;words_sentences&quot;, :uniq =&gt; true
end
@@@

schema.rb
@@@ ruby
ActiveRecord::Schema.define(:version =&gt; 5) do

  create_table &quot;features&quot;, :force =&gt; true do |t|
    t.text &quot;description&quot;
  end

  create_table &quot;parses&quot;, :force =&gt; true do |t|
    t.text &quot;parse_text&quot;, :null =&gt; false
  end

  add_index &quot;parses&quot;, [&quot;parse_text&quot;], :name =&gt; &quot;parse_text&quot;

  create_table &quot;sentences&quot;, :force =&gt; true do |t|
    t.text &quot;spelling_sequence&quot;,      :null =&gt; false
    t.text &quot;correct_parse_sequence&quot;, :null =&gt; false
  end

  create_table &quot;spellings&quot;, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;, :null =&gt; false
    t.text    &quot;text&quot;,    :null =&gt; false
  end

  add_index &quot;spellings&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;spellings&quot;, [&quot;text&quot;], :name =&gt; &quot;text&quot;

  create_table &quot;token_sets&quot;, :force =&gt; true do |t|
    t.integer  &quot;count&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
    t.text     &quot;token_ids&quot;
  end

  add_index &quot;token_sets&quot;, [&quot;token_ids&quot;], :name =&gt; &quot;token_ids&quot;

  create_table &quot;tokens&quot;, :force =&gt; true do |t|
    t.text     &quot;text&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
  end

  add_index &quot;tokens&quot;, [&quot;text&quot;], :name =&gt; &quot;text&quot;

  create_table &quot;word_parses&quot;, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,  :null =&gt; false
    t.integer &quot;parse_id&quot;, :null =&gt; false
  end

  add_index &quot;word_parses&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;word_parses&quot;, [&quot;parse_id&quot;], :name =&gt; &quot;parse_id&quot;

  create_table &quot;words&quot;, :force =&gt; true do |t|
    t.string &quot;name&quot;, :limit =&gt; 100, :null =&gt; false
  end

  add_index &quot;words&quot;, [&quot;name&quot;], :name =&gt; &quot;name&quot;

  create_table &quot;words_features&quot;, :id =&gt; false, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,    :null =&gt; false
    t.integer &quot;feature_id&quot;, :null =&gt; false
  end

  add_index &quot;words_features&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;words_features&quot;, [&quot;feature_id&quot;], :name =&gt; &quot;feature_id&quot;

  create_table &quot;words_sentences&quot;, :id =&gt; false, :force =&gt; true do |t|
    t.integer &quot;word_id&quot;,     :null =&gt; false
    t.integer &quot;sentence_id&quot;, :null =&gt; false
  end

  add_index &quot;words_sentences&quot;, [&quot;word_id&quot;], :name =&gt; &quot;word_id&quot;
  add_index &quot;words_sentences&quot;, [&quot;sentence_id&quot;], :name =&gt; &quot;sentence_id&quot;

end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;This is my first bug report so I could be missing something, so
please forgive me.&lt;/p&gt;
&lt;p&gt;I experience a memory leak when I run the following Rake task.
It continues to run for a long time and consumes the memory very
fast and as a result slows down.&lt;/p&gt;
&lt;p&gt;I suspect that the sentences association
(has_and_belongs_to_many) in word.rb is responsible because when I
replace sentences_count = word.sentences.size with sentences_count
= 0 memory leak is gone.&lt;/p&gt;
&lt;p&gt;I found out _why's advice and think this maybe related with it,
&lt;a href=&quot;http://whytheluckystiff.net/articles/theFullyUpturnedBin.html&quot;&gt;http://whytheluckystiff.net/arti...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Additionally, I used the following simple memory profiler
&lt;a href=&quot;http://scottstuff.net/blog/articles/2006/08/17/memory-leak-profiling-with-rails&quot;&gt;
http://scottstuff.net/blog/artic...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I will attach the output of this profiler for the two different
configurations, one with associations and the other with no
associations.&lt;/p&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
desc 'how many times a token set is used.'
task :count_each_word_occurence_roughly =&amp;gt; :environment do

  word_count = 0

  words = Word.find(:all, :order =&amp;gt; &amp;quot;id&amp;quot;)
  words.each do |word|
    parse_tree = word.parse_tree

    parse_tree.root_node.each do |node|
      if node.children.length &amp;gt; 1
        tokens = []
        node.children.each do |child|
          token = Token.find_or_create_by_text(child.name)
          tokens &amp;lt;&amp;lt; token.id
        end
        tokens.sort!
        token_ids = tokens.join(&amp;quot;-&amp;quot;)
        token_set = TokenSet.find_or_initialize_by_token_ids(token_ids)

        sentences_count = word.sentences.size
        if token_set.roughtotal
          token_set.roughtotal += sentences_count
        else
          token_set.roughtotal = sentences_count
        end

        token_set.save
      end
    end

    word_count += 1
    if word_count % 10000 == 0
      print &amp;quot;processed &amp;quot; + word_count.to_s + &amp;quot; words\n&amp;quot;
      GC.start
    end
    # break unless word_count &amp;lt; 2000
  end
end
&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
class Word &amp;lt; ActiveRecord::Base

  #  has_many :word_parses
  #  has_many :parses, :through =&amp;gt; :word_parses
  has_and_belongs_to_many :parses, :join_table =&amp;gt; &amp;quot;word_parses&amp;quot;

  has_and_belongs_to_many :features, :join_table =&amp;gt; &amp;quot;words_features&amp;quot;, :uniq =&amp;gt; true

  has_and_belongs_to_many :sentences, :join_table =&amp;gt; &amp;quot;words_sentences&amp;quot;, :uniq =&amp;gt; true

  has_many :spellings

  ...

&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
class Sentence &amp;lt; ActiveRecord::Base

  has_and_belongs_to_many :words, :join_table =&amp;gt; &amp;quot;words_sentences&amp;quot;, :uniq =&amp;gt; true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;schema.rb&lt;/p&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
ActiveRecord::Schema.define(:version =&amp;gt; 5) do

  create_table &amp;quot;features&amp;quot;, :force =&amp;gt; true do |t|
    t.text &amp;quot;description&amp;quot;
  end

  create_table &amp;quot;parses&amp;quot;, :force =&amp;gt; true do |t|
    t.text &amp;quot;parse_text&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;parses&amp;quot;, [&amp;quot;parse_text&amp;quot;], :name =&amp;gt; &amp;quot;parse_text&amp;quot;

  create_table &amp;quot;sentences&amp;quot;, :force =&amp;gt; true do |t|
    t.text &amp;quot;spelling_sequence&amp;quot;,      :null =&amp;gt; false
    t.text &amp;quot;correct_parse_sequence&amp;quot;, :null =&amp;gt; false
  end

  create_table &amp;quot;spellings&amp;quot;, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;, :null =&amp;gt; false
    t.text    &amp;quot;text&amp;quot;,    :null =&amp;gt; false
  end

  add_index &amp;quot;spellings&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;spellings&amp;quot;, [&amp;quot;text&amp;quot;], :name =&amp;gt; &amp;quot;text&amp;quot;

  create_table &amp;quot;token_sets&amp;quot;, :force =&amp;gt; true do |t|
    t.integer  &amp;quot;count&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;
    t.datetime &amp;quot;updated_at&amp;quot;
    t.text     &amp;quot;token_ids&amp;quot;
  end

  add_index &amp;quot;token_sets&amp;quot;, [&amp;quot;token_ids&amp;quot;], :name =&amp;gt; &amp;quot;token_ids&amp;quot;

  create_table &amp;quot;tokens&amp;quot;, :force =&amp;gt; true do |t|
    t.text     &amp;quot;text&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;
    t.datetime &amp;quot;updated_at&amp;quot;
  end

  add_index &amp;quot;tokens&amp;quot;, [&amp;quot;text&amp;quot;], :name =&amp;gt; &amp;quot;text&amp;quot;

  create_table &amp;quot;word_parses&amp;quot;, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;,  :null =&amp;gt; false
    t.integer &amp;quot;parse_id&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;word_parses&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;word_parses&amp;quot;, [&amp;quot;parse_id&amp;quot;], :name =&amp;gt; &amp;quot;parse_id&amp;quot;

  create_table &amp;quot;words&amp;quot;, :force =&amp;gt; true do |t|
    t.string &amp;quot;name&amp;quot;, :limit =&amp;gt; 100, :null =&amp;gt; false
  end

  add_index &amp;quot;words&amp;quot;, [&amp;quot;name&amp;quot;], :name =&amp;gt; &amp;quot;name&amp;quot;

  create_table &amp;quot;words_features&amp;quot;, :id =&amp;gt; false, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;,    :null =&amp;gt; false
    t.integer &amp;quot;feature_id&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;words_features&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;words_features&amp;quot;, [&amp;quot;feature_id&amp;quot;], :name =&amp;gt; &amp;quot;feature_id&amp;quot;

  create_table &amp;quot;words_sentences&amp;quot;, :id =&amp;gt; false, :force =&amp;gt; true do |t|
    t.integer &amp;quot;word_id&amp;quot;,     :null =&amp;gt; false
    t.integer &amp;quot;sentence_id&amp;quot;, :null =&amp;gt; false
  end

  add_index &amp;quot;words_sentences&amp;quot;, [&amp;quot;word_id&amp;quot;], :name =&amp;gt; &amp;quot;word_id&amp;quot;
  add_index &amp;quot;words_sentences&amp;quot;, [&amp;quot;sentence_id&amp;quot;], :name =&amp;gt; &amp;quot;sentence_id&amp;quot;

end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-10-27T13:31:15+00:00</created-at>
      <creator-id type="integer">35668</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1279</number>
      <permalink>210-associations-cause-memory-leak</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>2.1 activerecord has_and_belongs_to_many leak memory</tag>
      <title>2.1.0 associations cause memory leak?</title>
      <updated-at type="datetime">2008-10-27T13:31:20+00:00</updated-at>
      <user-id type="integer">35668</user-id>
      <version type="integer">1</version>
      <user-name>onur g&#252;ng&#246;r</user-name>
      <creator-name>onur g&#252;ng&#246;r</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1279</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>addind the log of the version with no associations...</body>
      <body-html>&lt;div&gt;&lt;p&gt;addind the log of the version with no associations...&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-10-27T13:32:32+00:00</created-at>
      <creator-id type="integer">35668</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1279</number>
      <permalink>210-associations-cause-memory-leak</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>2.1 activerecord has_and_belongs_to_many leak memory</tag>
      <title>2.1.0 associations cause memory leak?</title>
      <updated-at type="datetime">2008-10-27T13:32:37+00:00</updated-at>
      <user-id type="integer">35668</user-id>
      <version type="integer">2</version>
      <user-name>onur g&#252;ng&#246;r</user-name>
      <creator-name>onur g&#252;ng&#246;r</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1279</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">2</attachments-count>
      <body>So word.sentences.size will cause the association to be loaded into memory inside a instance variable in word. Ruby can't garbage collect the array holding the sentences because the word still refers to it, and ruby can't garbage collect words you have already processed because the words array still refers to them.

One way of dodging this is to use count instead of size (since that won't cause the target to be loaded). Another way would be to split words into batches (so that when you have finished one batch nothing refers to those words any more and it can be garbage collected, yet another way would be change the find call to load records (for example) 500 at a time.

Nothing bad that rails is doing :-)</body>
      <body-html>&lt;div&gt;&lt;p&gt;So word.sentences.size will cause the association to be loaded
into memory inside a instance variable in word. Ruby can't garbage
collect the array holding the sentences because the word still
refers to it, and ruby can't garbage collect words you have already
processed because the words array still refers to them.&lt;/p&gt;
&lt;p&gt;One way of dodging this is to use count instead of size (since
that won't cause the target to be loaded). Another way would be to
split words into batches (so that when you have finished one batch
nothing refers to those words any more and it can be garbage
collected, yet another way would be change the find call to load
records (for example) 500 at a time.&lt;/p&gt;
&lt;p&gt;Nothing bad that rails is doing :-)&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-12-12T16:48:10+00:00</created-at>
      <creator-id type="integer">35668</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1279</number>
      <permalink>210-associations-cause-memory-leak</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>invalid</state>
      <tag>2.1 activerecord has_and_belongs_to_many leak memory</tag>
      <title>2.1.0 associations cause memory leak?</title>
      <updated-at type="datetime">2008-12-12T16:48:12+00:00</updated-at>
      <user-id type="integer">17477</user-id>
      <version type="integer">3</version>
      <user-name>Frederick Cheung</user-name>
      <creator-name>onur g&#252;ng&#246;r</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1279</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">2</attachments-count>
      <body>thanks for the notice, I already solved the problem by using batches.

I will follow your recommendation of using count() instead at the earlies convenience.</body>
      <body-html>&lt;div&gt;&lt;p&gt;thanks for the notice, I already solved the problem by using
batches.&lt;/p&gt;
&lt;p&gt;I will follow your recommendation of using count() instead at
the earlies convenience.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-12-12T20:45:38+00:00</created-at>
      <creator-id type="integer">35668</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1279</number>
      <permalink>210-associations-cause-memory-leak</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>invalid</state>
      <tag>2.1 activerecord has_and_belongs_to_many leak memory</tag>
      <title>2.1.0 associations cause memory leak?</title>
      <updated-at type="datetime">2008-12-12T20:45:38+00:00</updated-at>
      <user-id type="integer">35668</user-id>
      <version type="integer">4</version>
      <user-name>onur g&#252;ng&#246;r</user-name>
      <creator-name>onur g&#252;ng&#246;r</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1279</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
  </versions>
  <attachments type="array">
    <attachment type="Attachment">
      <code>e546f177eeec1d16cb065c6c8d0ae8e33220eab2</code>
      <content-type>application/octet-stream</content-type>
      <created-at type="datetime">2008-10-27T13:31:16+00:00</created-at>
      <filename>memory_profiler-assoc.log</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">57235</id>
      <size type="integer">2590</size>
      <uploader-id type="integer">35668</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/57235/memory_profiler-assoc.log</url>
    </attachment>
    <attachment type="Attachment">
      <code>336fddf7154d7dc6771d26495a565934f71a27a6</code>
      <content-type>application/octet-stream</content-type>
      <created-at type="datetime">2008-10-27T13:32:32+00:00</created-at>
      <filename>memory_profiler-no-assoc.log</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">57236</id>
      <size type="integer">2528</size>
      <uploader-id type="integer">35668</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/57236/memory_profiler-no-assoc.log</url>
    </attachment>
  </attachments>
</ticket>
