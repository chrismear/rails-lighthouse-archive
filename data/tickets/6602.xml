<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer" nil="true"></assigned-user-id>
  <attachments-count type="integer">0</attachments-count>
  <closed type="boolean">false</closed>
  <created-at type="datetime">2011-03-21T19:36:12+00:00</created-at>
  <creator-id type="integer">142219</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer" nil="true"></milestone-id>
  <number type="integer">6602</number>
  <permalink>invalid-sql-duplicate-columns-in-select-list-generated-by-include-on-not-yet-loaded-has_many-through</permalink>
  <priority type="integer">0</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>new</state>
  <tag nil="true"></tag>
  <title>Invalid SQL (duplicate columns in select list) generated by include? on not-yet-loaded has_many :through</title>
  <updated-at type="datetime">2011-03-21T19:36:14+00:00</updated-at>
  <user-id type="integer">142219</user-id>
  <version type="integer">1</version>
  <user-name>ystael</user-name>
  <creator-name>ystael</creator-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/6602</url>
  <priority-name nil="true"></priority-name>
  <original-body>When include? is called on a has_many :through association proxy which has not yet been loaded, the resulting SQL refers to a column twice in the select list, which is invalid at least on MS SQL Server.  Example:

@@@ ruby
class Foo &lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :bars, :through =&gt; :foos_bars
end

class Bar &lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :foos, :through =&gt; :foos_bars
end

class FoosBar &lt; ActiveRecord::Base
  belongs_to :foo
  belongs_to :bar
end
@@@

Now create one Foo, one Bar, and one FoosBar connecting them, then restart the console and try:
@@@ ruby
&gt; foo = Foo.first
&gt; bar = Bar.first
&gt; foo.bars.include?(bar)
@@@

The following exception results:

@@@ sql
ActiveRecord::StatementInvalid: ActiveRecord::JDBCError: The column 'id' was specified multiple times for 't'.: SELECT t.* FROM (SELECT ROW_NUMBER() OVER(ORDER BY bars.id) AS _row_num, bars.*, bars.[id] FROM bars INNER JOIN foos_bars ON bars.id = foos_bars.bar_id WHERE bars.[id] = 1 AND ((foos_bars.foo_id = 1))) AS t WHERE t._row_num BETWEEN 1 AND 1
@@@

The issue does not arise if before calling foo.bars.include?(bar) one first causes the association to be loaded, for example by asking for foo.bars.length .

On MySQL we get similar SQL generated, but on MySQL it is allowed to name a column twice in the select list:
@@@ sql
SELECT `bars`.*, `bars`.`id` FROM `bars` INNER JOIN `foos_bars` ON `bars`.id = `foos_bars`.bar_id WHERE `bars`.`id` = 1 AND ((`foos_bars`.foo_id = 1)) LIMIT 1
@@@

Environment: Rails 3.0.5, JRuby 1.6.0, AR-JDBC 1.1.1, Windows 7, MS SQL Server 2008.  Note that in this exact environment this issue is masked by another bug in AR-JDBC, issue http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156 .  My fork https://github.com/ystael/activerecord-jdbc-adapter contains a tentative fix for that issue which unmasks this one.</original-body>
  <latest-body>When include? is called on a has_many :through association proxy which has not yet been loaded, the resulting SQL refers to a column twice in the select list, which is invalid at least on MS SQL Server.  Example:

@@@ ruby
class Foo &lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :bars, :through =&gt; :foos_bars
end

class Bar &lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :foos, :through =&gt; :foos_bars
end

class FoosBar &lt; ActiveRecord::Base
  belongs_to :foo
  belongs_to :bar
end
@@@

Now create one Foo, one Bar, and one FoosBar connecting them, then restart the console and try:
@@@ ruby
&gt; foo = Foo.first
&gt; bar = Bar.first
&gt; foo.bars.include?(bar)
@@@

The following exception results:

@@@ sql
ActiveRecord::StatementInvalid: ActiveRecord::JDBCError: The column 'id' was specified multiple times for 't'.: SELECT t.* FROM (SELECT ROW_NUMBER() OVER(ORDER BY bars.id) AS _row_num, bars.*, bars.[id] FROM bars INNER JOIN foos_bars ON bars.id = foos_bars.bar_id WHERE bars.[id] = 1 AND ((foos_bars.foo_id = 1))) AS t WHERE t._row_num BETWEEN 1 AND 1
@@@

The issue does not arise if before calling foo.bars.include?(bar) one first causes the association to be loaded, for example by asking for foo.bars.length .

On MySQL we get similar SQL generated, but on MySQL it is allowed to name a column twice in the select list:
@@@ sql
SELECT `bars`.*, `bars`.`id` FROM `bars` INNER JOIN `foos_bars` ON `bars`.id = `foos_bars`.bar_id WHERE `bars`.`id` = 1 AND ((`foos_bars`.foo_id = 1)) LIMIT 1
@@@

Environment: Rails 3.0.5, JRuby 1.6.0, AR-JDBC 1.1.1, Windows 7, MS SQL Server 2008.  Note that in this exact environment this issue is masked by another bug in AR-JDBC, issue http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156 .  My fork https://github.com/ystael/activerecord-jdbc-adapter contains a tentative fix for that issue which unmasks this one.</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;When include? is called on a has_many :through association proxy
which has not yet been loaded, the resulting SQL refers to a column
twice in the select list, which is invalid at least on MS SQL
Server. Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;class Foo &amp;lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :bars, :through =&amp;gt; :foos_bars
end

class Bar &amp;lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :foos, :through =&amp;gt; :foos_bars
end

class FoosBar &amp;lt; ActiveRecord::Base
  belongs_to :foo
  belongs_to :bar
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Now create one Foo, one Bar, and one FoosBar connecting them,
then restart the console and try:&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;&amp;gt; foo = Foo.first
&amp;gt; bar = Bar.first
&amp;gt; foo.bars.include?(bar)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The following exception results:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;ActiveRecord::StatementInvalid: ActiveRecord::JDBCError: The column 'id' was specified multiple times for 't'.: SELECT t.* FROM (SELECT ROW_NUMBER() OVER(ORDER BY bars.id) AS _row_num, bars.*, bars.[id] FROM bars INNER JOIN foos_bars ON bars.id = foos_bars.bar_id WHERE bars.[id] = 1 AND ((foos_bars.foo_id = 1))) AS t WHERE t._row_num BETWEEN 1 AND 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The issue does not arise if before calling
foo.bars.include?(bar) one first causes the association to be
loaded, for example by asking for foo.bars.length .&lt;/p&gt;
&lt;p&gt;On MySQL we get similar SQL generated, but on MySQL it is
allowed to name a column twice in the select list:&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;SELECT `bars`.*, `bars`.`id` FROM `bars` INNER JOIN `foos_bars` ON `bars`.id = `foos_bars`.bar_id WHERE `bars`.`id` = 1 AND ((`foos_bars`.foo_id = 1)) LIMIT 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Environment: Rails 3.0.5, JRuby 1.6.0, AR-JDBC 1.1.1, Windows 7,
MS SQL Server 2008. Note that in this exact environment this issue
is masked by another bug in AR-JDBC, issue &lt;a href=
&quot;http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156&quot;&gt;http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156&lt;/a&gt;
. My fork &lt;a href=
&quot;https://github.com/ystael/activerecord-jdbc-adapter&quot;&gt;https://github.com/ystael/activerecord-jdbc-adapter&lt;/a&gt;
contains a tentative fix for that issue which unmasks this one.&lt;/p&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>When include? is called on a has_many :through association proxy which has not yet been loaded, the resulting SQL refers to a column twice in the select list, which is invalid at least on MS SQL Server.  Example:

@@@ ruby
class Foo &lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :bars, :through =&gt; :foos_bars
end

class Bar &lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :foos, :through =&gt; :foos_bars
end

class FoosBar &lt; ActiveRecord::Base
  belongs_to :foo
  belongs_to :bar
end
@@@

Now create one Foo, one Bar, and one FoosBar connecting them, then restart the console and try:
@@@ ruby
&gt; foo = Foo.first
&gt; bar = Bar.first
&gt; foo.bars.include?(bar)
@@@

The following exception results:

@@@ sql
ActiveRecord::StatementInvalid: ActiveRecord::JDBCError: The column 'id' was specified multiple times for 't'.: SELECT t.* FROM (SELECT ROW_NUMBER() OVER(ORDER BY bars.id) AS _row_num, bars.*, bars.[id] FROM bars INNER JOIN foos_bars ON bars.id = foos_bars.bar_id WHERE bars.[id] = 1 AND ((foos_bars.foo_id = 1))) AS t WHERE t._row_num BETWEEN 1 AND 1
@@@

The issue does not arise if before calling foo.bars.include?(bar) one first causes the association to be loaded, for example by asking for foo.bars.length .

On MySQL we get similar SQL generated, but on MySQL it is allowed to name a column twice in the select list:
@@@ sql
SELECT `bars`.*, `bars`.`id` FROM `bars` INNER JOIN `foos_bars` ON `bars`.id = `foos_bars`.bar_id WHERE `bars`.`id` = 1 AND ((`foos_bars`.foo_id = 1)) LIMIT 1
@@@

Environment: Rails 3.0.5, JRuby 1.6.0, AR-JDBC 1.1.1, Windows 7, MS SQL Server 2008.  Note that in this exact environment this issue is masked by another bug in AR-JDBC, issue http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156 .  My fork https://github.com/ystael/activerecord-jdbc-adapter contains a tentative fix for that issue which unmasks this one.</body>
      <body-html>&lt;div&gt;&lt;p&gt;When include? is called on a has_many :through association proxy
which has not yet been loaded, the resulting SQL refers to a column
twice in the select list, which is invalid at least on MS SQL
Server. Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;class Foo &amp;lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :bars, :through =&amp;gt; :foos_bars
end

class Bar &amp;lt; ActiveRecord::Base
  has_many :foos_bars
  has_many :foos, :through =&amp;gt; :foos_bars
end

class FoosBar &amp;lt; ActiveRecord::Base
  belongs_to :foo
  belongs_to :bar
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Now create one Foo, one Bar, and one FoosBar connecting them,
then restart the console and try:&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;&amp;gt; foo = Foo.first
&amp;gt; bar = Bar.first
&amp;gt; foo.bars.include?(bar)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The following exception results:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;ActiveRecord::StatementInvalid: ActiveRecord::JDBCError: The column 'id' was specified multiple times for 't'.: SELECT t.* FROM (SELECT ROW_NUMBER() OVER(ORDER BY bars.id) AS _row_num, bars.*, bars.[id] FROM bars INNER JOIN foos_bars ON bars.id = foos_bars.bar_id WHERE bars.[id] = 1 AND ((foos_bars.foo_id = 1))) AS t WHERE t._row_num BETWEEN 1 AND 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The issue does not arise if before calling
foo.bars.include?(bar) one first causes the association to be
loaded, for example by asking for foo.bars.length .&lt;/p&gt;
&lt;p&gt;On MySQL we get similar SQL generated, but on MySQL it is
allowed to name a column twice in the select list:&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;SELECT `bars`.*, `bars`.`id` FROM `bars` INNER JOIN `foos_bars` ON `bars`.id = `foos_bars`.bar_id WHERE `bars`.`id` = 1 AND ((`foos_bars`.foo_id = 1)) LIMIT 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Environment: Rails 3.0.5, JRuby 1.6.0, AR-JDBC 1.1.1, Windows 7,
MS SQL Server 2008. Note that in this exact environment this issue
is masked by another bug in AR-JDBC, issue &lt;a href=
&quot;http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156&quot;&gt;http://kenai.com/jira/browse/ACTIVERECORD_JDBC-156&lt;/a&gt;
. My fork &lt;a href=
&quot;https://github.com/ystael/activerecord-jdbc-adapter&quot;&gt;https://github.com/ystael/activerecord-jdbc-adapter&lt;/a&gt;
contains a tentative fix for that issue which unmasks this one.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-03-21T19:36:12+00:00</created-at>
      <creator-id type="integer">142219</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6602</number>
      <permalink>invalid-sql-duplicate-columns-in-select-list-generated-by-include-on-not-yet-loaded-has_many-through</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>Invalid SQL (duplicate columns in select list) generated by include? on not-yet-loaded has_many :through</title>
      <updated-at type="datetime">2011-03-21T19:36:14+00:00</updated-at>
      <user-id type="integer">142219</user-id>
      <version type="integer">1</version>
      <user-name>ystael</user-name>
      <creator-name>ystael</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6602</url>
      <priority-name nil="true"></priority-name>
    </version>
  </versions>
</ticket>
