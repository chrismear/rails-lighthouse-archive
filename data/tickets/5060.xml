<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer">15316</assigned-user-id>
  <attachments-count type="integer">1</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2010-09-14T04:39:35+01:00</created-at>
  <creator-id type="integer">12845</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer">71472</milestone-id>
  <number type="integer">5060</number>
  <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
  <priority type="integer">3</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>committed</state>
  <tag>activerecord scope</tag>
  <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
  <updated-at type="datetime">2011-03-30T17:55:18+01:00</updated-at>
  <user-id type="integer">15316</user-id>
  <version type="integer">26</version>
  <user-name>Aaron Patterson</user-name>
  <creator-name>Wincent Colaiuta</creator-name>
  <assigned-user-name>Aaron Patterson</assigned-user-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
  <milestone-title>3.x</milestone-title>
  <priority-name>Low</priority-name>
  <original-body>Calling &quot;empty?&quot; on an ActiveRelation instance returned by &quot;offset()&quot; (eg. &quot;Article.scoped.limit(10).offset(10).empty?&quot;) reports &quot;true&quot; even when the result set is non-empty.

# Demonstration #

Given a bunch of sample records:

@@@
&gt;&gt; Article.count
  SQL (3.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&gt; 38
@@@

Expected behavior of &quot;length&quot; and &quot;empty?&quot; methods on ActiveRelation instances:

First, &quot;where&quot;:

- Note how calling &quot;length&quot; actually retrieves the records and the &quot;length&quot; returned is the number of records.
- Calling &quot;empty?&quot; does not retrieve the records and instead executes a &quot;COUNT&quot; query

@@@
&gt;&gt; Article.where(:public =&gt; true).length
  Article Load (1.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1)
=&gt; 38

&gt;&gt; Article.where(:public =&gt; true).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1)
=&gt; false
@@@

Now for &quot;limit&quot;:

- Again, &quot;length&quot; retrieves the records and reports the actual number
- And again, &quot;empty?&quot; does not retrieve the records but instead does a &quot;COUNT&quot; (although note here that the &quot;LIMIT&quot; has absolutely no effect because only 1 row, the count value, will ever be returned)

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&gt; 10

&gt;&gt; Article.where(:public =&gt; true).limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&gt; false
@@@

Finally, let's look at &quot;offset&quot;:

- &quot;length&quot; retrieves the records and reports the actual number
- &quot;empty?&quot; does not retrieve the records, does a &quot;COUNT&quot; query, and returns &quot;true&quot; instead of the expected &quot;false&quot;

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&gt; 10
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(10).empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&gt; true
@@@

If we do offset(0) then the result is the opposite:

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(0).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 0, 10
=&gt; false
@@@

# Analysis #

So this is happening because &quot;empty?&quot; is executing a COUNT query with a LIMIT clause on it.

The COUNT query will always return exactly 1 row, containing the number of matching rows.

In the case where the LIMIT clause is something like &quot;LIMIT 10&quot; this has no effect.

In the case where &quot;offset()&quot; is used and the LIMIT clause becomes something like &quot;LIMIT 10, 10&quot;, the COUNT query returns nothing at all because the one row that it would normally return is pruned. This in turn is interpreted as being zero, and so &quot;empty?&quot; returns true.

# Implications #

The behavior might catch out people upgrading from the older query syntax. For example, I discovered this issue when I converted an old call like this:

@@@
@articles = Article.find :all, :conditions =&gt; &quot;...&quot;, :order =&gt; ..., :limit =&gt; ..., :offset =&gt; ...
@@@

To use scopes:

@@@
scope :published, where(:public =&gt; true)
scope :recent, published.order('updated_at DESC').limit(10)

@articles = Article.recent.offset(...)
@@@

All of this works fine, until we hit the view code:

@@@
unless @articles.empty?
  ...
@@@

All of a sudden, @articles.empty? was returning &quot;true&quot; even though @articles wasn't really empty, thus breaking the view.

So basically this could affect anyone who is using &quot;offset()&quot; and expecting &quot;empty?&quot; to work on it.

# Workaround #

Must force the execution of the query by using &quot;all()&quot; or some other means before calling &quot;empty?&quot;; eg:

@@@
Article.where(:public =&gt; true).limit(10).offset(10).all.empty?
@@@

# Solution #

I suspect that the behavior of making &quot;empty?&quot; trigger a COUNT query is probably the wrong thing to do.

Just as &quot;length&quot; triggers record retrieval, &quot;empty?&quot; probably should too.

If, however, it is decided that the different behavior of &quot;length&quot; (triggering SELECT) and &quot;empty?&quot; (triggering SELECT COUNT) is seen as a desirable thing, we should at least modify the behavior of the &quot;empty?&quot; method when it is used on an offset() relation, because the currently constructed query doesn't make any sense.

ie. it doesn't make sense for *any* query that starts with &quot;SELECT COUNT&quot; to include any &quot;LIMIT&quot; clause at all, because it will either be a no-op, or will prune away the actual result row.

So at the very least, if a relation obtained via &quot;offset()&quot; receives an &quot;empty?&quot; message then it should trigger a &quot;SELECT COUNT&quot; query *without* the LIMIT clause on it.</original-body>
  <latest-body>Calling &quot;empty?&quot; on an ActiveRelation instance returned by &quot;offset()&quot; (eg. &quot;Article.scoped.limit(10).offset(10).empty?&quot;) reports &quot;true&quot; even when the result set is non-empty.

# Demonstration #

Given a bunch of sample records:

@@@
&gt;&gt; Article.count
  SQL (3.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&gt; 38
@@@

Expected behavior of &quot;length&quot; and &quot;empty?&quot; methods on ActiveRelation instances:

First, &quot;where&quot;:

- Note how calling &quot;length&quot; actually retrieves the records and the &quot;length&quot; returned is the number of records.
- Calling &quot;empty?&quot; does not retrieve the records and instead executes a &quot;COUNT&quot; query

@@@
&gt;&gt; Article.where(:public =&gt; true).length
  Article Load (1.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1)
=&gt; 38

&gt;&gt; Article.where(:public =&gt; true).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1)
=&gt; false
@@@

Now for &quot;limit&quot;:

- Again, &quot;length&quot; retrieves the records and reports the actual number
- And again, &quot;empty?&quot; does not retrieve the records but instead does a &quot;COUNT&quot; (although note here that the &quot;LIMIT&quot; has absolutely no effect because only 1 row, the count value, will ever be returned)

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&gt; 10

&gt;&gt; Article.where(:public =&gt; true).limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&gt; false
@@@

Finally, let's look at &quot;offset&quot;:

- &quot;length&quot; retrieves the records and reports the actual number
- &quot;empty?&quot; does not retrieve the records, does a &quot;COUNT&quot; query, and returns &quot;true&quot; instead of the expected &quot;false&quot;

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&gt; 10
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(10).empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&gt; true
@@@

If we do offset(0) then the result is the opposite:

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(0).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 0, 10
=&gt; false
@@@

# Analysis #

So this is happening because &quot;empty?&quot; is executing a COUNT query with a LIMIT clause on it.

The COUNT query will always return exactly 1 row, containing the number of matching rows.

In the case where the LIMIT clause is something like &quot;LIMIT 10&quot; this has no effect.

In the case where &quot;offset()&quot; is used and the LIMIT clause becomes something like &quot;LIMIT 10, 10&quot;, the COUNT query returns nothing at all because the one row that it would normally return is pruned. This in turn is interpreted as being zero, and so &quot;empty?&quot; returns true.

# Implications #

The behavior might catch out people upgrading from the older query syntax. For example, I discovered this issue when I converted an old call like this:

@@@
@articles = Article.find :all, :conditions =&gt; &quot;...&quot;, :order =&gt; ..., :limit =&gt; ..., :offset =&gt; ...
@@@

To use scopes:

@@@
scope :published, where(:public =&gt; true)
scope :recent, published.order('updated_at DESC').limit(10)

@articles = Article.recent.offset(...)
@@@

All of this works fine, until we hit the view code:

@@@
unless @articles.empty?
  ...
@@@

All of a sudden, @articles.empty? was returning &quot;true&quot; even though @articles wasn't really empty, thus breaking the view.

So basically this could affect anyone who is using &quot;offset()&quot; and expecting &quot;empty?&quot; to work on it.

# Workaround #

Must force the execution of the query by using &quot;all()&quot; or some other means before calling &quot;empty?&quot;; eg:

@@@
Article.where(:public =&gt; true).limit(10).offset(10).all.empty?
@@@

# Solution #

I suspect that the behavior of making &quot;empty?&quot; trigger a COUNT query is probably the wrong thing to do.

Just as &quot;length&quot; triggers record retrieval, &quot;empty?&quot; probably should too.

If, however, it is decided that the different behavior of &quot;length&quot; (triggering SELECT) and &quot;empty?&quot; (triggering SELECT COUNT) is seen as a desirable thing, we should at least modify the behavior of the &quot;empty?&quot; method when it is used on an offset() relation, because the currently constructed query doesn't make any sense.

ie. it doesn't make sense for *any* query that starts with &quot;SELECT COUNT&quot; to include any &quot;LIMIT&quot; clause at all, because it will either be a no-op, or will prune away the actual result row.

So at the very least, if a relation obtained via &quot;offset()&quot; receives an &quot;empty?&quot; message then it should trigger a &quot;SELECT COUNT&quot; query *without* the LIMIT clause on it.</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;Calling &quot;empty?&quot; on an ActiveRelation instance returned by
&quot;offset()&quot; (eg. &quot;Article.scoped.limit(10).offset(10).empty?&quot;)
reports &quot;true&quot; even when the result set is non-empty.&lt;/p&gt;
&lt;h1&gt;Demonstration&lt;/h1&gt;
&lt;p&gt;Given a bunch of sample records:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.count
  SQL (3.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&amp;gt; 38&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Expected behavior of &quot;length&quot; and &quot;empty?&quot; methods on
ActiveRelation instances:&lt;/p&gt;
&lt;p&gt;First, &quot;where&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note how calling &quot;length&quot; actually retrieves the records and
the &quot;length&quot; returned is the number of records.&lt;/li&gt;
&lt;li&gt;Calling &quot;empty?&quot; does not retrieve the records and instead
executes a &quot;COUNT&quot; query&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).length
  Article Load (1.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1)
=&amp;gt; 38

&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1)
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Now for &quot;limit&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Again, &quot;length&quot; retrieves the records and reports the actual
number&lt;/li&gt;
&lt;li&gt;And again, &quot;empty?&quot; does not retrieve the records but instead
does a &quot;COUNT&quot; (although note here that the &quot;LIMIT&quot; has absolutely
no effect because only 1 row, the count value, will ever be
returned)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&amp;gt; 10

&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Finally, let's look at &quot;offset&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&quot;length&quot; retrieves the records and reports the actual
number&lt;/li&gt;
&lt;li&gt;&quot;empty?&quot; does not retrieve the records, does a &quot;COUNT&quot; query,
and returns &quot;true&quot; instead of the expected &quot;false&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).offset(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&amp;gt; 10
&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).offset(10).empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;If we do offset(0) then the result is the opposite:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).offset(0).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 0, 10
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;h1&gt;Analysis&lt;/h1&gt;
&lt;p&gt;So this is happening because &quot;empty?&quot; is executing a COUNT query
with a LIMIT clause on it.&lt;/p&gt;
&lt;p&gt;The COUNT query will always return exactly 1 row, containing the
number of matching rows.&lt;/p&gt;
&lt;p&gt;In the case where the LIMIT clause is something like &quot;LIMIT 10&quot;
this has no effect.&lt;/p&gt;
&lt;p&gt;In the case where &quot;offset()&quot; is used and the LIMIT clause
becomes something like &quot;LIMIT 10, 10&quot;, the COUNT query returns
nothing at all because the one row that it would normally return is
pruned. This in turn is interpreted as being zero, and so &quot;empty?&quot;
returns true.&lt;/p&gt;
&lt;h1&gt;Implications&lt;/h1&gt;
&lt;p&gt;The behavior might catch out people upgrading from the older
query syntax. For example, I discovered this issue when I converted
an old call like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@articles = Article.find :all, :conditions =&amp;gt; &quot;...&quot;, :order =&amp;gt; ..., :limit =&amp;gt; ..., :offset =&amp;gt; ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;To use scopes:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scope :published, where(:public =&amp;gt; true)
scope :recent, published.order('updated_at DESC').limit(10)

@articles = Article.recent.offset(...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;All of this works fine, until we hit the view code:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unless @articles.empty?
  ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;All of a sudden, @articles.empty? was returning &quot;true&quot; even
though @articles wasn't really empty, thus breaking the view.&lt;/p&gt;
&lt;p&gt;So basically this could affect anyone who is using &quot;offset()&quot;
and expecting &quot;empty?&quot; to work on it.&lt;/p&gt;
&lt;h1&gt;Workaround&lt;/h1&gt;
&lt;p&gt;Must force the execution of the query by using &quot;all()&quot; or some
other means before calling &quot;empty?&quot;; eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Article.where(:public =&amp;gt; true).limit(10).offset(10).all.empty?&lt;/code&gt;
&lt;/pre&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;I suspect that the behavior of making &quot;empty?&quot; trigger a COUNT
query is probably the wrong thing to do.&lt;/p&gt;
&lt;p&gt;Just as &quot;length&quot; triggers record retrieval, &quot;empty?&quot; probably
should too.&lt;/p&gt;
&lt;p&gt;If, however, it is decided that the different behavior of
&quot;length&quot; (triggering SELECT) and &quot;empty?&quot; (triggering SELECT COUNT)
is seen as a desirable thing, we should at least modify the
behavior of the &quot;empty?&quot; method when it is used on an offset()
relation, because the currently constructed query doesn't make any
sense.&lt;/p&gt;
&lt;p&gt;ie. it doesn't make sense for &lt;em&gt;any&lt;/em&gt; query that starts
with &quot;SELECT COUNT&quot; to include any &quot;LIMIT&quot; clause at all, because
it will either be a no-op, or will prune away the actual result
row.&lt;/p&gt;
&lt;p&gt;So at the very least, if a relation obtained via &quot;offset()&quot;
receives an &quot;empty?&quot; message then it should trigger a &quot;SELECT
COUNT&quot; query &lt;em&gt;without&lt;/em&gt; the LIMIT clause on it.&lt;/p&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Calling &quot;empty?&quot; on an ActiveRelation instance returned by &quot;offset()&quot; (eg. &quot;Article.scoped.limit(10).offset(10).empty?&quot;) reports &quot;true&quot; even when the result set is non-empty.

# Demonstration #

Given a bunch of sample records:

@@@
&gt;&gt; Article.count
  SQL (3.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&gt; 38
@@@

Expected behavior of &quot;length&quot; and &quot;empty?&quot; methods on ActiveRelation instances:

First, &quot;where&quot;:

- Note how calling &quot;length&quot; actually retrieves the records and the &quot;length&quot; returned is the number of records.
- Calling &quot;empty?&quot; does not retrieve the records and instead executes a &quot;COUNT&quot; query

@@@
&gt;&gt; Article.where(:public =&gt; true).length
  Article Load (1.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1)
=&gt; 38

&gt;&gt; Article.where(:public =&gt; true).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1)
=&gt; false
@@@

Now for &quot;limit&quot;:

- Again, &quot;length&quot; retrieves the records and reports the actual number
- And again, &quot;empty?&quot; does not retrieve the records but instead does a &quot;COUNT&quot; (although note here that the &quot;LIMIT&quot; has absolutely no effect because only 1 row, the count value, will ever be returned)

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&gt; 10

&gt;&gt; Article.where(:public =&gt; true).limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&gt; false
@@@

Finally, let's look at &quot;offset&quot;:

- &quot;length&quot; retrieves the records and reports the actual number
- &quot;empty?&quot; does not retrieve the records, does a &quot;COUNT&quot; query, and returns &quot;true&quot; instead of the expected &quot;false&quot;

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&gt; 10
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(10).empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&gt; true
@@@

If we do offset(0) then the result is the opposite:

@@@
&gt;&gt; Article.where(:public =&gt; true).limit(10).offset(0).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 0, 10
=&gt; false
@@@

# Analysis #

So this is happening because &quot;empty?&quot; is executing a COUNT query with a LIMIT clause on it.

The COUNT query will always return exactly 1 row, containing the number of matching rows.

In the case where the LIMIT clause is something like &quot;LIMIT 10&quot; this has no effect.

In the case where &quot;offset()&quot; is used and the LIMIT clause becomes something like &quot;LIMIT 10, 10&quot;, the COUNT query returns nothing at all because the one row that it would normally return is pruned. This in turn is interpreted as being zero, and so &quot;empty?&quot; returns true.

# Implications #

The behavior might catch out people upgrading from the older query syntax. For example, I discovered this issue when I converted an old call like this:

@@@
@articles = Article.find :all, :conditions =&gt; &quot;...&quot;, :order =&gt; ..., :limit =&gt; ..., :offset =&gt; ...
@@@

To use scopes:

@@@
scope :published, where(:public =&gt; true)
scope :recent, published.order('updated_at DESC').limit(10)

@articles = Article.recent.offset(...)
@@@

All of this works fine, until we hit the view code:

@@@
unless @articles.empty?
  ...
@@@

All of a sudden, @articles.empty? was returning &quot;true&quot; even though @articles wasn't really empty, thus breaking the view.

So basically this could affect anyone who is using &quot;offset()&quot; and expecting &quot;empty?&quot; to work on it.

# Workaround #

Must force the execution of the query by using &quot;all()&quot; or some other means before calling &quot;empty?&quot;; eg:

@@@
Article.where(:public =&gt; true).limit(10).offset(10).all.empty?
@@@

# Solution #

I suspect that the behavior of making &quot;empty?&quot; trigger a COUNT query is probably the wrong thing to do.

Just as &quot;length&quot; triggers record retrieval, &quot;empty?&quot; probably should too.

If, however, it is decided that the different behavior of &quot;length&quot; (triggering SELECT) and &quot;empty?&quot; (triggering SELECT COUNT) is seen as a desirable thing, we should at least modify the behavior of the &quot;empty?&quot; method when it is used on an offset() relation, because the currently constructed query doesn't make any sense.

ie. it doesn't make sense for *any* query that starts with &quot;SELECT COUNT&quot; to include any &quot;LIMIT&quot; clause at all, because it will either be a no-op, or will prune away the actual result row.

So at the very least, if a relation obtained via &quot;offset()&quot; receives an &quot;empty?&quot; message then it should trigger a &quot;SELECT COUNT&quot; query *without* the LIMIT clause on it.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Calling &quot;empty?&quot; on an ActiveRelation instance returned by
&quot;offset()&quot; (eg. &quot;Article.scoped.limit(10).offset(10).empty?&quot;)
reports &quot;true&quot; even when the result set is non-empty.&lt;/p&gt;
&lt;h1&gt;Demonstration&lt;/h1&gt;
&lt;p&gt;Given a bunch of sample records:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.count
  SQL (3.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&amp;gt; 38&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Expected behavior of &quot;length&quot; and &quot;empty?&quot; methods on
ActiveRelation instances:&lt;/p&gt;
&lt;p&gt;First, &quot;where&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note how calling &quot;length&quot; actually retrieves the records and
the &quot;length&quot; returned is the number of records.&lt;/li&gt;
&lt;li&gt;Calling &quot;empty?&quot; does not retrieve the records and instead
executes a &quot;COUNT&quot; query&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).length
  Article Load (1.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1)
=&amp;gt; 38

&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1)
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Now for &quot;limit&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Again, &quot;length&quot; retrieves the records and reports the actual
number&lt;/li&gt;
&lt;li&gt;And again, &quot;empty?&quot; does not retrieve the records but instead
does a &quot;COUNT&quot; (although note here that the &quot;LIMIT&quot; has absolutely
no effect because only 1 row, the count value, will ever be
returned)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&amp;gt; 10

&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Finally, let's look at &quot;offset&quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&quot;length&quot; retrieves the records and reports the actual
number&lt;/li&gt;
&lt;li&gt;&quot;empty?&quot; does not retrieve the records, does a &quot;COUNT&quot; query,
and returns &quot;true&quot; instead of the expected &quot;false&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).offset(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&amp;gt; 10
&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).offset(10).empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 10, 10
=&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;If we do offset(0) then the result is the opposite:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.where(:public =&amp;gt; true).limit(10).offset(0).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` WHERE (`articles`.`public` = 1) LIMIT 0, 10
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;h1&gt;Analysis&lt;/h1&gt;
&lt;p&gt;So this is happening because &quot;empty?&quot; is executing a COUNT query
with a LIMIT clause on it.&lt;/p&gt;
&lt;p&gt;The COUNT query will always return exactly 1 row, containing the
number of matching rows.&lt;/p&gt;
&lt;p&gt;In the case where the LIMIT clause is something like &quot;LIMIT 10&quot;
this has no effect.&lt;/p&gt;
&lt;p&gt;In the case where &quot;offset()&quot; is used and the LIMIT clause
becomes something like &quot;LIMIT 10, 10&quot;, the COUNT query returns
nothing at all because the one row that it would normally return is
pruned. This in turn is interpreted as being zero, and so &quot;empty?&quot;
returns true.&lt;/p&gt;
&lt;h1&gt;Implications&lt;/h1&gt;
&lt;p&gt;The behavior might catch out people upgrading from the older
query syntax. For example, I discovered this issue when I converted
an old call like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@articles = Article.find :all, :conditions =&amp;gt; &quot;...&quot;, :order =&amp;gt; ..., :limit =&amp;gt; ..., :offset =&amp;gt; ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;To use scopes:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scope :published, where(:public =&amp;gt; true)
scope :recent, published.order('updated_at DESC').limit(10)

@articles = Article.recent.offset(...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;All of this works fine, until we hit the view code:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unless @articles.empty?
  ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;All of a sudden, @articles.empty? was returning &quot;true&quot; even
though @articles wasn't really empty, thus breaking the view.&lt;/p&gt;
&lt;p&gt;So basically this could affect anyone who is using &quot;offset()&quot;
and expecting &quot;empty?&quot; to work on it.&lt;/p&gt;
&lt;h1&gt;Workaround&lt;/h1&gt;
&lt;p&gt;Must force the execution of the query by using &quot;all()&quot; or some
other means before calling &quot;empty?&quot;; eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Article.where(:public =&amp;gt; true).limit(10).offset(10).all.empty?&lt;/code&gt;
&lt;/pre&gt;
&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;I suspect that the behavior of making &quot;empty?&quot; trigger a COUNT
query is probably the wrong thing to do.&lt;/p&gt;
&lt;p&gt;Just as &quot;length&quot; triggers record retrieval, &quot;empty?&quot; probably
should too.&lt;/p&gt;
&lt;p&gt;If, however, it is decided that the different behavior of
&quot;length&quot; (triggering SELECT) and &quot;empty?&quot; (triggering SELECT COUNT)
is seen as a desirable thing, we should at least modify the
behavior of the &quot;empty?&quot; method when it is used on an offset()
relation, because the currently constructed query doesn't make any
sense.&lt;/p&gt;
&lt;p&gt;ie. it doesn't make sense for &lt;em&gt;any&lt;/em&gt; query that starts
with &quot;SELECT COUNT&quot; to include any &quot;LIMIT&quot; clause at all, because
it will either be a no-op, or will prune away the actual result
row.&lt;/p&gt;
&lt;p&gt;So at the very least, if a relation obtained via &quot;offset()&quot;
receives an &quot;empty?&quot; message then it should trigger a &quot;SELECT
COUNT&quot; query &lt;em&gt;without&lt;/em&gt; the LIMIT clause on it.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-07T11:00:57+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-07T11:01:00+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">1</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>More digging:

**Example 1:**

@@@
&gt;&gt; Article.scoped.limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` LIMIT 10
=&gt; 10
&gt;&gt; Article.scoped.limit(10).size
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10
=&gt; 38
&gt;&gt; Article.scoped.limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10
=&gt; false
@@@

&quot;length&quot; delegates to &quot;to_a&quot; (in activerecord/lib/active_record/relation.rb), so it returns the expected result.

&quot;size&quot; calls &quot;count&quot; (in activerecord/lib/active_record/relation/calculations.rb), so it constructs a COUNT query which returns a surprising result.

&quot;empty?&quot; calls the same &quot;count&quot; method under the hood (&quot;count.zero?&quot;), so it behaves in the same way that &quot;size&quot; does.

**Example 2:**

@@@
&gt;&gt; Article.scoped.limit(10).offset(10).length
  Article Load (0.4ms)  SELECT `articles`.* FROM `articles` LIMIT 10, 10
=&gt; 10
&gt;&gt; Article.scoped.limit(10).offset(10).size
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10, 10
=&gt; 0
&gt;&gt; Article.scoped.limit(10).offset(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10, 10
=&gt; true
@@@

Here &quot;length&quot; again works because it delegates to &quot;to_a&quot;.

&quot;size&quot; here also calls &quot;count&quot;, and returns 0 because it's using a COUNT query with a LIMIT clause. This is a surprising result.

&quot;empty?&quot; calls &quot;count&quot; under the hood, so returns &quot;true&quot; here, which is a surprising result.

**Example 3:**

@@@
&gt;&gt; Article.scoped.size
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&gt; 38
&gt;&gt; Article.scoped.length
  Article Load (0.4ms)  SELECT `articles`.* FROM `articles`
=&gt; 38
&gt;&gt; Article.scoped.empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&gt; false
@@@

Only here do &quot;size&quot;, &quot;length&quot; and &quot;empty?&quot; agree, because there is no LIMIT component.</body>
      <body-html>&lt;div&gt;&lt;p&gt;More digging:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.scoped.limit(10).length
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` LIMIT 10
=&amp;gt; 10
&amp;gt;&amp;gt; Article.scoped.limit(10).size
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10
=&amp;gt; 38
&amp;gt;&amp;gt; Article.scoped.limit(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&quot;length&quot; delegates to &quot;to_a&quot; (in
activerecord/lib/active_record/relation.rb), so it returns the
expected result.&lt;/p&gt;
&lt;p&gt;&quot;size&quot; calls &quot;count&quot; (in
activerecord/lib/active_record/relation/calculations.rb), so it
constructs a COUNT query which returns a surprising result.&lt;/p&gt;
&lt;p&gt;&quot;empty?&quot; calls the same &quot;count&quot; method under the hood
(&quot;count.zero?&quot;), so it behaves in the same way that &quot;size&quot;
does.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.scoped.limit(10).offset(10).length
  Article Load (0.4ms)  SELECT `articles`.* FROM `articles` LIMIT 10, 10
=&amp;gt; 10
&amp;gt;&amp;gt; Article.scoped.limit(10).offset(10).size
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10, 10
=&amp;gt; 0
&amp;gt;&amp;gt; Article.scoped.limit(10).offset(10).empty?
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles` LIMIT 10, 10
=&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Here &quot;length&quot; again works because it delegates to &quot;to_a&quot;.&lt;/p&gt;
&lt;p&gt;&quot;size&quot; here also calls &quot;count&quot;, and returns 0 because it's using
a COUNT query with a LIMIT clause. This is a surprising result.&lt;/p&gt;
&lt;p&gt;&quot;empty?&quot; calls &quot;count&quot; under the hood, so returns &quot;true&quot; here,
which is a surprising result.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Article.scoped.size
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&amp;gt; 38
&amp;gt;&amp;gt; Article.scoped.length
  Article Load (0.4ms)  SELECT `articles`.* FROM `articles`
=&amp;gt; 38
&amp;gt;&amp;gt; Article.scoped.empty?
  SQL (0.4ms)  SELECT COUNT(*) AS count_id FROM `articles`
=&amp;gt; false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Only here do &quot;size&quot;, &quot;length&quot; and &quot;empty?&quot; agree, because there
is no LIMIT component.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-07T12:22:20+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-07T12:22:22+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">2</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Can somebody from the Rails team comment on this one? I'm happy to work on a patch to fix this, but I'd like to hear beforehand if I'm correcting in stating that these kinds of results are considered incorrect and therefore a bug:

    Article.scoped.limit(10).offset(5).length # 50 (correct)
    Article.scoped.limit(10).offset(5).size   # zero (incorrect)
    Article.scoped.limit(10).offset(5).empty? #&#160;true (incorrect)</body>
      <body-html>&lt;div&gt;&lt;p&gt;Can somebody from the Rails team comment on this one? I'm happy
to work on a patch to fix this, but I'd like to hear beforehand if
I'm correcting in stating that these kinds of results are
considered incorrect and therefore a bug:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Article.scoped.limit(10).offset(5).length # 50 (correct)
Article.scoped.limit(10).offset(5).size   # zero (incorrect)
Article.scoped.limit(10).offset(5).empty? # true (incorrect)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-15T20:40:35+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-15T20:40:36+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">3</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>@Wincent Earlier you mentioned that you might be leaning towards making #size work same as #length; meaning load all the records.  I would say that first attempt should be to have sql as efficient as possible and both #size and #empty? should make a COUNT sql.</body>
      <body-html>&lt;div&gt;&lt;p&gt;@Wincent Earlier you mentioned that you might be leaning towards
making #size work same as #length; meaning load all the records. I
would say that first attempt should be to have sql as efficient as
possible and both #size and #empty? should make a COUNT sql.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-15T21:59:55+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:priority: 0
:state: new
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag nil="true"></tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-15T21:59:57+01:00</updated-at>
      <user-id type="integer">40263</user-id>
      <version type="integer">4</version>
      <user-name>Neeraj Singh</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Yes, agreed that it should be efficient if possible. The trouble is that the query that is generated makes no sense:

   SELECT COUNT(*) FROM foo WHERE thing = 'bar' LIMIT 10, 10

will always return zero rows, because whatever the `COUNT` is gets lopped off by the `LIMIT` clause.

Ideally what `.empty?` and `.size` would do is strip off the `LIMIT` clause and actually do this:

   SELECT COUNT(*) FROM foo WHERE thing = 'bar'

Which is both correct and efficient.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Yes, agreed that it should be efficient if possible. The trouble
is that the query that is generated makes no sense:&lt;/p&gt;
&lt;p&gt;SELECT COUNT(*) FROM foo WHERE thing = 'bar' LIMIT 10, 10&lt;/p&gt;
&lt;p&gt;will always return zero rows, because whatever the
&lt;code&gt;COUNT&lt;/code&gt; is gets lopped off by the &lt;code&gt;LIMIT&lt;/code&gt;
clause.&lt;/p&gt;
&lt;p&gt;Ideally what &lt;code&gt;.empty?&lt;/code&gt; and &lt;code&gt;.size&lt;/code&gt; would
do is strip off the &lt;code&gt;LIMIT&lt;/code&gt; clause and actually do
this:&lt;/p&gt;
&lt;p&gt;SELECT COUNT(*) FROM foo WHERE thing = 'bar'&lt;/p&gt;
&lt;p&gt;Which is both correct and efficient.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-15T22:04:18+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag nil="true"></tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-15T22:04:21+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">5</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>The problem with dropping limit is that I can have a condition like 

@@@ ruby
Article.scoped.limit(10).offset(5).size
@@@

and the output could be a number &gt; 10. And that does not make sense.

I would say for operations like 

@@@ ruby
Article.scoped.limit(10).offset(5).size   # zero (incorrect)
Article.scoped.limit(10).offset(5).empty? # true (incorrect)
@@@

ActiveRecord should blow up saying that use .length instead.</body>
      <body-html>&lt;div&gt;&lt;p&gt;The problem with dropping limit is that I can have a condition
like&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;Article.scoped.limit(10).offset(5).size&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;and the output could be a number &amp;gt; 10. And that does not make
sense.&lt;/p&gt;
&lt;p&gt;I would say for operations like&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;ruby&quot;&gt;Article.scoped.limit(10).offset(5).size   # zero (incorrect)
Article.scoped.limit(10).offset(5).empty? # true (incorrect)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ActiveRecord should blow up saying that use .length instead.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T02:39:19+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: 
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T02:39:20+01:00</updated-at>
      <user-id type="integer">40263</user-id>
      <version type="integer">6</version>
      <user-name>Neeraj Singh</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Earlier you said you wanted it to be efficient and use a `COUNT` query if possible, but if you tell users to use `length` (which under the hood does `to_a` first) you're forcing the immediate execution of a non-`COUNT` query at that moment.

Isn't it a reasonable expectation for a user to be able to do:

@@@
Model.some_active_record_relation_query.empty?
@@@

And get a boolean that says if any results are returned or not? And that this should be done via a `COUNT` rather than actually retrieving the records and counting them?

So what I am saying is given the example you cite:

@@@
Article.scoped.limit(10).offset(5).size
@@@

ActiveRecord should drop the `LIMIT` clause from the actual `COUNT` query (seeing as that would cause us to always return 0), and then when returning the results, compare the returned number to the values passed in via `limit` and/or `offset`.

ie. if the query that would be sent to the database is:

@@@
SELECT COUNT(*) FROM `articles` LIMIT 5, 10
@@@

the actual query should be:

@@@
SELECT COUNT(*) FROM `articles`
@@@

and if the result is say, 38, ActiveRecord knows that the limit requested by the user was 10, so it should return 10 (ie. the number of rows that would be returned by executing the actual retrieval query).

What do you think?</body>
      <body-html>&lt;div&gt;&lt;p&gt;Earlier you said you wanted it to be efficient and use a
&lt;code&gt;COUNT&lt;/code&gt; query if possible, but if you tell users to use
&lt;code&gt;length&lt;/code&gt; (which under the hood does &lt;code&gt;to_a&lt;/code&gt;
first) you're forcing the immediate execution of a
non-&lt;code&gt;COUNT&lt;/code&gt; query at that moment.&lt;/p&gt;
&lt;p&gt;Isn't it a reasonable expectation for a user to be able to
do:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Model.some_active_record_relation_query.empty?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;And get a boolean that says if any results are returned or not?
And that this should be done via a &lt;code&gt;COUNT&lt;/code&gt; rather than
actually retrieving the records and counting them?&lt;/p&gt;
&lt;p&gt;So what I am saying is given the example you cite:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Article.scoped.limit(10).offset(5).size&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ActiveRecord should drop the &lt;code&gt;LIMIT&lt;/code&gt; clause from the
actual &lt;code&gt;COUNT&lt;/code&gt; query (seeing as that would cause us to
always return 0), and then when returning the results, compare the
returned number to the values passed in via &lt;code&gt;limit&lt;/code&gt;
and/or &lt;code&gt;offset&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;ie. if the query that would be sent to the database is:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(*) FROM `articles` LIMIT 5, 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;the actual query should be:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(*) FROM `articles`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;and if the result is say, 38, ActiveRecord knows that the limit
requested by the user was 10, so it should return 10 (ie. the
number of rows that would be returned by executing the actual
retrieval query).&lt;/p&gt;
&lt;p&gt;What do you think?&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T06:41:57+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T06:41:59+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">7</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>This will fix #empty? but what about #size? How would you get accurate result for #size?</body>
      <body-html>&lt;div&gt;&lt;p&gt;This will fix #empty? but what about #size? How would you get
accurate result for #size?&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T12:28:31+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T12:28:32+01:00</updated-at>
      <user-id type="integer">40263</user-id>
      <version type="integer">8</version>
      <user-name>Neeraj Singh</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Well, that depends on what you define as accurate. Does &quot;accurate&quot; mean the total number of records that match the `WHERE` condition, or the total number that would be returned if you did the query with a `LIMIT` applied to the `WHERE`? I imagine that either behavior can be implemented; it's just we need to decide which is the correct one to proceed with. The same technique (stripping the `LIMIT` and then comparing it to the result before returning) would work, if that's what we decide to do.

The way I see it is this:

If the user writes a broken SQL query like:

@@@
SELECT COUNT(*) FROM `articles` LIMIT 10, 10
@@@

Then the database will give them a broken answer (ie. always zero rows returned). It seems like the right thing to do: a broken query should give a broken answer.

So, if the user uses ActiveRecord::Relation to recreate that same broken query:

@@@
Article.limit(10).offset(10).count
@@@

Then perhaps they should get a broken answer back too, for consistency with the analogous case written in raw SQL. Although the `count` method _is_ defined on `Array`, in this case it happens to be an SQL keyword too, so it doesn't seem too unreasonable to give it this kind of SQL-centric interpretation when called on an ActiveRecord::Relation instance.

On the other hand, we tell users that ActiveRecord::Relation objects are basically supposed to be Array-like. You get lazy-evaluation for free, and when you actually try to iterate over the objects with `each` or `for` or whatever the actual query gets evaluated.

So, if the user has a controller like this:

@@@
@articles = Article.find :all, :limit =&gt; 10, :offset =&gt; 10
@@@

And a view like this:

@@@
&lt;%- unless @articles.empty? %&gt;
  &lt;h1&gt;Articles...&lt;/h1&gt;
@@@

Then they would expect that changing their controller to:

@@@
@articles = Article.limit(10).offset(10)
@@@

Would continue to provide them with an Array-like object that they can use in their view in exactly the same way.

If they call `length` on it it behaves in an unsurprising way, because `to_a` is getting called behind the scenes. No lazy evaluation, and no SQL `COUNT` query either.

If they call `count` on it they might be surprised to get a broken answer back, but as I mentioned above, there is a case for this being the right thing to do, seeing as a similar `COUNT` query written in raw SQL would give them the same broken answer.

If they call `size` on it they do get the surprising behavior, because it shares the behavior of `count`. I'm inclined to think that it probably shouldn't. The fix is either to call `to_a` just like we do with `length`, or do the special handling of the `LIMIT` clause already described. Which one you choose probably depends on whether you want a `COUNT` query implemented behind the scenes or not.

If they call `empty?` they also get the surprising answer. There is no `EMPTY` keyword in SQL, but there evidently is an `empty?` method on Array, so it is reasonable for the user to expect Array-like semantics. Again there are two possible fixes: either drop the `LIMIT` clause, or do a `to_a` first.

If you think about the most common use case for `empty?` I'd say that preferring to do a `COUNT` query probably isn't right. ie. it is usually used like this:

@@@
# in controller
@models = ... # model query

#&#160;in view
&lt;%- if @models.empty? %&gt;
  &lt;h1&gt;Models!&lt;/h1&gt;
  &lt;%- @models.each |m| %&gt;
    # do something with the models...
@@@

So in this case preferring a `COUNT` query gives a false sense of economy because you end up doing a `COUNT` and if it succeeds you repeat the query, this time as a normal `SELECT`.

If you forget about the `COUNT` query and just do a `to_a`, you do only one query, and if no rows are returned (ie. when `empty?` is `true`) you haven't wasted time doing a heavyweight query because you got nothing back anyway.

I guess it is important to get this right, as queries of this time (with `LIMIT` and offset components) are extremely common in web applications, due to the ubiquity of pagination. At least for me what we should do with the `empty?` method is clear, and `length` already works; what I am not sure about is what we should do with `size`.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Well, that depends on what you define as accurate. Does
&quot;accurate&quot; mean the total number of records that match the
&lt;code&gt;WHERE&lt;/code&gt; condition, or the total number that would be
returned if you did the query with a &lt;code&gt;LIMIT&lt;/code&gt; applied to
the &lt;code&gt;WHERE&lt;/code&gt;? I imagine that either behavior can be
implemented; it's just we need to decide which is the correct one
to proceed with. The same technique (stripping the
&lt;code&gt;LIMIT&lt;/code&gt; and then comparing it to the result before
returning) would work, if that's what we decide to do.&lt;/p&gt;
&lt;p&gt;The way I see it is this:&lt;/p&gt;
&lt;p&gt;If the user writes a broken SQL query like:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(*) FROM `articles` LIMIT 10, 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Then the database will give them a broken answer (ie. always
zero rows returned). It seems like the right thing to do: a broken
query should give a broken answer.&lt;/p&gt;
&lt;p&gt;So, if the user uses ActiveRecord::Relation to recreate that
same broken query:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Article.limit(10).offset(10).count&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Then perhaps they should get a broken answer back too, for
consistency with the analogous case written in raw SQL. Although
the &lt;code&gt;count&lt;/code&gt; method &lt;em&gt;is&lt;/em&gt; defined on
&lt;code&gt;Array&lt;/code&gt;, in this case it happens to be an SQL keyword
too, so it doesn't seem too unreasonable to give it this kind of
SQL-centric interpretation when called on an ActiveRecord::Relation
instance.&lt;/p&gt;
&lt;p&gt;On the other hand, we tell users that ActiveRecord::Relation
objects are basically supposed to be Array-like. You get
lazy-evaluation for free, and when you actually try to iterate over
the objects with &lt;code&gt;each&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; or whatever
the actual query gets evaluated.&lt;/p&gt;
&lt;p&gt;So, if the user has a controller like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@articles = Article.find :all, :limit =&amp;gt; 10, :offset =&amp;gt; 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;And a view like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%- unless @articles.empty? %&amp;gt;
  &amp;lt;h1&amp;gt;Articles...&amp;lt;/h1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Then they would expect that changing their controller to:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@articles = Article.limit(10).offset(10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Would continue to provide them with an Array-like object that
they can use in their view in exactly the same way.&lt;/p&gt;
&lt;p&gt;If they call &lt;code&gt;length&lt;/code&gt; on it it behaves in an
unsurprising way, because &lt;code&gt;to_a&lt;/code&gt; is getting called
behind the scenes. No lazy evaluation, and no SQL
&lt;code&gt;COUNT&lt;/code&gt; query either.&lt;/p&gt;
&lt;p&gt;If they call &lt;code&gt;count&lt;/code&gt; on it they might be surprised to
get a broken answer back, but as I mentioned above, there is a case
for this being the right thing to do, seeing as a similar
&lt;code&gt;COUNT&lt;/code&gt; query written in raw SQL would give them the
same broken answer.&lt;/p&gt;
&lt;p&gt;If they call &lt;code&gt;size&lt;/code&gt; on it they do get the surprising
behavior, because it shares the behavior of &lt;code&gt;count&lt;/code&gt;. I'm
inclined to think that it probably shouldn't. The fix is either to
call &lt;code&gt;to_a&lt;/code&gt; just like we do with &lt;code&gt;length&lt;/code&gt;, or
do the special handling of the &lt;code&gt;LIMIT&lt;/code&gt; clause already
described. Which one you choose probably depends on whether you
want a &lt;code&gt;COUNT&lt;/code&gt; query implemented behind the scenes or
not.&lt;/p&gt;
&lt;p&gt;If they call &lt;code&gt;empty?&lt;/code&gt; they also get the surprising
answer. There is no &lt;code&gt;EMPTY&lt;/code&gt; keyword in SQL, but there
evidently is an &lt;code&gt;empty?&lt;/code&gt; method on Array, so it is
reasonable for the user to expect Array-like semantics. Again there
are two possible fixes: either drop the &lt;code&gt;LIMIT&lt;/code&gt; clause,
or do a &lt;code&gt;to_a&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;If you think about the most common use case for
&lt;code&gt;empty?&lt;/code&gt; I'd say that preferring to do a
&lt;code&gt;COUNT&lt;/code&gt; query probably isn't right. ie. it is usually
used like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# in controller
@models = ... # model query

# in view
&amp;lt;%- if @models.empty? %&amp;gt;
  &amp;lt;h1&amp;gt;Models!&amp;lt;/h1&amp;gt;
  &amp;lt;%- @models.each |m| %&amp;gt;
    # do something with the models...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;So in this case preferring a &lt;code&gt;COUNT&lt;/code&gt; query gives a
false sense of economy because you end up doing a
&lt;code&gt;COUNT&lt;/code&gt; and if it succeeds you repeat the query, this
time as a normal &lt;code&gt;SELECT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you forget about the &lt;code&gt;COUNT&lt;/code&gt; query and just do a
&lt;code&gt;to_a&lt;/code&gt;, you do only one query, and if no rows are
returned (ie. when &lt;code&gt;empty?&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;) you
haven't wasted time doing a heavyweight query because you got
nothing back anyway.&lt;/p&gt;
&lt;p&gt;I guess it is important to get this right, as queries of this
time (with &lt;code&gt;LIMIT&lt;/code&gt; and offset components) are extremely
common in web applications, due to the ubiquity of pagination. At
least for me what we should do with the &lt;code&gt;empty?&lt;/code&gt; method
is clear, and &lt;code&gt;length&lt;/code&gt; already works; what I am not sure
about is what we should do with &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T14:06:15+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T14:06:16+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">9</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>not sure if all the databases sqlite3, mysql, postgresql and oracle produce IMIT 10, 10 in the end.

Given the hard work that needs to go in and given that it will only solve .empty but not .size I would still say ( a bit reluctantly though) that it is better to blow up than silently provide wrong result. :-(</body>
      <body-html>&lt;div&gt;&lt;p&gt;not sure if all the databases sqlite3, mysql, postgresql and
oracle produce IMIT 10, 10 in the end.&lt;/p&gt;
&lt;p&gt;Given the hard work that needs to go in and given that it will
only solve .empty but not .size I would still say ( a bit
reluctantly though) that it is better to blow up than silently
provide wrong result. :-(&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T17:05:29+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T17:05:30+01:00</updated-at>
      <user-id type="integer">40263</user-id>
      <version type="integer">10</version>
      <user-name>Neeraj Singh</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Not sure what you mean about it not solving the `size` case. It would:

- drop `LIMIT` clause
- do query
- if result is &gt; limit value, return limit value
- otherwise, return result obtained via query

ie.

- if 42 rows counted without limit clause, and user passed in limit of 10, the result would be 10
- if 4 rows counted without limit clause, and user passed in limit of 10, the result would be 4

But as I noted above, I have no idea whether this is more correct than the existing behavior of returning 0. In a way, I like the existing behavior in the sense that it matches up with what you would get if you wrote an SQL `COUNT` query with a `LIMIT` and offset. (Definitely for the `count` method, although not so sure about `size`, although I seem to recall that `size` has always mapped to `count` and therefore `COUNT`in Rails, and `length` as always had &quot;Array semantics&quot;.) I also don't really like the complexity here of both stripping something off before submitting the query, and also intercepting the result and potentially modifying it.

In any case, don't think blowing up is a good idea at all. The database doesn't complain about invalid SQL if you do something ill-advised like `SELECT COUNT(*) FROM thing LIMIT 10, 10`, so Rails shouldn't really be throwing an exception either. It's not invalid, it's just not what the user might think it is.

It would be better to just leave things as they are and have users scratching their heads about unexpected results when they do `empty?`. (Although I would rather fix it, to be honest.)

As for the difficulty of the fix and the question about different database adapters, I think I can see that there is already code in `activerecord/lib/active_record/relation/calculations.rb` that drops clauses off of queries before firing them.

If we just want to unbreak `empty?` the fix could be as minimal as removing:

@@@
    def empty?
      loaded? ? @records.empty? : count.zero?
    end
@@@

from `activerecord/lib/active_record/relation.rb` and adding `empty?` to its list of delegated methods; ie:

@@@
delegate :to_xml, :to_yaml, :length, :collect, :map, :each, :empty?, :all?, :include?, :to =&gt; :to_a
@@@

Personally that's what I'd do at a minimum. I would probably leave the rest as is, and address the other possible surprises in the documentation by making it clear that:

- `length` is equivalent to `to_a.length`, so causes the query to be executed immediately
- `size` maps to `count`
- `count` will do an SQL `COUNT` query if the relation is not yet loaded
- `empty?` is equivalent to `to_a.empty?`, so again causes the query to be executed immediately
- mixing `size` or `count` with `limit()` and `offset()` will always produce 0 counts for any non-zero offset, because the `LIMIT` clause effectively removes the row containing the `COUNT` from the result

What do you think?</body>
      <body-html>&lt;div&gt;&lt;p&gt;Not sure what you mean about it not solving the
&lt;code&gt;size&lt;/code&gt; case. It would:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drop &lt;code&gt;LIMIT&lt;/code&gt; clause&lt;/li&gt;
&lt;li&gt;do query&lt;/li&gt;
&lt;li&gt;if result is &amp;gt; limit value, return limit value&lt;/li&gt;
&lt;li&gt;otherwise, return result obtained via query&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ie.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if 42 rows counted without limit clause, and user passed in
limit of 10, the result would be 10&lt;/li&gt;
&lt;li&gt;if 4 rows counted without limit clause, and user passed in
limit of 10, the result would be 4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But as I noted above, I have no idea whether this is more
correct than the existing behavior of returning 0. In a way, I like
the existing behavior in the sense that it matches up with what you
would get if you wrote an SQL &lt;code&gt;COUNT&lt;/code&gt; query with a
&lt;code&gt;LIMIT&lt;/code&gt; and offset. (Definitely for the
&lt;code&gt;count&lt;/code&gt; method, although not so sure about
&lt;code&gt;size&lt;/code&gt;, although I seem to recall that &lt;code&gt;size&lt;/code&gt;
has always mapped to &lt;code&gt;count&lt;/code&gt; and therefore
&lt;code&gt;COUNT&lt;/code&gt;in Rails, and &lt;code&gt;length&lt;/code&gt; as always had
&quot;Array semantics&quot;.) I also don't really like the complexity here of
both stripping something off before submitting the query, and also
intercepting the result and potentially modifying it.&lt;/p&gt;
&lt;p&gt;In any case, don't think blowing up is a good idea at all. The
database doesn't complain about invalid SQL if you do something
ill-advised like &lt;code&gt;SELECT COUNT(*) FROM thing LIMIT 10,
10&lt;/code&gt;, so Rails shouldn't really be throwing an exception
either. It's not invalid, it's just not what the user might think
it is.&lt;/p&gt;
&lt;p&gt;It would be better to just leave things as they are and have
users scratching their heads about unexpected results when they do
&lt;code&gt;empty?&lt;/code&gt;. (Although I would rather fix it, to be
honest.)&lt;/p&gt;
&lt;p&gt;As for the difficulty of the fix and the question about
different database adapters, I think I can see that there is
already code in
&lt;code&gt;activerecord/lib/active_record/relation/calculations.rb&lt;/code&gt;
that drops clauses off of queries before firing them.&lt;/p&gt;
&lt;p&gt;If we just want to unbreak &lt;code&gt;empty?&lt;/code&gt; the fix could be
as minimal as removing:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def empty?
      loaded? ? @records.empty? : count.zero?
    end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;from &lt;code&gt;activerecord/lib/active_record/relation.rb&lt;/code&gt; and
adding &lt;code&gt;empty?&lt;/code&gt; to its list of delegated methods;
ie:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delegate :to_xml, :to_yaml, :length, :collect, :map, :each, :empty?, :all?, :include?, :to =&amp;gt; :to_a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Personally that's what I'd do at a minimum. I would probably
leave the rest as is, and address the other possible surprises in
the documentation by making it clear that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;length&lt;/code&gt; is equivalent to &lt;code&gt;to_a.length&lt;/code&gt;,
so causes the query to be executed immediately&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt; maps to &lt;code&gt;count&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt; will do an SQL &lt;code&gt;COUNT&lt;/code&gt; query if
the relation is not yet loaded&lt;/li&gt;
&lt;li&gt;&lt;code&gt;empty?&lt;/code&gt; is equivalent to &lt;code&gt;to_a.empty?&lt;/code&gt;,
so again causes the query to be executed immediately&lt;/li&gt;
&lt;li&gt;mixing &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; with
&lt;code&gt;limit()&lt;/code&gt; and &lt;code&gt;offset()&lt;/code&gt; will always produce
0 counts for any non-zero offset, because the &lt;code&gt;LIMIT&lt;/code&gt;
clause effectively removes the row containing the
&lt;code&gt;COUNT&lt;/code&gt; from the result&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What do you think?&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T17:32:16+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T17:32:18+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">11</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>The intent of the author here is to find how many records are there after the offset limiting upto 10. By dropping the LIMIT clause that information is lost.

@@@ ruby
Article.limit(10).offset(10).size? 
@@@ 

Second look at the query above makes me think it is a meaningless request; valid but meaningless. What the user wants here is confusing because of the usage of both size and offset and limit?</body>
      <body-html>&lt;div&gt;&lt;p&gt;The intent of the author here is to find how many records are
there after the offset limiting upto 10. By dropping the LIMIT
clause that information is lost.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;Article.limit(10).offset(10).size?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Second look at the query above makes me think it is a
meaningless request; valid but meaningless. What the user wants
here is confusing because of the usage of both size and offset and
limit?&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T17:39:37+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T17:39:41+01:00</updated-at>
      <user-id type="integer">40263</user-id>
      <version type="integer">12</version>
      <user-name>Neeraj Singh</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>This scenario comes up all the time with pagination. Your example:

@@@
@articles = Article.limit(10).offset(10)
@@@

That's 10 articles per page, in groups of 10, starting at offset 10 (ie. second page). Isn't it perfectly reasonable to want to know how many articles are in `@articles`? Or to know if there are any results to be rendered (eg. `not empty?`).

So yes, the author does want to know how many records there are after offset 10, up to a limit of 10, but you're wrong when you say that dropping the `LIMIT` clause loses that information. If you _don't_ drop the `LIMIT` clause then Rails will issue a query like `SELECT COUNT(*) FROM articles LIMIT 10, 10` and the result will be 0, no matter how many rows in the table. This is because a `COUNT` query always returns 1 row, a row containing the count, and if you use a `LIMIT` with an offset component, you throw the result away.

The only way to get an accurate answer is to either:

- actually retrieve the records and then count them (ie. `to_a.count`, `to_a.size`, `to_a.length`)
- or exclude the `LIMIT` clause from the query and then return `MAX(result, limit)` to the user

See what I'm saying?

You're right though that it looks confusing if a user writes a query like `Article.limit(10).offset(10).size`. But in practice users won't do that. This issue is going to crop up because a user will take a query from a Rails 2 app:

@@@
# in controller
@articles = Article.find :all, :limit =&gt; 10, :offset =&gt; 10

# in view
if @articles.empty? # or similar...
@@@

And convert it to use the new API:

@@@
# in controller
@articles = Article.limit(10).offset(10)

# in view
if @articles.empty?
@@@

And wonder why it's not displaying any records all of a sudden.</body>
      <body-html>&lt;div&gt;&lt;p&gt;This scenario comes up all the time with pagination. Your
example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@articles = Article.limit(10).offset(10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;That's 10 articles per page, in groups of 10, starting at offset
10 (ie. second page). Isn't it perfectly reasonable to want to know
how many articles are in &lt;code&gt;@articles&lt;/code&gt;? Or to know if
there are any results to be rendered (eg. &lt;code&gt;not
empty?&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;So yes, the author does want to know how many records there are
after offset 10, up to a limit of 10, but you're wrong when you say
that dropping the &lt;code&gt;LIMIT&lt;/code&gt; clause loses that information.
If you &lt;em&gt;don't&lt;/em&gt; drop the &lt;code&gt;LIMIT&lt;/code&gt; clause then Rails
will issue a query like &lt;code&gt;SELECT COUNT(*) FROM articles LIMIT
10, 10&lt;/code&gt; and the result will be 0, no matter how many rows in
the table. This is because a &lt;code&gt;COUNT&lt;/code&gt; query always
returns 1 row, a row containing the count, and if you use a
&lt;code&gt;LIMIT&lt;/code&gt; with an offset component, you throw the result
away.&lt;/p&gt;
&lt;p&gt;The only way to get an accurate answer is to either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;actually retrieve the records and then count them (ie.
&lt;code&gt;to_a.count&lt;/code&gt;, &lt;code&gt;to_a.size&lt;/code&gt;,
&lt;code&gt;to_a.length&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;or exclude the &lt;code&gt;LIMIT&lt;/code&gt; clause from the query and
then return &lt;code&gt;MAX(result, limit)&lt;/code&gt; to the user&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See what I'm saying?&lt;/p&gt;
&lt;p&gt;You're right though that it looks confusing if a user writes a
query like &lt;code&gt;Article.limit(10).offset(10).size&lt;/code&gt;. But in
practice users won't do that. This issue is going to crop up
because a user will take a query from a Rails 2 app:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# in controller
@articles = Article.find :all, :limit =&amp;gt; 10, :offset =&amp;gt; 10

# in view
if @articles.empty? # or similar...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;And convert it to use the new API:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# in controller
@articles = Article.limit(10).offset(10)

# in view
if @articles.empty?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;And wonder why it's not displaying any records all of a
sudden.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-07-16T17:51:49+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-07-16T17:51:52+01:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">13</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>For what it's worth, I've been following/fighting this issue for a while and I agree with Wincent: the OFFSET clause needs to be conditionally stripped from scoped queries.

This is meaningless in the DBs I'm familiar with:

  SELECT COUNT(*) FROM widgets LIMIT 10 OFFSET 10 

It always returns zero.  The *only* time I see value in including the OFFSET clause in a COUNT is when results are aggregated and grouped -but that's already outside the AR sweet spot.

My experience matches Wincent's: pagination code applies LIMIT/OFFSET in a scope (very useful), but counting is then screwed up.  So if my pagination page size is 10 and I need to count how many records are being shown (perhaps I do something radically different for count == 1 versus count &gt; 1), things get ugly quickly.  And stripping the LIMIT during DB counts seems like a painless solution.

Anybody know the status of this?

-Chris</body>
      <body-html>&lt;div&gt;&lt;p&gt;For what it's worth, I've been following/fighting this issue for
a while and I agree with Wincent: the OFFSET clause needs to be
conditionally stripped from scoped queries.&lt;/p&gt;
&lt;p&gt;This is meaningless in the DBs I'm familiar with:&lt;/p&gt;
&lt;p&gt;SELECT COUNT(*) FROM widgets LIMIT 10 OFFSET 10&lt;/p&gt;
&lt;p&gt;It always returns zero. The &lt;em&gt;only&lt;/em&gt; time I see value in
including the OFFSET clause in a COUNT is when results are
aggregated and grouped -but that's already outside the AR sweet
spot.&lt;/p&gt;
&lt;p&gt;My experience matches Wincent's: pagination code applies
LIMIT/OFFSET in a scope (very useful), but counting is then screwed
up. So if my pagination page size is 10 and I need to count how
many records are being shown (perhaps I do something radically
different for count == 1 versus count &amp;gt; 1), things get ugly
quickly. And stripping the LIMIT during DB counts seems like a
painless solution.&lt;/p&gt;
&lt;p&gt;Anybody know the status of this?&lt;/p&gt;
&lt;p&gt;-Chris&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-09-13T20:39:44+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-09-13T20:39:48+01:00</updated-at>
      <user-id type="integer">17461</user-id>
      <version type="integer">14</version>
      <user-name>Chris Hapgood</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-09-13T20:40:34+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: activerecord
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2010-09-13T20:40:36+01:00</updated-at>
      <user-id type="integer">17461</user-id>
      <version type="integer">15</version>
      <user-name>Chris Hapgood</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>This issue has been automatically marked as stale because it has not been commented on for at least three months.

The resources of the Rails core team are limited, and so we are asking for your help. If you can still reproduce this error on the 3-0-stable branch or on master, please reply with all of the information you have about it and add &quot;[state:open]&quot; to your comment. This will reopen the ticket for review. Likewise, if you feel that this is a very important feature for Rails to include, please reply with your explanation so we can consider it.

Thank you for all your contributions, and we hope you will understand this step to focus our efforts where they are most helpful.</body>
      <body-html>&lt;div&gt;&lt;p&gt;This issue has been automatically marked as stale because it has
not been commented on for at least three months.&lt;/p&gt;
&lt;p&gt;The resources of the Rails core team are limited, and so we are
asking for your help. If you can still reproduce this error on the
3-0-stable branch or on master, please reply with all of the
information you have about it and add &quot;[state:open]&quot; to your
comment. This will reopen the ticket for review. Likewise, if you
feel that this is a very important feature for Rails to include,
please reply with your explanation so we can consider it.&lt;/p&gt;
&lt;p&gt;Thank you for all your contributions, and we hope you will
understand this step to focus our efforts where they are most
helpful.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-02T16:31:38+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-02T16:50:08+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">16</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body nil="true"></body>
      <body-html nil="true"></body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-02-02T16:31:40+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:state: open
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>stale</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-02T16:51:02+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">17</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Just checked and the problematic behavior is still there in Rails 3.0.4.rc1, so [state:open]</body>
      <body-html>&lt;div&gt;&lt;p&gt;Just checked and the problematic behavior is still there in
Rails 3.0.4.rc1, so [state:open]&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-02T19:01:35+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:state: stale
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-02T20:09:16+00:00</updated-at>
      <user-id type="integer">12845</user-id>
      <version type="integer">18</version>
      <user-name>Wincent Colaiuta</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-02T20:30:27+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:milestone: 
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-02T20:43:47+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">19</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>[[bulk edit](/projects/8994/bulk_edits/42275)]</body>
      <body-html>&lt;div&gt;&lt;p&gt;[&lt;a href=&quot;/projects/8994/bulk_edits/42275&quot;&gt;bulk edit&lt;/a&gt;]&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-12T21:58:22+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:milestone: 92071
</diffable-attributes>
      <milestone-id type="integer">101623</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-12T21:58:22+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">20</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.0.5</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>This issue caught my attention so I wrote a little patch for it. This is my first attempt at Rails hacking so hopefully it's up to standards. I've also included test cases to verify that it works. All activerecord tests passed for SQLite, Postgres and Mysql. Thanks for taking a look!</body>
      <body-html>&lt;div&gt;&lt;p&gt;This issue caught my attention so I wrote a little patch for it.
This is my first attempt at Rails hacking so hopefully it's up to
standards. I've also included test cases to verify that it works.
All activerecord tests passed for SQLite, Postgres and Mysql.
Thanks for taking a look!&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-13T02:55:07+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">101623</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-13T02:55:18+00:00</updated-at>
      <user-id type="integer">136805</user-id>
      <version type="integer">21</version>
      <user-name>atrofast</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.0.5</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>[[bulk edit](/projects/8994/bulk_edits/43692)]</body>
      <body-html>&lt;div&gt;&lt;p&gt;[&lt;a href=&quot;/projects/8994/bulk_edits/43692&quot;&gt;bulk edit&lt;/a&gt;]&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-27T03:15:39+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:milestone: 101623
</diffable-attributes>
      <milestone-id type="integer">103410</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-02-27T03:15:39+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">22</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.0.6</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Hello,

I attempted to submit a patch here but got shut down by Lighthouse's spam guards.  I tried submitting as a pull request instead:

https://github.com/rails/rails/pull/201

Also pertains to #6268.

Thanks!

-john</body>
      <body-html>&lt;div&gt;&lt;p&gt;Hello,&lt;/p&gt;
&lt;p&gt;I attempted to submit a patch here but got shut down by
Lighthouse's spam guards. I tried submitting as a pull request
instead:&lt;/p&gt;
&lt;p&gt;&lt;a href=
&quot;https://github.com/rails/rails/pull/201&quot;&gt;https://github.com/rails/rails/pull/201&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Also pertains to &lt;a href=&quot;/projects/8994/tickets/6268&quot; title=
&quot;Ticket #6268&quot;&gt;#6268&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks!&lt;/p&gt;
&lt;p&gt;-john&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-03-04T05:04:13+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">103410</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-03-04T05:04:25+00:00</updated-at>
      <user-id type="integer">139717</user-id>
      <version type="integer">23</version>
      <user-name>John Mileham</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.0.6</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-03-04T14:31:24+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:assigned_user: 
</diffable-attributes>
      <milestone-id type="integer">103410</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-03-04T14:31:35+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">24</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.0.6</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I'm liking John's ideas, but his changes should not go in a bugfix release.  So I'm moving to 3.x.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I'm liking John's ideas, but his changes should not go in a
bugfix release. So I'm moving to 3.x.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-03-23T22:06:05+00:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:milestone: 103410
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-03-23T22:06:22+00:00</updated-at>
      <user-id type="integer">15316</user-id>
      <version type="integer">25</version>
      <user-name>Aaron Patterson</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.x</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I've merged John's stuff to master, so I'm closing this.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I've merged John's stuff to master, so I'm closing this.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-03-30T17:55:03+01:00</created-at>
      <creator-id type="integer">12845</creator-id>
      <diffable-attributes type="yaml">--- 
:state: open
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">5060</number>
      <permalink>activerelation-offsetempty-produces-unexpected-result</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>committed</state>
      <tag>activerecord scope</tag>
      <title>ActiveRelation &quot;offset().empty?&quot; produces unexpected result</title>
      <updated-at type="datetime">2011-03-30T17:55:18+01:00</updated-at>
      <user-id type="integer">15316</user-id>
      <version type="integer">26</version>
      <user-name>Aaron Patterson</user-name>
      <creator-name>Wincent Colaiuta</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5060</url>
      <milestone-title>3.x</milestone-title>
      <priority-name>Low</priority-name>
    </version>
  </versions>
  <attachments type="array">
    <attachment type="Attachment">
      <code>0de23168a1bbb39c2b9c31db64146167f65c4a89</code>
      <content-type>text/plain</content-type>
      <created-at type="datetime">2011-02-13T02:55:07+00:00</created-at>
      <filename>limit_offset_count_fix.diff</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">909820</id>
      <size type="integer">3291</size>
      <uploader-id type="integer">136805</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/909820/limit_offset_count_fix.diff</url>
    </attachment>
  </attachments>
</ticket>
