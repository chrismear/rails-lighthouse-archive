From 97cbafb4c71542ebde494869d93ee3ed79f71ffe Mon Sep 17 00:00:00 2001
From: Brian Underwood <bunderwood@rbmtechnologies.com>
Date: Thu, 9 Dec 2010 15:31:23 -0500
Subject: [PATCH 1/2] Namespacing the Fixtures and Fixture classes under the ActiveRecord module

---
 activerecord/lib/active_record/fixtures.rb         |  564 ++++++++++----------
 .../lib/active_record/railties/databases.rake      |    6 +-
 .../cases/adapters/mysql/reserved_word_test.rb     |    2 +-
 .../cases/adapters/mysql2/reserved_word_test.rb    |    2 +-
 activerecord/test/cases/fixtures_test.rb           |   40 +-
 activerecord/test/cases/helper.rb                  |    2 +-
 activerecord/test/fixtures/mateys.yml              |    4 +-
 activerecord/test/fixtures/parrots_pirates.yml     |    8 +-
 8 files changed, 314 insertions(+), 314 deletions(-)

diff --git a/activerecord/lib/active_record/fixtures.rb b/activerecord/lib/active_record/fixtures.rb
index 6fb723f..a4c0913 100644
--- a/activerecord/lib/active_record/fixtures.rb
+++ b/activerecord/lib/active_record/fixtures.rb
@@ -446,378 +446,378 @@ class FixturesFileNotFound < StandardError; end
 #
 # Any fixture labeled "DEFAULTS" is safely ignored.
 
-class Fixtures < (RUBY_VERSION < '1.9' ? YAML::Omap : Hash)
-  MAX_ID = 2 ** 30 - 1
-  DEFAULT_FILTER_RE = /\.ya?ml$/
+module ActiveRecord
+  class Fixtures < (RUBY_VERSION < '1.9' ? YAML::Omap : Hash)
+    MAX_ID = 2 ** 30 - 1
+    DEFAULT_FILTER_RE = /\.ya?ml$/
 
-  @@all_cached_fixtures = {}
+    @@all_cached_fixtures = {}
 
-  def self.reset_cache(connection = nil)
-    connection ||= ActiveRecord::Base.connection
-    @@all_cached_fixtures[connection.object_id] = {}
-  end
+    def self.reset_cache(connection = nil)
+      connection ||= ActiveRecord::Base.connection
+      @@all_cached_fixtures[connection.object_id] = {}
+    end
 
-  def self.cache_for_connection(connection)
-    @@all_cached_fixtures[connection.object_id] ||= {}
-    @@all_cached_fixtures[connection.object_id]
-  end
+    def self.cache_for_connection(connection)
+      @@all_cached_fixtures[connection.object_id] ||= {}
+      @@all_cached_fixtures[connection.object_id]
+    end
 
-  def self.fixture_is_cached?(connection, table_name)
-    cache_for_connection(connection)[table_name]
-  end
+    def self.fixture_is_cached?(connection, table_name)
+      cache_for_connection(connection)[table_name]
+    end
 
-  def self.cached_fixtures(connection, keys_to_fetch = nil)
-    if keys_to_fetch
-      fixtures = cache_for_connection(connection).values_at(*keys_to_fetch)
-    else
-      fixtures = cache_for_connection(connection).values
+    def self.cached_fixtures(connection, keys_to_fetch = nil)
+      if keys_to_fetch
+        fixtures = cache_for_connection(connection).values_at(*keys_to_fetch)
+      else
+        fixtures = cache_for_connection(connection).values
+      end
+      fixtures.size > 1 ? fixtures : fixtures.first
     end
-    fixtures.size > 1 ? fixtures : fixtures.first
-  end
 
-  def self.cache_fixtures(connection, fixtures_map)
-    cache_for_connection(connection).update(fixtures_map)
-  end
+    def self.cache_fixtures(connection, fixtures_map)
+      cache_for_connection(connection).update(fixtures_map)
+    end
 
-  def self.instantiate_fixtures(object, table_name, fixtures, load_instances = true)
-    object.instance_variable_set "@#{table_name.to_s.gsub('.','_')}", fixtures
-    if load_instances
-      ActiveRecord::Base.silence do
-        fixtures.each do |name, fixture|
-          begin
-            object.instance_variable_set "@#{name}", fixture.find
-          rescue FixtureClassNotFound
-            nil
+    def self.instantiate_fixtures(object, table_name, fixtures, load_instances = true)
+      object.instance_variable_set "@#{table_name.to_s.gsub('.','_')}", fixtures
+      if load_instances
+        ActiveRecord::Base.silence do
+          fixtures.each do |name, fixture|
+            begin
+              object.instance_variable_set "@#{name}", fixture.find
+            rescue FixtureClassNotFound
+              nil
+            end
           end
         end
       end
     end
-  end
 
-  def self.instantiate_all_loaded_fixtures(object, load_instances = true)
-    all_loaded_fixtures.each do |table_name, fixtures|
-      Fixtures.instantiate_fixtures(object, table_name, fixtures, load_instances)
+    def self.instantiate_all_loaded_fixtures(object, load_instances = true)
+      all_loaded_fixtures.each do |table_name, fixtures|
+        Fixtures.instantiate_fixtures(object, table_name, fixtures, load_instances)
+      end
     end
-  end
 
-  cattr_accessor :all_loaded_fixtures
-  self.all_loaded_fixtures = {}
+    cattr_accessor :all_loaded_fixtures
+    self.all_loaded_fixtures = {}
 
-  def self.create_fixtures(fixtures_directory, table_names, class_names = {})
-    table_names = [table_names].flatten.map { |n| n.to_s }
-    table_names.each { |n| class_names[n.tr('/', '_').to_sym] = n.classify if n.include?('/') }
-    connection  = block_given? ? yield : ActiveRecord::Base.connection
+    def self.create_fixtures(fixtures_directory, table_names, class_names = {})
+      table_names = [table_names].flatten.map { |n| n.to_s }
+      table_names.each { |n| class_names[n.tr('/', '_').to_sym] = n.classify if n.include?('/') }
+      connection  = block_given? ? yield : ActiveRecord::Base.connection
 
-    table_names_to_fetch = table_names.reject { |table_name| fixture_is_cached?(connection, table_name) }
+      table_names_to_fetch = table_names.reject { |table_name| fixture_is_cached?(connection, table_name) }
 
-    unless table_names_to_fetch.empty?
-      ActiveRecord::Base.silence do
-        connection.disable_referential_integrity do
-          fixtures_map = {}
+      unless table_names_to_fetch.empty?
+        ActiveRecord::Base.silence do
+          connection.disable_referential_integrity do
+            fixtures_map = {}
 
-          fixtures = table_names_to_fetch.map do |table_name|
-            fixtures_map[table_name] = Fixtures.new(connection, table_name.tr('/', '_'), class_names[table_name.tr('/', '_').to_sym], File.join(fixtures_directory, table_name))
-          end
+            fixtures = table_names_to_fetch.map do |table_name|
+              fixtures_map[table_name] = Fixtures.new(connection, table_name.tr('/', '_'), class_names[table_name.tr('/', '_').to_sym], File.join(fixtures_directory, table_name))
+            end
 
-          all_loaded_fixtures.update(fixtures_map)
+            all_loaded_fixtures.update(fixtures_map)
 
-          connection.transaction(:requires_new => true) do
-            fixtures.reverse.each { |fixture| fixture.delete_existing_fixtures }
-            fixtures.each { |fixture| fixture.insert_fixtures }
+            connection.transaction(:requires_new => true) do
+              fixtures.reverse.each { |fixture| fixture.delete_existing_fixtures }
+              fixtures.each { |fixture| fixture.insert_fixtures }
 
-            # Cap primary key sequences to max(pk).
-            if connection.respond_to?(:reset_pk_sequence!)
-              table_names.each do |table_name|
-                connection.reset_pk_sequence!(table_name.tr('/', '_'))
+              # Cap primary key sequences to max(pk).
+              if connection.respond_to?(:reset_pk_sequence!)
+                table_names.each do |table_name|
+                  connection.reset_pk_sequence!(table_name.tr('/', '_'))
+                end
               end
             end
-          end
 
-          cache_fixtures(connection, fixtures_map)
+            cache_fixtures(connection, fixtures_map)
+          end
         end
       end
+      cached_fixtures(connection, table_names)
     end
-    cached_fixtures(connection, table_names)
-  end
 
-  # Returns a consistent, platform-independent identifier for +label+.
-  # Identifiers are positive integers less than 2^32.
-  def self.identify(label)
-    Zlib.crc32(label.to_s) % MAX_ID
-  end
-
-  attr_reader :table_name, :name
-
-  def initialize(connection, table_name, class_name, fixture_path, file_filter = DEFAULT_FILTER_RE)
-    @connection, @table_name, @fixture_path, @file_filter = connection, table_name, fixture_path, file_filter
-    @name = table_name # preserve fixture base name
-    @class_name = class_name ||
-                  (ActiveRecord::Base.pluralize_table_names ? @table_name.singularize.camelize : @table_name.camelize)
-    @table_name = "#{ActiveRecord::Base.table_name_prefix}#{@table_name}#{ActiveRecord::Base.table_name_suffix}"
-    @table_name = class_name.table_name if class_name.respond_to?(:table_name)
-    @connection = class_name.connection if class_name.respond_to?(:connection)
-    read_fixture_files
-  end
-
-  def delete_existing_fixtures
-    @connection.delete "DELETE FROM #{@connection.quote_table_name(table_name)}", 'Fixture Delete'
-  end
-
-  def insert_fixtures
-    now = ActiveRecord::Base.default_timezone == :utc ? Time.now.utc : Time.now
-    now = now.to_s(:db)
+    # Returns a consistent, platform-independent identifier for +label+.
+    # Identifiers are positive integers less than 2^32.
+    def self.identify(label)
+      Zlib.crc32(label.to_s) % MAX_ID
+    end
 
-    # allow a standard key to be used for doing defaults in YAML
-    if is_a?(Hash)
-      delete('DEFAULTS')
-    else
-      delete(assoc('DEFAULTS'))
+    attr_reader :table_name, :name
+
+    def initialize(connection, table_name, class_name, fixture_path, file_filter = DEFAULT_FILTER_RE)
+      @connection, @table_name, @fixture_path, @file_filter = connection, table_name, fixture_path, file_filter
+      @name = table_name # preserve fixture base name
+      @class_name = class_name ||
+                    (ActiveRecord::Base.pluralize_table_names ? @table_name.singularize.camelize : @table_name.camelize)
+      @table_name = "#{ActiveRecord::Base.table_name_prefix}#{@table_name}#{ActiveRecord::Base.table_name_suffix}"
+      @table_name = class_name.table_name if class_name.respond_to?(:table_name)
+      @connection = class_name.connection if class_name.respond_to?(:connection)
+      read_fixture_files
     end
 
-    # track any join tables we need to insert later
-    habtm_fixtures = Hash.new do |h, habtm|
-      h[habtm] = HabtmFixtures.new(@connection, habtm.options[:join_table], nil, nil)
+    def delete_existing_fixtures
+      @connection.delete "DELETE FROM #{@connection.quote_table_name(table_name)}", 'Fixture Delete'
     end
 
-    each do |label, fixture|
-      row = fixture.to_hash
+    def insert_fixtures
+      now = ActiveRecord::Base.default_timezone == :utc ? Time.now.utc : Time.now
+      now = now.to_s(:db)
 
-      if model_class && model_class < ActiveRecord::Base
-        # fill in timestamp columns if they aren't specified and the model is set to record_timestamps
-        if model_class.record_timestamps
-          timestamp_column_names.each do |name|
-            row[name] = now unless row.key?(name)
-          end
-        end
+      # allow a standard key to be used for doing defaults in YAML
+      if is_a?(Hash)
+        delete('DEFAULTS')
+      else
+        delete(assoc('DEFAULTS'))
+      end
 
-        # interpolate the fixture label
-        row.each do |key, value|
-          row[key] = label if value == "$LABEL"
-        end
+      # track any join tables we need to insert later
+      habtm_fixtures = Hash.new do |h, habtm|
+        h[habtm] = HabtmFixtures.new(@connection, habtm.options[:join_table], nil, nil)
+      end
 
-        # generate a primary key if necessary
-        if has_primary_key_column? && !row.include?(primary_key_name)
-          row[primary_key_name] = Fixtures.identify(label)
-        end
+      each do |label, fixture|
+        row = fixture.to_hash
 
-        # If STI is used, find the correct subclass for association reflection
-        reflection_class =
-          if row.include?(inheritance_column_name)
-            row[inheritance_column_name].constantize rescue model_class
-          else
-            model_class
+        if model_class && model_class < ActiveRecord::Base
+          # fill in timestamp columns if they aren't specified and the model is set to record_timestamps
+          if model_class.record_timestamps
+            timestamp_column_names.each do |name|
+              row[name] = now unless row.key?(name)
+            end
           end
 
-        reflection_class.reflect_on_all_associations.each do |association|
-          case association.macro
-          when :belongs_to
-            # Do not replace association name with association foreign key if they are named the same
-            fk_name = (association.options[:foreign_key] || "#{association.name}_id").to_s
+          # interpolate the fixture label
+          row.each do |key, value|
+            row[key] = label if value == "$LABEL"
+          end
 
-            if association.name.to_s != fk_name && value = row.delete(association.name.to_s)
-              if association.options[:polymorphic]
-                if value.sub!(/\s*\(([^\)]*)\)\s*$/, "")
-                  target_type = $1
-                  target_type_name = (association.options[:foreign_type] || "#{association.name}_type").to_s
+          # generate a primary key if necessary
+          if has_primary_key_column? && !row.include?(primary_key_name)
+            row[primary_key_name] = Fixtures.identify(label)
+          end
 
-                  # support polymorphic belongs_to as "label (Type)"
-                  row[target_type_name] = target_type
+          # If STI is used, find the correct subclass for association reflection
+          reflection_class =
+            if row.include?(inheritance_column_name)
+              row[inheritance_column_name].constantize rescue model_class
+            else
+              model_class
+            end
+
+          reflection_class.reflect_on_all_associations.each do |association|
+            case association.macro
+            when :belongs_to
+              # Do not replace association name with association foreign key if they are named the same
+              fk_name = (association.options[:foreign_key] || "#{association.name}_id").to_s
+
+              if association.name.to_s != fk_name && value = row.delete(association.name.to_s)
+                if association.options[:polymorphic]
+                  if value.sub!(/\s*\(([^\)]*)\)\s*$/, "")
+                    target_type = $1
+                    target_type_name = (association.options[:foreign_type] || "#{association.name}_type").to_s
+
+                    # support polymorphic belongs_to as "label (Type)"
+                    row[target_type_name] = target_type
+                  end
                 end
-              end
 
-              row[fk_name] = Fixtures.identify(value)
-            end
-          when :has_and_belongs_to_many
-            if (targets = row.delete(association.name.to_s))
-              targets = targets.is_a?(Array) ? targets : targets.split(/\s*,\s*/)
-              join_fixtures = habtm_fixtures[association]
-
-              targets.each do |target|
-                join_fixtures["#{label}_#{target}"] = Fixture.new(
-                  { association.primary_key_name => row[primary_key_name],
-                    association.association_foreign_key => Fixtures.identify(target) },
-                  nil, @connection)
+                row[fk_name] = Fixtures.identify(value)
+              end
+            when :has_and_belongs_to_many
+              if (targets = row.delete(association.name.to_s))
+                targets = targets.is_a?(Array) ? targets : targets.split(/\s*,\s*/)
+                join_fixtures = habtm_fixtures[association]
+
+                targets.each do |target|
+                  join_fixtures["#{label}_#{target}"] = Fixture.new(
+                    { association.primary_key_name => row[primary_key_name],
+                      association.association_foreign_key => Fixtures.identify(target) },
+                    nil, @connection)
+                end
               end
             end
           end
         end
+
+        @connection.insert_fixture(fixture, @table_name)
       end
 
-      @connection.insert_fixture(fixture, @table_name)
+      # insert any HABTM join tables we discovered
+      habtm_fixtures.values.each do |fixture|
+        fixture.delete_existing_fixtures
+        fixture.insert_fixtures
+      end
     end
 
-    # insert any HABTM join tables we discovered
-    habtm_fixtures.values.each do |fixture|
-      fixture.delete_existing_fixtures
-      fixture.insert_fixtures
-    end
-  end
+    private
+      class HabtmFixtures < ActiveRecord::Fixtures #:nodoc:
+        def read_fixture_files; end
+      end
 
-  private
-    class HabtmFixtures < ::Fixtures #:nodoc:
-      def read_fixture_files; end
-    end
+      def model_class
+        unless defined?(@model_class)
+          @model_class =
+            if @class_name.nil? || @class_name.is_a?(Class)
+              @class_name
+            else
+              @class_name.constantize rescue nil
+            end
+        end
 
-    def model_class
-      unless defined?(@model_class)
-        @model_class =
-          if @class_name.nil? || @class_name.is_a?(Class)
-            @class_name
-          else
-            @class_name.constantize rescue nil
-          end
+        @model_class
       end
 
-      @model_class
-    end
-
-    def primary_key_name
-      @primary_key_name ||= model_class && model_class.primary_key
-    end
+      def primary_key_name
+        @primary_key_name ||= model_class && model_class.primary_key
+      end
 
-    def has_primary_key_column?
-      @has_primary_key_column ||= primary_key_name &&
-        model_class.columns.any? { |c| c.name == primary_key_name }
-    end
+      def has_primary_key_column?
+        @has_primary_key_column ||= primary_key_name &&
+          model_class.columns.any? { |c| c.name == primary_key_name }
+      end
 
-    def timestamp_column_names
-      @timestamp_column_names ||=
-        %w(created_at created_on updated_at updated_on) & column_names
-    end
+      def timestamp_column_names
+        @timestamp_column_names ||=
+          %w(created_at created_on updated_at updated_on) & column_names
+      end
 
-    def inheritance_column_name
-      @inheritance_column_name ||= model_class && model_class.inheritance_column
-    end
+      def inheritance_column_name
+        @inheritance_column_name ||= model_class && model_class.inheritance_column
+      end
 
-    def column_names
-      @column_names ||= @connection.columns(@table_name).collect { |c| c.name }
-    end
+      def column_names
+        @column_names ||= @connection.columns(@table_name).collect { |c| c.name }
+      end
 
-    def read_fixture_files
-      if File.file?(yaml_file_path)
-        read_yaml_fixture_files
-      elsif File.file?(csv_file_path)
-        read_csv_fixture_files
-      else
-        raise FixturesFileNotFound, "Could not find #{yaml_file_path} or #{csv_file_path}"
+      def read_fixture_files
+        if File.file?(yaml_file_path)
+          read_yaml_fixture_files
+        elsif File.file?(csv_file_path)
+          read_csv_fixture_files
+        else
+          raise FixturesFileNotFound, "Could not find #{yaml_file_path} or #{csv_file_path}"
+        end
       end
-    end
 
-    def read_yaml_fixture_files
-      yaml_string = (Dir["#{@fixture_path}/**/*.yml"].select { |f|
-        File.file?(f)
-      } + [yaml_file_path]).map { |file_path| IO.read(file_path) }.join
+      def read_yaml_fixture_files
+        yaml_string = (Dir["#{@fixture_path}/**/*.yml"].select { |f|
+          File.file?(f)
+        } + [yaml_file_path]).map { |file_path| IO.read(file_path) }.join
+
+        if yaml = parse_yaml_string(yaml_string)
+          # If the file is an ordered map, extract its children.
+          yaml_value =
+            if yaml.respond_to?(:type_id) && yaml.respond_to?(:value)
+              yaml.value
+            else
+              [yaml]
+            end
 
-      if yaml = parse_yaml_string(yaml_string)
-        # If the file is an ordered map, extract its children.
-        yaml_value =
-          if yaml.respond_to?(:type_id) && yaml.respond_to?(:value)
-            yaml.value
-          else
-            [yaml]
-          end
+          yaml_value.each do |fixture|
+            raise Fixture::FormatError, "Bad data for #{@class_name} fixture named #{fixture}" unless fixture.respond_to?(:each)
+            fixture.each do |name, data|
+              unless data
+                raise Fixture::FormatError, "Bad data for #{@class_name} fixture named #{name} (nil)"
+              end
 
-        yaml_value.each do |fixture|
-          raise Fixture::FormatError, "Bad data for #{@class_name} fixture named #{fixture}" unless fixture.respond_to?(:each)
-          fixture.each do |name, data|
-            unless data
-              raise Fixture::FormatError, "Bad data for #{@class_name} fixture named #{name} (nil)"
+              self[name] = Fixture.new(data, model_class, @connection)
             end
-
-            self[name] = Fixture.new(data, model_class, @connection)
           end
         end
       end
-    end
 
-    def read_csv_fixture_files
-      reader = CSV.parse(erb_render(IO.read(csv_file_path)))
-      header = reader.shift
-      i = 0
-      reader.each do |row|
-        data = {}
-        row.each_with_index { |cell, j| data[header[j].to_s.strip] = cell.to_s.strip }
-        self["#{@class_name.to_s.underscore}_#{i+=1}"] = Fixture.new(data, model_class, @connection)
+      def read_csv_fixture_files
+        reader = CSV.parse(erb_render(IO.read(csv_file_path)))
+        header = reader.shift
+        i = 0
+        reader.each do |row|
+          data = {}
+          row.each_with_index { |cell, j| data[header[j].to_s.strip] = cell.to_s.strip }
+          self["#{@class_name.to_s.underscore}_#{i+=1}"] = Fixture.new(data, model_class, @connection)
+        end
       end
-    end
 
-    def yaml_file_path
-      "#{@fixture_path}.yml"
-    end
+      def yaml_file_path
+        "#{@fixture_path}.yml"
+      end
 
-    def csv_file_path
-      @fixture_path + ".csv"
-    end
+      def csv_file_path
+        @fixture_path + ".csv"
+      end
 
-    def yaml_fixtures_key(path)
-      File.basename(@fixture_path).split(".").first
-    end
+      def yaml_fixtures_key(path)
+        File.basename(@fixture_path).split(".").first
+      end
 
-    def parse_yaml_string(fixture_content)
-      YAML::load(erb_render(fixture_content))
-    rescue => error
-      raise Fixture::FormatError, "a YAML error occurred parsing #{yaml_file_path}. Please note that YAML must be consistently indented using spaces. Tabs are not allowed. Please have a look at http://www.yaml.org/faq.html\nThe exact error was:\n  #{error.class}: #{error}"
-    end
+      def parse_yaml_string(fixture_content)
+        YAML::load(erb_render(fixture_content))
+      rescue => error
+        raise Fixture::FormatError, "a YAML error occurred parsing #{yaml_file_path}. Please note that YAML must be consistently indented using spaces. Tabs are not allowed. Please have a look at http://www.yaml.org/faq.html\nThe exact error was:\n  #{error.class}: #{error}"
+      end
 
-    def erb_render(fixture_content)
-      ERB.new(fixture_content).result
-    end
-end
+      def erb_render(fixture_content)
+        ERB.new(fixture_content).result
+      end
+  end
 
-class Fixture #:nodoc:
-  include Enumerable
+  class Fixture #:nodoc:
+    include Enumerable
 
-  class FixtureError < StandardError #:nodoc:
-  end
+    class FixtureError < StandardError #:nodoc:
+    end
 
-  class FormatError < FixtureError #:nodoc:
-  end
+    class FormatError < FixtureError #:nodoc:
+    end
 
-  attr_reader :model_class
+    attr_reader :model_class
 
-  def initialize(fixture, model_class, connection = ActiveRecord::Base.connection)
-    @connection = connection
-    @fixture = fixture
-    @model_class = model_class.is_a?(Class) ? model_class : model_class.constantize rescue nil
-  end
+    def initialize(fixture, model_class, connection = ActiveRecord::Base.connection)
+      @connection = connection
+      @fixture = fixture
+      @model_class = model_class.is_a?(Class) ? model_class : model_class.constantize rescue nil
+    end
 
-  def class_name
-    @model_class.name if @model_class
-  end
+    def class_name
+      @model_class.name if @model_class
+    end
 
-  def each
-    @fixture.each { |item| yield item }
-  end
+    def each
+      @fixture.each { |item| yield item }
+    end
 
-  def [](key)
-    @fixture[key]
-  end
+    def [](key)
+      @fixture[key]
+    end
 
-  def to_hash
-    @fixture
-  end
+    def to_hash
+      @fixture
+    end
 
-  def key_list
-    @fixture.keys.map { |column_name| @connection.quote_column_name(column_name) }.join(', ')
-  end
+    def key_list
+      @fixture.keys.map { |column_name| @connection.quote_column_name(column_name) }.join(', ')
+    end
 
-  def value_list
-    cols = (model_class && model_class < ActiveRecord::Base) ? model_class.columns_hash : {}
-    @fixture.map do |key, value|
-      @connection.quote(value, cols[key]).gsub('[^\]\\n', "\n").gsub('[^\]\\r', "\r")
-    end.join(', ')
-  end
+    def value_list
+      cols = (model_class && model_class < ActiveRecord::Base) ? model_class.columns_hash : {}
+      @fixture.map do |key, value|
+        @connection.quote(value, cols[key]).gsub('[^\]\\n', "\n").gsub('[^\]\\r', "\r")
+      end.join(', ')
+    end
 
-  def find
-    if model_class
-      model_class.find(self[model_class.primary_key])
-    else
-      raise FixtureClassNotFound, "No class attached to find."
+    def find
+      if model_class
+        model_class.find(self[model_class.primary_key])
+      else
+        raise FixtureClassNotFound, "No class attached to find."
+      end
     end
   end
-end
 
-module ActiveRecord
   module TestFixtures
     extend ActiveSupport::Concern
 
diff --git a/activerecord/lib/active_record/railties/databases.rake b/activerecord/lib/active_record/railties/databases.rake
index a4fc181..e42806d 100644
--- a/activerecord/lib/active_record/railties/databases.rake
+++ b/activerecord/lib/active_record/railties/databases.rake
@@ -297,7 +297,7 @@ db_namespace = namespace :db do
       fixtures_dir = ENV['FIXTURES_DIR'] ? File.join(base_dir, ENV['FIXTURES_DIR']) : base_dir
 
       (ENV['FIXTURES'] ? ENV['FIXTURES'].split(/,/).map {|f| File.join(fixtures_dir, f) } : Dir["#{fixtures_dir}/**/*.{yml,csv}"]).each do |fixture_file|
-        Fixtures.create_fixtures(fixtures_dir, fixture_file[(fixtures_dir.size + 1)..-5])
+        ActiveRecord::Fixtures.create_fixtures(fixtures_dir, fixture_file[(fixtures_dir.size + 1)..-5])
       end
     end
 
@@ -308,13 +308,13 @@ db_namespace = namespace :db do
       label, id = ENV["LABEL"], ENV["ID"]
       raise "LABEL or ID required" if label.blank? && id.blank?
 
-      puts %Q(The fixture ID for "#{label}" is #{Fixtures.identify(label)}.) if label
+      puts %Q(The fixture ID for "#{label}" is #{ActiveRecord::Fixtures.identify(label)}.) if label
 
       base_dir = ENV['FIXTURES_PATH'] ? File.join(Rails.root, ENV['FIXTURES_PATH']) : File.join(Rails.root, 'test', 'fixtures')
       Dir["#{base_dir}/**/*.yml"].each do |file|
         if data = YAML::load(ERB.new(IO.read(file)).result)
           data.keys.each do |key|
-            key_id = Fixtures.identify(key)
+            key_id = ActiveRecord::Fixtures.identify(key)
 
             if key == label || key_id == id.to_i
               puts "#{file}: #{key} (#{key_id})"
diff --git a/activerecord/test/cases/adapters/mysql/reserved_word_test.rb b/activerecord/test/cases/adapters/mysql/reserved_word_test.rb
index 90d8b0d..2d7f262 100644
--- a/activerecord/test/cases/adapters/mysql/reserved_word_test.rb
+++ b/activerecord/test/cases/adapters/mysql/reserved_word_test.rb
@@ -156,7 +156,7 @@ class MysqlReservedWordTest < ActiveRecord::TestCase
   private
   # custom fixture loader, uses Fixtures#create_fixtures and appends base_path to the current file's path
   def create_test_fixtures(*fixture_names)
-    Fixtures.create_fixtures(FIXTURES_ROOT + "/reserved_words", fixture_names)
+    ActiveRecord::Fixtures.create_fixtures(FIXTURES_ROOT + "/reserved_words", fixture_names)
   end
 
   # custom drop table, uses execute on connection to drop a table if it exists. note: escapes table_name
diff --git a/activerecord/test/cases/adapters/mysql2/reserved_word_test.rb b/activerecord/test/cases/adapters/mysql2/reserved_word_test.rb
index 90d8b0d..2d7f262 100644
--- a/activerecord/test/cases/adapters/mysql2/reserved_word_test.rb
+++ b/activerecord/test/cases/adapters/mysql2/reserved_word_test.rb
@@ -156,7 +156,7 @@ class MysqlReservedWordTest < ActiveRecord::TestCase
   private
   # custom fixture loader, uses Fixtures#create_fixtures and appends base_path to the current file's path
   def create_test_fixtures(*fixture_names)
-    Fixtures.create_fixtures(FIXTURES_ROOT + "/reserved_words", fixture_names)
+    ActiveRecord::Fixtures.create_fixtures(FIXTURES_ROOT + "/reserved_words", fixture_names)
   end
 
   # custom drop table, uses execute on connection to drop a table if it exists. note: escapes table_name
diff --git a/activerecord/test/cases/fixtures_test.rb b/activerecord/test/cases/fixtures_test.rb
index 9ce163a..19845c6 100644
--- a/activerecord/test/cases/fixtures_test.rb
+++ b/activerecord/test/cases/fixtures_test.rb
@@ -35,7 +35,7 @@ class FixturesTest < ActiveRecord::TestCase
     FIXTURES.each do |name|
       fixtures = nil
       assert_nothing_raised { fixtures = create_fixtures(name) }
-      assert_kind_of(Fixtures, fixtures)
+      assert_kind_of(ActiveRecord::Fixtures, fixtures)
       fixtures.each { |_name, fixture|
         fixture.each { |key, value|
           assert_match(MATCH_ATTRIBUTE_NAME, key)
@@ -48,7 +48,7 @@ class FixturesTest < ActiveRecord::TestCase
     fixtures_array = nil
     assert_nothing_raised { fixtures_array = create_fixtures(*FIXTURES) }
     assert_kind_of(Array, fixtures_array)
-    fixtures_array.each { |fixtures| assert_kind_of(Fixtures, fixtures) }
+    fixtures_array.each { |fixtures| assert_kind_of(ActiveRecord::Fixtures, fixtures) }
   end
 
   def test_attributes
@@ -69,7 +69,7 @@ class FixturesTest < ActiveRecord::TestCase
   if ActiveRecord::Base.connection.supports_migrations?
     def test_inserts_with_pre_and_suffix
       # Reset cache to make finds on the new table work
-      Fixtures.reset_cache
+      ActiveRecord::Fixtures.reset_cache
 
       ActiveRecord::Base.connection.create_table :prefix_topics_suffix do |t|
         t.column :title, :string
@@ -146,11 +146,11 @@ class FixturesTest < ActiveRecord::TestCase
   end
 
   def test_empty_yaml_fixture
-    assert_not_nil Fixtures.new( Account.connection, "accounts", 'Account', FIXTURES_ROOT + "/naked/yml/accounts")
+    assert_not_nil ActiveRecord::Fixtures.new( Account.connection, "accounts", 'Account', FIXTURES_ROOT + "/naked/yml/accounts")
   end
 
   def test_empty_yaml_fixture_with_a_comment_in_it
-    assert_not_nil Fixtures.new( Account.connection, "companies", 'Company', FIXTURES_ROOT + "/naked/yml/companies")
+    assert_not_nil ActiveRecord::Fixtures.new( Account.connection, "companies", 'Company', FIXTURES_ROOT + "/naked/yml/companies")
   end
 
   def test_nonexistent_fixture_file
@@ -160,23 +160,23 @@ class FixturesTest < ActiveRecord::TestCase
     assert Dir[nonexistent_fixture_path+"*"].empty?
 
     assert_raise(FixturesFileNotFound) do
-      Fixtures.new( Account.connection, "companies", 'Company', nonexistent_fixture_path)
+      ActiveRecord::Fixtures.new( Account.connection, "companies", 'Company', nonexistent_fixture_path)
     end
   end
 
   def test_dirty_dirty_yaml_file
-    assert_raise(Fixture::FormatError) do
-      Fixtures.new( Account.connection, "courses", 'Course', FIXTURES_ROOT + "/naked/yml/courses")
+    assert_raise(ActiveRecord::Fixture::FormatError) do
+      ActiveRecord::Fixtures.new( Account.connection, "courses", 'Course', FIXTURES_ROOT + "/naked/yml/courses")
     end
   end
 
   def test_empty_csv_fixtures
-    assert_not_nil Fixtures.new( Account.connection, "accounts", 'Account', FIXTURES_ROOT + "/naked/csv/accounts")
+    assert_not_nil ActiveRecord::Fixtures.new( Account.connection, "accounts", 'Account', FIXTURES_ROOT + "/naked/csv/accounts")
   end
 
   def test_omap_fixtures
     assert_nothing_raised do
-      fixtures = Fixtures.new(Account.connection, 'categories', 'Category', FIXTURES_ROOT + "/categories_ordered")
+      fixtures = ActiveRecord::Fixtures.new(Account.connection, 'categories', 'Category', FIXTURES_ROOT + "/categories_ordered")
 
       i = 0
       fixtures.each do |name, fixture|
@@ -213,7 +213,7 @@ if Account.connection.respond_to?(:reset_pk_sequence!)
 
     def setup
       @instances = [Account.new(:credit_limit => 50), Company.new(:name => 'RoR Consulting')]
-      Fixtures.reset_cache # make sure tables get reinitialized
+      ActiveRecord::Fixtures.reset_cache # make sure tables get reinitialized
     end
 
     def test_resets_to_min_pk_with_specified_pk_and_sequence
@@ -505,13 +505,13 @@ class FasterFixturesTest < ActiveRecord::TestCase
 
   def load_extra_fixture(name)
     fixture = create_fixtures(name)
-    assert fixture.is_a?(Fixtures)
+    assert fixture.is_a?(ActiveRecord::Fixtures)
     @loaded_fixtures[fixture.table_name] = fixture
   end
 
   def test_cache
-    assert Fixtures.fixture_is_cached?(ActiveRecord::Base.connection, 'categories')
-    assert Fixtures.fixture_is_cached?(ActiveRecord::Base.connection, 'authors')
+    assert ActiveRecord::Fixtures.fixture_is_cached?(ActiveRecord::Base.connection, 'categories')
+    assert ActiveRecord::Fixtures.fixture_is_cached?(ActiveRecord::Base.connection, 'authors')
 
     assert_no_queries do
       create_fixtures('categories')
@@ -519,7 +519,7 @@ class FasterFixturesTest < ActiveRecord::TestCase
     end
 
     load_extra_fixture('posts')
-    assert Fixtures.fixture_is_cached?(ActiveRecord::Base.connection, 'posts')
+    assert ActiveRecord::Fixtures.fixture_is_cached?(ActiveRecord::Base.connection, 'posts')
     self.class.setup_fixture_accessors('posts')
     assert_equal 'Welcome to the weblog', posts(:welcome).title
   end
@@ -529,17 +529,17 @@ class FoxyFixturesTest < ActiveRecord::TestCase
   fixtures :parrots, :parrots_pirates, :pirates, :treasures, :mateys, :ships, :computers, :developers, :"admin/accounts", :"admin/users"
 
   def test_identifies_strings
-    assert_equal(Fixtures.identify("foo"), Fixtures.identify("foo"))
-    assert_not_equal(Fixtures.identify("foo"), Fixtures.identify("FOO"))
+    assert_equal(ActiveRecord::Fixtures.identify("foo"), ActiveRecord::Fixtures.identify("foo"))
+    assert_not_equal(ActiveRecord::Fixtures.identify("foo"), ActiveRecord::Fixtures.identify("FOO"))
   end
 
   def test_identifies_symbols
-    assert_equal(Fixtures.identify(:foo), Fixtures.identify(:foo))
+    assert_equal(ActiveRecord::Fixtures.identify(:foo), ActiveRecord::Fixtures.identify(:foo))
   end
 
   def test_identifies_consistently
-    assert_equal 207281424, Fixtures.identify(:ruby)
-    assert_equal 1066363776, Fixtures.identify(:sapphire_2)
+    assert_equal 207281424, ActiveRecord::Fixtures.identify(:ruby)
+    assert_equal 1066363776, ActiveRecord::Fixtures.identify(:sapphire_2)
   end
 
   TIMESTAMP_COLUMNS = %w(created_at created_on updated_at updated_on)
diff --git a/activerecord/test/cases/helper.rb b/activerecord/test/cases/helper.rb
index f9bbc52..459f07d 100644
--- a/activerecord/test/cases/helper.rb
+++ b/activerecord/test/cases/helper.rb
@@ -96,7 +96,7 @@ class ActiveSupport::TestCase
   self.use_transactional_fixtures = true
 
   def create_fixtures(*table_names, &block)
-    Fixtures.create_fixtures(ActiveSupport::TestCase.fixture_path, table_names, {}, &block)
+    ActiveRecord::Fixtures.create_fixtures(ActiveSupport::TestCase.fixture_path, table_names, {}, &block)
   end
 end
 
diff --git a/activerecord/test/fixtures/mateys.yml b/activerecord/test/fixtures/mateys.yml
index 9ecdd4e..d369095 100644
--- a/activerecord/test/fixtures/mateys.yml
+++ b/activerecord/test/fixtures/mateys.yml
@@ -1,4 +1,4 @@
 blackbeard_to_redbeard:
-  pirate_id: <%= Fixtures.identify(:blackbeard) %>
-  target_id: <%= Fixtures.identify(:redbeard) %>
+  pirate_id: <%= ActiveRecord::Fixtures.identify(:blackbeard) %>
+  target_id: <%= ActiveRecord::Fixtures.identify(:redbeard) %>
   weight: 10
diff --git a/activerecord/test/fixtures/parrots_pirates.yml b/activerecord/test/fixtures/parrots_pirates.yml
index 6b17a37..6647224 100644
--- a/activerecord/test/fixtures/parrots_pirates.yml
+++ b/activerecord/test/fixtures/parrots_pirates.yml
@@ -1,7 +1,7 @@
 george_blackbeard:
-  parrot_id: <%= Fixtures.identify(:george) %>
-  pirate_id: <%= Fixtures.identify(:blackbeard) %>
+  parrot_id: <%= ActiveRecord::Fixtures.identify(:george) %>
+  pirate_id: <%= ActiveRecord::Fixtures.identify(:blackbeard) %>
 
 louis_blackbeard:
-  parrot_id: <%= Fixtures.identify(:louis) %>
-  pirate_id: <%= Fixtures.identify(:blackbeard) %>
+  parrot_id: <%= ActiveRecord::Fixtures.identify(:louis) %>
+  pirate_id: <%= ActiveRecord::Fixtures.identify(:blackbeard) %>
-- 
1.7.1


From 5ffa321e58b03315e68a55e3b5a26ca5c8ef8540 Mon Sep 17 00:00:00 2001
From: Brian Underwood <bunderwood@rbmtechnologies.com>
Date: Mon, 13 Dec 2010 13:50:45 -0500
Subject: [PATCH 2/2] Additional changes namespacing the Fixtures class beyond ActiveRecord

---
 activesupport/test/autoload.rb                     |   30 ++++++++++----------
 .../test/fixtures/autoload/another_class.rb        |    2 +-
 activesupport/test/fixtures/autoload/some_class.rb |    2 +-
 railties/lib/rails/test_help.rb                    |    2 +-
 4 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/activesupport/test/autoload.rb b/activesupport/test/autoload.rb
index 5d8026a..edc8a88 100644
--- a/activesupport/test/autoload.rb
+++ b/activesupport/test/autoload.rb
@@ -3,7 +3,7 @@ require 'abstract_unit'
 class TestAutoloadModule < ActiveSupport::TestCase
   include ActiveSupport::Testing::Isolation
 
-  module ::Fixtures
+  module ActiveRecord::Fixtures
     extend ActiveSupport::Autoload
 
     module Autoload
@@ -12,69 +12,69 @@ class TestAutoloadModule < ActiveSupport::TestCase
   end
 
   test "the autoload module works like normal autoload" do
-    module ::Fixtures::Autoload
+    module ActiveRecord::Fixtures::Autoload
       autoload :SomeClass, "fixtures/autoload/some_class"
     end
 
-    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::Autoload::SomeClass }
   end
 
   test "when specifying an :eager constant it still works like normal autoload by default" do
-    module ::Fixtures::Autoload
+    module ActiveRecord::Fixtures::Autoload
       autoload :SomeClass, "fixtures/autoload/some_class"
     end
 
     assert !$LOADED_FEATURES.include?("fixtures/autoload/some_class.rb")
-    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::Autoload::SomeClass }
   end
 
   test ":eager constants can be triggered via ActiveSupport::Autoload.eager_autoload!" do
-    module ::Fixtures::Autoload
+    module ActiveRecord::Fixtures::Autoload
       autoload :SomeClass, "fixtures/autoload/some_class"
     end
     ActiveSupport::Autoload.eager_autoload!
     assert $LOADED_FEATURES.include?("fixtures/autoload/some_class.rb")
-    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::Autoload::SomeClass }
   end
 
   test "the location of autoloaded constants defaults to :name.underscore" do
-    module ::Fixtures::Autoload
+    module ActiveRecord::Fixtures::Autoload
       autoload :SomeClass
     end
 
     assert !$LOADED_FEATURES.include?("fixtures/autoload/some_class.rb")
-    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::Autoload::SomeClass }
   end
 
   test "the location of :eager autoloaded constants defaults to :name.underscore" do
-    module ::Fixtures::Autoload
+    module ActiveRecord::Fixtures::Autoload
       autoload :SomeClass
     end
 
     ActiveSupport::Autoload.eager_autoload!
     assert $LOADED_FEATURES.include?("fixtures/autoload/some_class.rb")
-    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::Autoload::SomeClass }
   end
 
   test "a directory for a block of autoloads can be specified" do
-    module ::Fixtures
+    module ActiveRecord::Fixtures
       autoload_under "autoload" do
         autoload :AnotherClass
       end
     end
 
     assert !$LOADED_FEATURES.include?("fixtures/autoload/another_class.rb")
-    assert_nothing_raised { ::Fixtures::AnotherClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::AnotherClass }
   end
 
   test "a path for a block of autoloads can be specified" do
-    module ::Fixtures
+    module ActiveRecord::Fixtures
       autoload_at "fixtures/autoload/another_class" do
         autoload :AnotherClass
       end
     end
 
     assert !$LOADED_FEATURES.include?("fixtures/autoload/another_class.rb")
-    assert_nothing_raised { ::Fixtures::AnotherClass }
+    assert_nothing_raised { ActiveRecord::Fixtures::AnotherClass }
   end
 end
\ No newline at end of file
diff --git a/activesupport/test/fixtures/autoload/another_class.rb b/activesupport/test/fixtures/autoload/another_class.rb
index a240b3d..9eb0905 100644
--- a/activesupport/test/fixtures/autoload/another_class.rb
+++ b/activesupport/test/fixtures/autoload/another_class.rb
@@ -1,2 +1,2 @@
-class Fixtures::AnotherClass
+class ActiveRecord::Fixtures::AnotherClass
 end
\ No newline at end of file
diff --git a/activesupport/test/fixtures/autoload/some_class.rb b/activesupport/test/fixtures/autoload/some_class.rb
index 13b3c73..287e729 100644
--- a/activesupport/test/fixtures/autoload/some_class.rb
+++ b/activesupport/test/fixtures/autoload/some_class.rb
@@ -1,2 +1,2 @@
-class Fixtures::Autoload::SomeClass
+class ActiveRecord::Fixtures::Autoload::SomeClass
 end
\ No newline at end of file
diff --git a/railties/lib/rails/test_help.rb b/railties/lib/rails/test_help.rb
index f810023..7b3fd07 100644
--- a/railties/lib/rails/test_help.rb
+++ b/railties/lib/rails/test_help.rb
@@ -24,7 +24,7 @@ if defined?(ActiveRecord)
   ActionDispatch::IntegrationTest.fixture_path = ActiveSupport::TestCase.fixture_path
 
   def create_fixtures(*table_names, &block)
-    Fixtures.create_fixtures(ActiveSupport::TestCase.fixture_path, table_names, {}, &block)
+    ActiveRecord::Fixtures.create_fixtures(ActiveSupport::TestCase.fixture_path, table_names, {}, &block)
   end
 end
 
-- 
1.7.1

