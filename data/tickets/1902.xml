<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer" nil="true"></assigned-user-id>
  <attachments-count type="integer">0</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2009-02-07T04:05:20+00:00</created-at>
  <creator-id type="integer">37950</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer">71472</milestone-id>
  <number type="integer">1902</number>
  <permalink>establish_connection-does-not-support-joins</permalink>
  <priority type="integer">1167</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>stale</state>
  <tag>establish_connection</tag>
  <title>establish_connection does not support joins</title>
  <updated-at type="datetime">2011-02-02T17:40:28+00:00</updated-at>
  <user-id type="integer">40272</user-id>
  <version type="integer">8</version>
  <user-name>Santiago Pastorino</user-name>
  <creator-name>Andrew Roth</creator-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
  <milestone-title>3.x</milestone-title>
  <priority-name nil="true"></priority-name>
  <original-body>Hello,

I have a situation where I need to use a legacy database.  I'm finding establish_connection is not adequate to use all of the active record features, for example has_many :through across different databases fails.  Would a solution be to detect the different connections, and split the query into two separate queries?

Is establish_connection even meant to work in this situation?

On mysql databases on the same server, I have found setting the table name to &quot;database.table&quot; seamlessly fixes the problem since mysql supports joins over databases.  Would a patch on active record that sets a prefix &quot;database.&quot; when establish_connection is used be useful / possible?

-----

@@@
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

legacy:
  adapter: sqlite3
  database: db/legacy.sqlite3
  pool: 5
  timeout: 5000
@@@
-----

@@@
class A &lt; ActiveRecord::Base
  has_many :a_bs
  has_many :bs, :through =&gt; :a_bs
end
class AB &lt; ActiveRecord::Base
  belongs_to :a
  belongs_to :b
end
class B &lt; ActiveRecord::Base
  establish_connection 'legacy'
end
@@@

-----

@@@
Loading development environment (Rails 2.2.2)
&gt;&gt; a = A.create!
=&gt; #&lt;A id: 1, created_at: &quot;2009-01-20 21:21:12&quot;, updated_at: &quot;2009-01-20 21:21:12&quot;&gt;
&gt;&gt; a.a_bs
=&gt; []
&gt;&gt; b = B.create!
=&gt; #&lt;B id: 1, created_at: &quot;2009-01-20 21:22:19&quot;, updated_at: &quot;2009-01-20 21:22:19&quot;&gt;
&gt;&gt; a.a_bs.create! :b_id =&gt; b.id
=&gt; #&lt;AB id: 1, a_id: 1, b_id: 1, created_at: &quot;2009-01-20 21:22:36&quot;, updated_at: &quot;2009-01-20 21:22:36&quot;&gt;
&gt;&gt; a.a_bs
=&gt; [#&lt;AB id: 1, a_id: 1, b_id: 1, created_at: &quot;2009-01-20 21:22:36&quot;, updated_at: &quot;2009-01-20 21:22:36&quot;&gt;]
&gt;&gt; a.bs
ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: abs: SELECT &quot;bs&quot;.* FROM &quot;bs&quot;  INNER JOIN abs ON bs.id = abs.b_id    WHERE ((&quot;abs&quot;.a_id = 1)) 
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract_adapter.rb:188:in `log'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:372:in `catch_schema_changes'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:275:in `select'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/database_statements.rb:7:in `select_all_without_query_cache'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/query_cache.rb:62:in `select_all'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:635:in `find_by_sql'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:1490:in `find_every'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:589:in `find'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/has_many_through_association.rb:73:in `find_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_collection.rb:344:in `load_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_proxy.rb:139:in `inspect'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:298:in `output_value'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:151:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:259:in `signal_status'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:147:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:146:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:70:in `start'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `catch'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `start'
&gt;&gt;
@@@</original-body>
  <latest-body>Hello,

I have a situation where I need to use a legacy database.  I'm finding establish_connection is not adequate to use all of the active record features, for example has_many :through across different databases fails.  Would a solution be to detect the different connections, and split the query into two separate queries?

Is establish_connection even meant to work in this situation?

On mysql databases on the same server, I have found setting the table name to &quot;database.table&quot; seamlessly fixes the problem since mysql supports joins over databases.  Would a patch on active record that sets a prefix &quot;database.&quot; when establish_connection is used be useful / possible?

-----

@@@
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

legacy:
  adapter: sqlite3
  database: db/legacy.sqlite3
  pool: 5
  timeout: 5000
@@@
-----

@@@
class A &lt; ActiveRecord::Base
  has_many :a_bs
  has_many :bs, :through =&gt; :a_bs
end
class AB &lt; ActiveRecord::Base
  belongs_to :a
  belongs_to :b
end
class B &lt; ActiveRecord::Base
  establish_connection 'legacy'
end
@@@

-----

@@@
Loading development environment (Rails 2.2.2)
&gt;&gt; a = A.create!
=&gt; #&lt;A id: 1, created_at: &quot;2009-01-20 21:21:12&quot;, updated_at: &quot;2009-01-20 21:21:12&quot;&gt;
&gt;&gt; a.a_bs
=&gt; []
&gt;&gt; b = B.create!
=&gt; #&lt;B id: 1, created_at: &quot;2009-01-20 21:22:19&quot;, updated_at: &quot;2009-01-20 21:22:19&quot;&gt;
&gt;&gt; a.a_bs.create! :b_id =&gt; b.id
=&gt; #&lt;AB id: 1, a_id: 1, b_id: 1, created_at: &quot;2009-01-20 21:22:36&quot;, updated_at: &quot;2009-01-20 21:22:36&quot;&gt;
&gt;&gt; a.a_bs
=&gt; [#&lt;AB id: 1, a_id: 1, b_id: 1, created_at: &quot;2009-01-20 21:22:36&quot;, updated_at: &quot;2009-01-20 21:22:36&quot;&gt;]
&gt;&gt; a.bs
ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: abs: SELECT &quot;bs&quot;.* FROM &quot;bs&quot;  INNER JOIN abs ON bs.id = abs.b_id    WHERE ((&quot;abs&quot;.a_id = 1)) 
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract_adapter.rb:188:in `log'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:372:in `catch_schema_changes'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:275:in `select'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/database_statements.rb:7:in `select_all_without_query_cache'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/query_cache.rb:62:in `select_all'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:635:in `find_by_sql'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:1490:in `find_every'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:589:in `find'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/has_many_through_association.rb:73:in `find_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_collection.rb:344:in `load_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_proxy.rb:139:in `inspect'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:298:in `output_value'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:151:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:259:in `signal_status'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:147:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:146:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:70:in `start'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `catch'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `start'
&gt;&gt;
@@@</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;Hello,&lt;/p&gt;
&lt;p&gt;I have a situation where I need to use a legacy database. I'm
finding establish_connection is not adequate to use all of the
active record features, for example has_many :through across
different databases fails. Would a solution be to detect the
different connections, and split the query into two separate
queries?&lt;/p&gt;
&lt;p&gt;Is establish_connection even meant to work in this
situation?&lt;/p&gt;
&lt;p&gt;On mysql databases on the same server, I have found setting the
table name to &quot;database.table&quot; seamlessly fixes the problem since
mysql supports joins over databases. Would a patch on active record
that sets a prefix &quot;database.&quot; when establish_connection is used be
useful / possible?&lt;/p&gt;
&lt;hr&gt;

&lt;pre&gt;&lt;code&gt;
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

legacy:
  adapter: sqlite3
  database: db/legacy.sqlite3
  pool: 5
  timeout: 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;

&lt;pre&gt;&lt;code&gt;
class A &amp;lt; ActiveRecord::Base
  has_many :a_bs
  has_many :bs, :through =&amp;gt; :a_bs
end
class AB &amp;lt; ActiveRecord::Base
  belongs_to :a
  belongs_to :b
end
class B &amp;lt; ActiveRecord::Base
  establish_connection 'legacy'
end
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;

&lt;pre&gt;&lt;code&gt;
Loading development environment (Rails 2.2.2)
&amp;gt;&amp;gt; a = A.create!
=&amp;gt; #&amp;lt;A id: 1, created_at: &amp;quot;2009-01-20 21:21:12&amp;quot;, updated_at: &amp;quot;2009-01-20 21:21:12&amp;quot;&amp;gt;
&amp;gt;&amp;gt; a.a_bs
=&amp;gt; []
&amp;gt;&amp;gt; b = B.create!
=&amp;gt; #&amp;lt;B id: 1, created_at: &amp;quot;2009-01-20 21:22:19&amp;quot;, updated_at: &amp;quot;2009-01-20 21:22:19&amp;quot;&amp;gt;
&amp;gt;&amp;gt; a.a_bs.create! :b_id =&amp;gt; b.id
=&amp;gt; #&amp;lt;AB id: 1, a_id: 1, b_id: 1, created_at: &amp;quot;2009-01-20 21:22:36&amp;quot;, updated_at: &amp;quot;2009-01-20 21:22:36&amp;quot;&amp;gt;
&amp;gt;&amp;gt; a.a_bs
=&amp;gt; [#&amp;lt;AB id: 1, a_id: 1, b_id: 1, created_at: &amp;quot;2009-01-20 21:22:36&amp;quot;, updated_at: &amp;quot;2009-01-20 21:22:36&amp;quot;&amp;gt;]
&amp;gt;&amp;gt; a.bs
ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: abs: SELECT &amp;quot;bs&amp;quot;.* FROM &amp;quot;bs&amp;quot;  INNER JOIN abs ON bs.id = abs.b_id    WHERE ((&amp;quot;abs&amp;quot;.a_id = 1)) 
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract_adapter.rb:188:in `log'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:372:in `catch_schema_changes'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:275:in `select'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/database_statements.rb:7:in `select_all_without_query_cache'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/query_cache.rb:62:in `select_all'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:635:in `find_by_sql'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:1490:in `find_every'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:589:in `find'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/has_many_through_association.rb:73:in `find_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_collection.rb:344:in `load_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_proxy.rb:139:in `inspect'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:298:in `output_value'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:151:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:259:in `signal_status'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:147:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:146:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:70:in `start'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `catch'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `start'
&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Hello,

I have a situation where I need to use a legacy database.  I'm finding establish_connection is not adequate to use all of the active record features, for example has_many :through across different databases fails.  Would a solution be to detect the different connections, and split the query into two separate queries?

Is establish_connection even meant to work in this situation?

On mysql databases on the same server, I have found setting the table name to &quot;database.table&quot; seamlessly fixes the problem since mysql supports joins over databases.  Would a patch on active record that sets a prefix &quot;database.&quot; when establish_connection is used be useful / possible?

-----

@@@
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

legacy:
  adapter: sqlite3
  database: db/legacy.sqlite3
  pool: 5
  timeout: 5000
@@@
-----

@@@
class A &lt; ActiveRecord::Base
  has_many :a_bs
  has_many :bs, :through =&gt; :a_bs
end
class AB &lt; ActiveRecord::Base
  belongs_to :a
  belongs_to :b
end
class B &lt; ActiveRecord::Base
  establish_connection 'legacy'
end
@@@

-----

@@@
Loading development environment (Rails 2.2.2)
&gt;&gt; a = A.create!
=&gt; #&lt;A id: 1, created_at: &quot;2009-01-20 21:21:12&quot;, updated_at: &quot;2009-01-20 21:21:12&quot;&gt;
&gt;&gt; a.a_bs
=&gt; []
&gt;&gt; b = B.create!
=&gt; #&lt;B id: 1, created_at: &quot;2009-01-20 21:22:19&quot;, updated_at: &quot;2009-01-20 21:22:19&quot;&gt;
&gt;&gt; a.a_bs.create! :b_id =&gt; b.id
=&gt; #&lt;AB id: 1, a_id: 1, b_id: 1, created_at: &quot;2009-01-20 21:22:36&quot;, updated_at: &quot;2009-01-20 21:22:36&quot;&gt;
&gt;&gt; a.a_bs
=&gt; [#&lt;AB id: 1, a_id: 1, b_id: 1, created_at: &quot;2009-01-20 21:22:36&quot;, updated_at: &quot;2009-01-20 21:22:36&quot;&gt;]
&gt;&gt; a.bs
ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: abs: SELECT &quot;bs&quot;.* FROM &quot;bs&quot;  INNER JOIN abs ON bs.id = abs.b_id    WHERE ((&quot;abs&quot;.a_id = 1)) 
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract_adapter.rb:188:in `log'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:372:in `catch_schema_changes'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:275:in `select'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/database_statements.rb:7:in `select_all_without_query_cache'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/query_cache.rb:62:in `select_all'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:635:in `find_by_sql'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:1490:in `find_every'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:589:in `find'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/has_many_through_association.rb:73:in `find_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_collection.rb:344:in `load_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_proxy.rb:139:in `inspect'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:298:in `output_value'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:151:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:259:in `signal_status'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:147:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:146:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:70:in `start'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `catch'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `start'
&gt;&gt;
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;Hello,&lt;/p&gt;
&lt;p&gt;I have a situation where I need to use a legacy database. I'm
finding establish_connection is not adequate to use all of the
active record features, for example has_many :through across
different databases fails. Would a solution be to detect the
different connections, and split the query into two separate
queries?&lt;/p&gt;
&lt;p&gt;Is establish_connection even meant to work in this
situation?&lt;/p&gt;
&lt;p&gt;On mysql databases on the same server, I have found setting the
table name to &quot;database.table&quot; seamlessly fixes the problem since
mysql supports joins over databases. Would a patch on active record
that sets a prefix &quot;database.&quot; when establish_connection is used be
useful / possible?&lt;/p&gt;
&lt;hr&gt;

&lt;pre&gt;&lt;code&gt;
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

legacy:
  adapter: sqlite3
  database: db/legacy.sqlite3
  pool: 5
  timeout: 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;

&lt;pre&gt;&lt;code&gt;
class A &amp;lt; ActiveRecord::Base
  has_many :a_bs
  has_many :bs, :through =&amp;gt; :a_bs
end
class AB &amp;lt; ActiveRecord::Base
  belongs_to :a
  belongs_to :b
end
class B &amp;lt; ActiveRecord::Base
  establish_connection 'legacy'
end
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;

&lt;pre&gt;&lt;code&gt;
Loading development environment (Rails 2.2.2)
&amp;gt;&amp;gt; a = A.create!
=&amp;gt; #&amp;lt;A id: 1, created_at: &amp;quot;2009-01-20 21:21:12&amp;quot;, updated_at: &amp;quot;2009-01-20 21:21:12&amp;quot;&amp;gt;
&amp;gt;&amp;gt; a.a_bs
=&amp;gt; []
&amp;gt;&amp;gt; b = B.create!
=&amp;gt; #&amp;lt;B id: 1, created_at: &amp;quot;2009-01-20 21:22:19&amp;quot;, updated_at: &amp;quot;2009-01-20 21:22:19&amp;quot;&amp;gt;
&amp;gt;&amp;gt; a.a_bs.create! :b_id =&amp;gt; b.id
=&amp;gt; #&amp;lt;AB id: 1, a_id: 1, b_id: 1, created_at: &amp;quot;2009-01-20 21:22:36&amp;quot;, updated_at: &amp;quot;2009-01-20 21:22:36&amp;quot;&amp;gt;
&amp;gt;&amp;gt; a.a_bs
=&amp;gt; [#&amp;lt;AB id: 1, a_id: 1, b_id: 1, created_at: &amp;quot;2009-01-20 21:22:36&amp;quot;, updated_at: &amp;quot;2009-01-20 21:22:36&amp;quot;&amp;gt;]
&amp;gt;&amp;gt; a.bs
ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: abs: SELECT &amp;quot;bs&amp;quot;.* FROM &amp;quot;bs&amp;quot;  INNER JOIN abs ON bs.id = abs.b_id    WHERE ((&amp;quot;abs&amp;quot;.a_id = 1)) 
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract_adapter.rb:188:in `log'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:372:in `catch_schema_changes'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:132:in `execute'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/sqlite_adapter.rb:275:in `select'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/database_statements.rb:7:in `select_all_without_query_cache'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/connection_adapters/abstract/query_cache.rb:62:in `select_all'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:635:in `find_by_sql'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:1490:in `find_every'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb:589:in `find'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/has_many_through_association.rb:73:in `find_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_collection.rb:344:in `load_target'
	from /Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations/association_proxy.rb:139:in `inspect'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:298:in `output_value'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:151:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:259:in `signal_status'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:147:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:146:in `eval_input'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:70:in `start'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `catch'
	from /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/irb.rb:69:in `start'
&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2009-02-07T04:05:20+00:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2009-02-07T04:05:22+00:00</updated-at>
      <user-id type="integer">37950</user-id>
      <version type="integer">1</version>
      <user-name>Andrew Roth</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>+1 currently on a project where we have to monkey patch column_alias to get this to work correctly.  Why it's aliasing off the current connection and not the reflected one seems to be a bug.
Patch below
@@@
module ActiveRecord::Associations::ClassMethods
  def column_aliases(join_dependency)
    join_dependency.joins.collect{|join| join.column_names_with_alias.collect{|column_name, aliased_name|
      if join.respond_to?(:reflection)
        &quot;#{join.reflection.klass.connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&quot;
      else
        &quot;#{connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&quot;
      end }}.flatten.join(&quot;, &quot;)
  end
end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;+1 currently on a project where we have to monkey patch
column_alias to get this to work correctly. Why it's aliasing off
the current connection and not the reflected one seems to be a bug.
Patch below&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
module ActiveRecord::Associations::ClassMethods
  def column_aliases(join_dependency)
    join_dependency.joins.collect{|join| join.column_names_with_alias.collect{|column_name, aliased_name|
      if join.respond_to?(:reflection)
        &amp;quot;#{join.reflection.klass.connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&amp;quot;
      else
        &amp;quot;#{connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&amp;quot;
      end }}.flatten.join(&amp;quot;, &amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2009-03-13T17:45:31+00:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2009-03-13T17:45:36+00:00</updated-at>
      <user-id type="integer">10551</user-id>
      <version type="integer">2</version>
      <user-name>scott</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Sorry forgot to mention had to fix quote_table_name (for Mysql) to include the db name automatically, we originally hoped that would take care of it all.
@@@
class ActiveRecord::ConnectionAdapters::MysqlAdapter
  def database
    @connection_options[3]
  end
  
  def quote_table_name(name)
        if name.index(&quot;.&quot;).nil?
          name = database + &quot;.&quot; + name 
        end
        @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')
  end
end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;Sorry forgot to mention had to fix quote_table_name (for Mysql)
to include the db name automatically, we originally hoped that
would take care of it all.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
class ActiveRecord::ConnectionAdapters::MysqlAdapter
  def database
    @connection_options[3]
  end
  
  def quote_table_name(name)
        if name.index(&amp;quot;.&amp;quot;).nil?
          name = database + &amp;quot;.&amp;quot; + name 
        end
        @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2009-03-13T17:48:30+00:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2009-03-13T17:48:33+00:00</updated-at>
      <user-id type="integer">10551</user-id>
      <version type="integer">3</version>
      <user-name>scott</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Yea it's been a fun week, you are probably gonna need this to fix the table names as well
@@@
class ActiveRecord::Associations::ClassMethods::JoinDependency::JoinAssociation  
  def table_alias_for(table_name, table_alias)
        &quot;#{reflection.klass.connection.quote_table_name(table_name)} #{table_alias if table_name != table_alias}&quot;.strip
  end
end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;Yea it's been a fun week, you are probably gonna need this to
fix the table names as well&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
class ActiveRecord::Associations::ClassMethods::JoinDependency::JoinAssociation  
  def table_alias_for(table_name, table_alias)
        &amp;quot;#{reflection.klass.connection.quote_table_name(table_name)} #{table_alias if table_name != table_alias}&amp;quot;.strip
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2009-03-16T23:51:28+00:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2009-03-16T23:51:30+00:00</updated-at>
      <user-id type="integer">10551</user-id>
      <version type="integer">4</version>
      <user-name>scott</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I am also having problems with this, and cannot find my way around active record enough to figure it out. The issue that I am having is if it is being used for an order, the join still fails.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I am also having problems with this, and cannot find my way
around active record enough to figure it out. The issue that I am
having is if it is being used for an order, the join still
fails.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2009-05-28T20:35:04+01:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2009-05-28T20:35:08+01:00</updated-at>
      <user-id type="integer">17743</user-id>
      <version type="integer">5</version>
      <user-name>jonbro (at gmail)</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>[[bulk edit](/projects/8994/bulk_edits/19097)]</body>
      <body-html>&lt;div&gt;&lt;p&gt;[&lt;a href=&quot;/projects/8994/bulk_edits/19097&quot;&gt;bulk edit&lt;/a&gt;]&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-05-04T18:48:39+01:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- 
:milestone: 9903
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2010-05-04T18:48:39+01:00</updated-at>
      <user-id type="integer">85</user-id>
      <version type="integer">6</version>
      <user-name>Jeremy Kemper</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>3.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>This issue has been automatically marked as stale because it has not been commented on for at least three months.

The resources of the Rails core team are limited, and so we are asking for your help. If you can still reproduce this error on the 3-0-stable branch or on master, please reply with all of the information you have about it and add &quot;[state:open]&quot; to your comment. This will reopen the ticket for review. Likewise, if you feel that this is a very important feature for Rails to include, please reply with your explanation so we can consider it.

Thank you for all your contributions, and we hope you will understand this step to focus our efforts where they are most helpful.</body>
      <body-html>&lt;div&gt;&lt;p&gt;This issue has been automatically marked as stale because it has
not been commented on for at least three months.&lt;/p&gt;
&lt;p&gt;The resources of the Rails core team are limited, and so we are
asking for your help. If you can still reproduce this error on the
3-0-stable branch or on master, please reply with all of the
information you have about it and add &quot;[state:open]&quot; to your
comment. This will reopen the ticket for review. Likewise, if you
feel that this is a very important feature for Rails to include,
please reply with your explanation so we can consider it.&lt;/p&gt;
&lt;p&gt;Thank you for all your contributions, and we hope you will
understand this step to focus our efforts where they are most
helpful.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-02T16:41:39+00:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- 
:priority: 0
:state: new
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">1167</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2011-02-02T17:39:56+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">7</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>3.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body nil="true"></body>
      <body-html nil="true"></body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-02-02T16:41:41+00:00</created-at>
      <creator-id type="integer">37950</creator-id>
      <diffable-attributes type="yaml">--- 
:state: open
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">1902</number>
      <permalink>establish_connection-does-not-support-joins</permalink>
      <priority type="integer">1167</priority>
      <project-id type="integer">8994</project-id>
      <state>stale</state>
      <tag>establish_connection</tag>
      <title>establish_connection does not support joins</title>
      <updated-at type="datetime">2011-02-02T17:40:28+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">8</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Andrew Roth</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1902</url>
      <milestone-title>3.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
  </versions>
</ticket>
