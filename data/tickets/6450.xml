<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer">15316</assigned-user-id>
  <attachments-count type="integer">0</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2011-02-21T14:04:55+00:00</created-at>
  <creator-id type="integer">22106</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer">71472</milestone-id>
  <number type="integer">6450</number>
  <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
  <priority type="integer">3</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>resolved</state>
  <tag>arel distinct postgresql</tag>
  <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
  <updated-at type="datetime">2011-04-22T04:49:47+01:00</updated-at>
  <user-id type="integer">17393</user-id>
  <version type="integer">11</version>
  <user-name>Repository</user-name>
  <creator-name>Szymon Nowak</creator-name>
  <assigned-user-name>Aaron Patterson</assigned-user-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
  <milestone-title>3.x</milestone-title>
  <priority-name>Low</priority-name>
  <original-body>For the following query
@@@
Country.select(&quot;DISTINCT ON(countries.id) countries.*&quot;).joins(:cities).order(&quot;countries.name ASC&quot;)
@@@

Arel generates the following SQL (in Visitors::PostgreSQL#visit_Arel_Nodes_SelectStatement):

@@@
SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0
@@@

However, it causes some problems:

@@@
ActiveRecord::StatementInvalid: PGError: ERROR:  column id_list.alias_0 does not exist
LINE 1: ...untry_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.al...
                                                             ^
: SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0
@@@

I'm no SQL expert, but I'm not sure why Arel generates subquery if DISTINCT ON is present if the following SQL works just fine:

@@@
SELECT DISTINCT ON(countries.id) countries.* FROM countries INNER JOIN cities ON cities.country_id = countries.id ORDER BY countries.id;
@@@</original-body>
  <latest-body>For the following query
@@@
Country.select(&quot;DISTINCT ON(countries.id) countries.*&quot;).joins(:cities).order(&quot;countries.name ASC&quot;)
@@@

Arel generates the following SQL (in Visitors::PostgreSQL#visit_Arel_Nodes_SelectStatement):

@@@
SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0
@@@

However, it causes some problems:

@@@
ActiveRecord::StatementInvalid: PGError: ERROR:  column id_list.alias_0 does not exist
LINE 1: ...untry_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.al...
                                                             ^
: SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0
@@@

I'm no SQL expert, but I'm not sure why Arel generates subquery if DISTINCT ON is present if the following SQL works just fine:

@@@
SELECT DISTINCT ON(countries.id) countries.* FROM countries INNER JOIN cities ON cities.country_id = countries.id ORDER BY countries.id;
@@@</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;For the following query&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Country.select(&quot;DISTINCT ON(countries.id) countries.*&quot;).joins(:cities).order(&quot;countries.name ASC&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Arel generates the following SQL (in
Visitors::PostgreSQL#visit_Arel_Nodes_SelectStatement):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;However, it causes some problems:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActiveRecord::StatementInvalid: PGError: ERROR:  column id_list.alias_0 does not exist
LINE 1: ...untry_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.al...
                                                             ^
: SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I'm no SQL expert, but I'm not sure why Arel generates subquery
if DISTINCT ON is present if the following SQL works just fine:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT DISTINCT ON(countries.id) countries.* FROM countries INNER JOIN cities ON cities.country_id = countries.id ORDER BY countries.id;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>For the following query
@@@
Country.select(&quot;DISTINCT ON(countries.id) countries.*&quot;).joins(:cities).order(&quot;countries.name ASC&quot;)
@@@

Arel generates the following SQL (in Visitors::PostgreSQL#visit_Arel_Nodes_SelectStatement):

@@@
SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0
@@@

However, it causes some problems:

@@@
ActiveRecord::StatementInvalid: PGError: ERROR:  column id_list.alias_0 does not exist
LINE 1: ...untry_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.al...
                                                             ^
: SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0
@@@

I'm no SQL expert, but I'm not sure why Arel generates subquery if DISTINCT ON is present if the following SQL works just fine:

@@@
SELECT DISTINCT ON(countries.id) countries.* FROM countries INNER JOIN cities ON cities.country_id = countries.id ORDER BY countries.id;
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;For the following query&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Country.select(&quot;DISTINCT ON(countries.id) countries.*&quot;).joins(:cities).order(&quot;countries.name ASC&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Arel generates the following SQL (in
Visitors::PostgreSQL#visit_Arel_Nodes_SelectStatement):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;However, it causes some problems:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActiveRecord::StatementInvalid: PGError: ERROR:  column id_list.alias_0 does not exist
LINE 1: ...untry_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.al...
                                                             ^
: SELECT * FROM (SELECT DISTINCT ON(countries.id) countries.* FROM &quot;countries&quot; INNER JOIN &quot;cities&quot; ON &quot;cities&quot;.&quot;country_id&quot; = &quot;countries&quot;.&quot;id&quot;) AS id_list ORDER BY id_list.alias_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I'm no SQL expert, but I'm not sure why Arel generates subquery
if DISTINCT ON is present if the following SQL works just fine:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT DISTINCT ON(countries.id) countries.* FROM countries INNER JOIN cities ON cities.country_id = countries.id ORDER BY countries.id;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-18T15:52:25+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-18T15:52:31+00:00</updated-at>
      <user-id type="integer">22106</user-id>
      <version type="integer">1</version>
      <user-name>Szymon Nowak</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Not sure if this is appropriate, and i'm no doctor, but i concur.

I need Arel to generate this SQL in postgres.
@@@ ruby
Discount.select(&quot;DISTINCT ON(email) \*&quot;).order(&quot;email, created_at DESC&quot;)
=&gt; SELECT DISTINCT ON (email) * FROM discounts ORDER BY email, created_at DESC
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;Not sure if this is appropriate, and i'm no doctor, but i
concur.&lt;/p&gt;
&lt;p&gt;I need Arel to generate this SQL in postgres.&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;ruby&quot;&gt;Discount.select(&quot;DISTINCT ON(email) *&quot;).order(&quot;email, created_at DESC&quot;)
=&amp;gt; SELECT DISTINCT ON (email) * FROM discounts ORDER BY email, created_at DESC&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-19T12:52:19+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-19T12:52:29+00:00</updated-at>
      <user-id type="integer">133187</user-id>
      <version type="integer">2</version>
      <user-name>23inhouse</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I ran across the same issue using Postgresql under Rails 3.0.4 and Ruby 1.9.2p0 2 months ago.  

I wanted to do this:

  scope :last_concerts,
    select(&quot;DISTINCT (concerts.artist_id)&quot;).
    joins(:event).
    where(&quot;result &lt;&gt; ? and result &lt;= ?&quot;, CONCERT_LOST, CONCERT_WON).
    order([&quot;concerts.artist_id&quot;, &quot;events.date DESC&quot;])

And ended up having to do it with find_by_sql:

  def self.last_concert
    find_by_sql(&quot;SELECT DISTINCT ON (artist_id) concerts.*
    FROM concerts INNER JOIN events ON events.id = concerts.event_id
    WHERE (result &lt;&gt; #{CONCERT_LOST} and result &lt;= #{CONCERT_WON})
    ORDER BY artist_id, events.date DESC;&quot;)
  end</body>
      <body-html>&lt;div&gt;&lt;p&gt;I ran across the same issue using Postgresql under Rails 3.0.4
and Ruby 1.9.2p0 2 months ago.&lt;br&gt;&lt;/p&gt;
&lt;p&gt;I wanted to do this:&lt;/p&gt;
&lt;p&gt;scope :last_concerts,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select(&quot;DISTINCT (concerts.artist_id)&quot;).
joins(:event).
where(&quot;result &amp;lt;&amp;gt; ? and result &amp;lt;= ?&quot;, CONCERT_LOST, CONCERT_WON).
order([&quot;concerts.artist_id&quot;, &quot;events.date DESC&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;And ended up having to do it with find_by_sql:&lt;/p&gt;
&lt;p&gt;def self.last_concert&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find_by_sql(&quot;SELECT DISTINCT ON (artist_id) concerts.*
FROM concerts INNER JOIN events ON events.id = concerts.event_id
WHERE (result &amp;lt;&amp;gt; #{CONCERT_LOST} and result &amp;lt;= #{CONCERT_WON})
ORDER BY artist_id, events.date DESC;&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;end&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-19T21:57:57+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-19T21:58:08+00:00</updated-at>
      <user-id type="integer">85496</user-id>
      <version type="integer">3</version>
      <user-name>Jon Atack</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I meant to write under Rails 3.0.3 ...</body>
      <body-html>&lt;div&gt;&lt;p&gt;I meant to write under Rails 3.0.3 ...&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-19T21:58:49+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-19T21:59:01+00:00</updated-at>
      <user-id type="integer">85496</user-id>
      <version type="integer">4</version>
      <user-name>Jon Atack</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>We're getting good results after overwriting arel method: https://github.com/rails/arel/blob/master/lib/arel/visitors/postgresql.rb#L9 to return just `super` in any case - not really sure why this subqueries are needed.
So after that change it's possibly to do in activerecord:

@@@ sql
select(&quot;DISTINCT ON (posts.author_id) posts.*&quot;).order(&quot;posts.author_id&quot;)
@@@

which can be chained with other `order` calls.</body>
      <body-html>&lt;div&gt;&lt;p&gt;We're getting good results after overwriting arel method:
&lt;a href=
&quot;https://github.com/rails/arel/blob/master/lib/arel/visitors/postgresql.rb#L9&quot;&gt;
https://github.com/rails/arel/blob/master/lib/arel/visitors/postgre...&lt;/a&gt;
to return just &lt;code&gt;super&lt;/code&gt; in any case - not really sure why
this subqueries are needed.&lt;br&gt;
So after that change it's possibly to do in activerecord:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;select(&quot;DISTINCT ON (posts.author_id) posts.*&quot;).order(&quot;posts.author_id&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;which can be chained with other &lt;code&gt;order&lt;/code&gt; calls.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-21T10:51:33+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-21T10:51:42+00:00</updated-at>
      <user-id type="integer">31422</user-id>
      <version type="integer">5</version>
      <user-name>Wojciech Wn&#281;trzak</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Replica Tag Watches sell at low prices. Buy Tag Heuer Replica Watches, Fake TAG Heuer Watches please come to our &lt;a href=&quot;http://www.replicawatchesi.com/tag-heuer-watches&quot;&gt;Replica Tag Heuer watches&lt;/a&gt;.Look no further for &lt;a href=&quot;http://www.replicawatchesi.com/&quot;&gt;replica watches&lt;/a&gt;, &lt;a href=&quot;http://www.replicawatchesi.com/&quot;&gt;replica rolex&lt;/a&gt;, &lt;a href=&quot;http://www.replicawatchesi.com/&quot;&gt;replica watches uk&lt;/a&gt;, &lt;a href=&quot;http://www.replicawatchesi.com/breitling-watches&quot;&gt;Replica Breitling watches&lt;/a&gt;, Swiss Replica Rolex, fake watch, and swiss replica watch.Buy Omega Watch, Omega Replicas, Alpha Omega Watches, Ladies Omega Replica Watches from our &lt;a href=&quot;http://www.replicawatchesi.com/omega-watches&quot;&gt;Replica Omega watches&lt;/a&gt; store.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Replica Tag Watches sell at low prices. Buy Tag Heuer Replica
Watches, Fake TAG Heuer Watches please come to our &lt;a href=
&quot;http://www.replicawatchesi.com/tag-heuer-watches&quot;&gt;Replica Tag
Heuer watches&lt;/a&gt;.Look no further for &lt;a href=
&quot;http://www.replicawatchesi.com/&quot;&gt;replica watches&lt;/a&gt;, &lt;a href=
&quot;http://www.replicawatchesi.com/&quot;&gt;replica rolex&lt;/a&gt;, &lt;a href=
&quot;http://www.replicawatchesi.com/&quot;&gt;replica watches uk&lt;/a&gt;, &lt;a href=
&quot;http://www.replicawatchesi.com/breitling-watches&quot;&gt;Replica
Breitling watches&lt;/a&gt;, Swiss Replica Rolex, fake watch, and swiss
replica watch.Buy Omega Watch, Omega Replicas, Alpha Omega Watches,
Ladies Omega Replica Watches from our &lt;a href=
&quot;http://www.replicawatchesi.com/omega-watches&quot;&gt;Replica Omega
watches&lt;/a&gt; store.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-21T13:56:59+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-21T14:04:55+00:00</updated-at>
      <user-id type="integer">138022</user-id>
      <version type="integer">6</version>
      <user-name>benben</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Just small update - it seems that the column in DISTINCT ON must match the first column in ORDER BY clause:

This works fine:

@@@ sql
SELECT DISTINCT ON(countries.name) countries.* FROM countries ORDER BY countries.name;
@@@

This causes error:

@@@ sql
SELECT DISTINCT ON(countries.id) countries.* FROM countries ORDER BY countries.name;
ERROR:  SELECT DISTINCT ON expressions must match initial ORDER BY expressions
LINE 1: SELECT DISTINCT ON(countries.id) countries.* FROM countries ...
@@@

According to PostgreSQL docs: `The DISTINCT ON expression(s) must match the leftmost ORDER BY expression(s).` So only if it's not the case, a subquery needs to be generated.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Just small update - it seems that the column in DISTINCT ON must
match the first column in ORDER BY clause:&lt;/p&gt;
&lt;p&gt;This works fine:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;SELECT DISTINCT ON(countries.name) countries.* FROM countries ORDER BY countries.name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;This causes error:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;sql&quot;&gt;SELECT DISTINCT ON(countries.id) countries.* FROM countries ORDER BY countries.name;
ERROR:  SELECT DISTINCT ON expressions must match initial ORDER BY expressions
LINE 1: SELECT DISTINCT ON(countries.id) countries.* FROM countries ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;According to PostgreSQL docs: &lt;code&gt;The DISTINCT ON
expression(s) must match the leftmost ORDER BY
expression(s).&lt;/code&gt; So only if it's not the case, a subquery
needs to be generated.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-24T10:03:43+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-02-24T10:03:54+00:00</updated-at>
      <user-id type="integer">22106</user-id>
      <version type="integer">7</version>
      <user-name>Szymon Nowak</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title nil="true"></milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I'd like to remove the automatic subselect generation.  It's a relic from ARel 1.0.

However, removing the subselect generation breaks tests in AR.  Specifically, it breaks queries like this: https://github.com/rails/rails/blob/3-0-stable/activerecord/test/cases/associations/inverse_associations_test.rb#L249

I think there are two ways to fix this:

1. If a user doesn't add the correct order by clause, add it automatically here: https://github.com/rails/rails/blob/3-0-stable/activerecord/lib/active_record/connection_adapters/postgresql_adapter.rb#L867-886

2. Don't add anything automatically, let the database blow up, and force the user to specify the column in the order clause.

Personally I lean towards #2 since there is less magic involved.  But either way, I think this should be fixed in Rails 3.1.

Thoughts?</body>
      <body-html>&lt;div&gt;&lt;p&gt;I'd like to remove the automatic subselect generation. It's a
relic from ARel 1.0.&lt;/p&gt;
&lt;p&gt;However, removing the subselect generation breaks tests in AR.
Specifically, it breaks queries like this: &lt;a href=
&quot;https://github.com/rails/rails/blob/3-0-stable/activerecord/test/cases/associations/inverse_associations_test.rb#L249&quot;&gt;
https://github.com/rails/rails/blob/3-0-stable/activerecord/test/ca...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I think there are two ways to fix this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;If a user doesn't add the correct order by clause, add it
automatically here: &lt;a href=
&quot;https://github.com/rails/rails/blob/3-0-stable/activerecord/lib/active_record/connection_adapters/postgresql_adapter.rb#L867-886&quot;&gt;
https://github.com/rails/rails/blob/3-0-stable/activerecord/lib/act...&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don't add anything automatically, let the database blow up, and
force the user to specify the column in the order clause.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Personally I lean towards &lt;a href=&quot;/projects/8994/tickets/2&quot;
title=&quot;Ticket #2&quot;&gt;#2&lt;/a&gt; since there is less magic involved. But
either way, I think this should be fixed in Rails 3.1.&lt;/p&gt;
&lt;p&gt;Thoughts?&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-03-22T23:30:08+00:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- 
:priority: 0
:milestone: 
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-03-22T23:30:22+00:00</updated-at>
      <user-id type="integer">15316</user-id>
      <version type="integer">8</version>
      <user-name>Aaron Patterson</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title>3.x</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I'm for #2 in a short term, because right now it doesn't work at all.

However, having e.g. the following requirement: &quot;Display the latest post posted by each user and sort the results by created_at&quot;, it's really not so easy to do.

If one does:
@@@
SELECT DISTINCT ON(user_id) * FROM posts ORDER BY user_id, created_at DESC;
@@@
it will display the latest post by each user, but the results will be ordered by user_id. So, the results need to be used as a subquery, which will be ordered by created_at DESC once more:
@@@
SELECT * FROM posts WHERE id IN (SELECT DISTINCT ON(user_id) id FROM posts ORDER BY user_id, created_at DESC) ORDER BY created_at DESC
@@@
which is probably exactly what ARel tries to do now.

So in a long term, it would be nice if ARel did all this stuff automatically, but it's probably really complicated to implement it properly, so the most important thing for now is just to make it work at all :)</body>
      <body-html>&lt;div&gt;&lt;p&gt;I'm for &lt;a href=&quot;/projects/8994/tickets/2&quot; title=
&quot;Ticket #2&quot;&gt;#2&lt;/a&gt; in a short term, because right now it doesn't
work at all.&lt;/p&gt;
&lt;p&gt;However, having e.g. the following requirement: &quot;Display the
latest post posted by each user and sort the results by
created_at&quot;, it's really not so easy to do.&lt;/p&gt;
&lt;p&gt;If one does:&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT DISTINCT ON(user_id) * FROM posts ORDER BY user_id, created_at DESC;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;it will display the latest post by each user, but the results
will be ordered by user_id. So, the results need to be used as a
subquery, which will be ordered by created_at DESC once
more:&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM posts WHERE id IN (SELECT DISTINCT ON(user_id) id FROM posts ORDER BY user_id, created_at DESC) ORDER BY created_at DESC&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;which is probably exactly what ARel tries to do now.&lt;/p&gt;
&lt;p&gt;So in a long term, it would be nice if ARel did all this stuff
automatically, but it's probably really complicated to implement it
properly, so the most important thing for now is just to make it
work at all :)&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-04-11T14:10:30+01:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-04-11T14:10:44+01:00</updated-at>
      <user-id type="integer">22106</user-id>
      <version type="integer">9</version>
      <user-name>Szymon Nowak</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title>3.x</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>&lt;a href=&quot;http://www.rolexreplicascollection.net/&quot;&gt;rolex watches&lt;/a&gt; are very common in our &lt;a href=&quot;http://www.rolexreplicascollection.net/audemars-piguet-watches-c-114.html&quot;&gt;Audemars Piguet Replicas&lt;/a&gt;  lifes, there are quite several well known &lt;a href=&quot;http://www.freereplicawatches.com&quot;&gt;wrist watches&lt;/a&gt;  brands, the majority &lt;a href=&quot;http://www.rolexreplicascollection.net/gucci-watches-c-117.html&quot;&gt;Gucci Replicas&lt;/a&gt;  of them are Swiss bands,  &lt;a href=&quot;http://www.rolexreplicascollection.net/panerai-watches-c-118.html&quot;&gt;Panerai Replicas&lt;/a&gt; ,and it is &lt;a href=&quot;http://www.rolexreplicascollection.net/omega-watches-c-127.html&quot;&gt;Omega Replicas&lt;/a&gt; unlikely, unless the &lt;a href=&quot;http://www.replica-watches-uk.net/&quot;&gt;replica watches&lt;/a&gt; 's owner is filthy rich and equally careless &lt;a href=&quot;http://www.replicawatches.uk.net/breitling-watches-c-11.html&quot;&gt;replica breitling&lt;/a&gt; with his, Even the highest quality, Some &lt;a href=&quot;http://www.replicawatches.uk.net/omega-watches-c-27.html&quot;&gt;replica omega&lt;/a&gt; are believed to be to acquire luxury wrist that are &lt;a href=&quot;http://www.replica-watches-uk.net/&quot;&gt;Replica Concord&lt;/a&gt; founded of gold or platinum or other high priced materials. placing on these wrist &lt;a href=&quot;http://www.replicawatches.uk.net/&quot;&gt;fake rolex&lt;/a&gt; certainly will make us stand out from other &lt;a href=&quot;http://www.replicawatches.uk.net/&quot;&gt;Swiss Replica Watch&lt;/a&gt; people.Does everyone can afford these genuine, &lt;a href=&quot;http://www.replicawatches.uk.net/tag-heuer-watches-c-35.html&quot;&gt;replica tag heuer&lt;/a&gt; Taking your or &lt;a href=&quot;http://www.replicawatches.uk.net/&quot;&gt;replica watch&lt;/a&gt; ? When should expensive &lt;a href=&quot;http://www.replicawatches.uk.net/&quot;&gt;replica watch uk&lt;/a&gt; , before you take your precious?</body>
      <body-html>&lt;div&gt;&lt;p&gt;&lt;a href=&quot;http://www.rolexreplicascollection.net/&quot;&gt;rolex
watches&lt;/a&gt; are very common in our &lt;a href=
&quot;http://www.rolexreplicascollection.net/audemars-piguet-watches-c-114.html&quot;&gt;
Audemars Piguet Replicas&lt;/a&gt; lifes, there are quite several well
known &lt;a href=&quot;http://www.freereplicawatches.com&quot;&gt;wrist watches&lt;/a&gt;
brands, the majority &lt;a href=
&quot;http://www.rolexreplicascollection.net/gucci-watches-c-117.html&quot;&gt;Gucci
Replicas&lt;/a&gt; of them are Swiss bands, &lt;a href=
&quot;http://www.rolexreplicascollection.net/panerai-watches-c-118.html&quot;&gt;
Panerai Replicas&lt;/a&gt; ,and it is &lt;a href=
&quot;http://www.rolexreplicascollection.net/omega-watches-c-127.html&quot;&gt;Omega
Replicas&lt;/a&gt; unlikely, unless the &lt;a href=
&quot;http://www.replica-watches-uk.net/&quot;&gt;replica watches&lt;/a&gt; 's owner
is filthy rich and equally careless &lt;a href=
&quot;http://www.replicawatches.uk.net/breitling-watches-c-11.html&quot;&gt;replica
breitling&lt;/a&gt; with his, Even the highest quality, Some &lt;a href=
&quot;http://www.replicawatches.uk.net/omega-watches-c-27.html&quot;&gt;replica
omega&lt;/a&gt; are believed to be to acquire luxury wrist that are
&lt;a href=&quot;http://www.replica-watches-uk.net/&quot;&gt;Replica Concord&lt;/a&gt;
founded of gold or platinum or other high priced materials. placing
on these wrist &lt;a href=&quot;http://www.replicawatches.uk.net/&quot;&gt;fake
rolex&lt;/a&gt; certainly will make us stand out from other &lt;a href=
&quot;http://www.replicawatches.uk.net/&quot;&gt;Swiss Replica Watch&lt;/a&gt;
people.Does everyone can afford these genuine, &lt;a href=
&quot;http://www.replicawatches.uk.net/tag-heuer-watches-c-35.html&quot;&gt;replica
tag heuer&lt;/a&gt; Taking your or &lt;a href=
&quot;http://www.replicawatches.uk.net/&quot;&gt;replica watch&lt;/a&gt; ? When should
expensive &lt;a href=&quot;http://www.replicawatches.uk.net/&quot;&gt;replica watch
uk&lt;/a&gt; , before you take your precious?&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-04-16T03:10:13+01:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-04-16T03:10:27+01:00</updated-at>
      <user-id type="integer">114903</user-id>
      <version type="integer">10</version>
      <user-name>laptopbatteries</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title>3.x</milestone-title>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">15316</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>(from [724a7866774c7847cc79b699ccf7da9fee72b154]) stop using distinct on for the unique id queries. [#6450 state:resolved]
https://github.com/rails/rails/commit/724a7866774c7847cc79b699ccf7da9fee72b154</body>
      <body-html>&lt;div&gt;&lt;p&gt;(from &lt;a href=
&quot;/projects/8994/changesets/724a7866774c7847cc79b699ccf7da9fee72b154&quot;
title=
&quot;Changeset [724a7866774c7847cc79b699ccf7da9fee72b154]&quot;&gt;[724a7866774c7847cc79b699ccf7da9fee72b154]&lt;/a&gt;)
stop using distinct on for the unique id queries. [&lt;a href=
&quot;/projects/8994/tickets/6450&quot; title=&quot;Ticket #6450&quot;&gt;#6450&lt;/a&gt;
state:resolved] &lt;a href=
&quot;https://github.com/rails/rails/commit/724a7866774c7847cc79b699ccf7da9fee72b154&quot;&gt;
https://github.com/rails/rails/commit/724a7866774c7847cc79b699ccf7d...&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-04-22T04:49:31+01:00</created-at>
      <creator-id type="integer">22106</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
</diffable-attributes>
      <milestone-id type="integer">71472</milestone-id>
      <number type="integer">6450</number>
      <permalink>arel-generates-invalid-sql-when-using-distinct-on-in-postgresql</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>resolved</state>
      <tag>arel distinct postgresql</tag>
      <title>Arel generates invalid SQL when using DISTINCT ON in PostgreSQL</title>
      <updated-at type="datetime">2011-04-22T04:49:47+01:00</updated-at>
      <user-id type="integer">17393</user-id>
      <version type="integer">11</version>
      <user-name>Repository</user-name>
      <creator-name>Szymon Nowak</creator-name>
      <assigned-user-name>Aaron Patterson</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/6450</url>
      <milestone-title>3.x</milestone-title>
      <priority-name>Low</priority-name>
    </version>
  </versions>
</ticket>
