From b6700056a3af9661c36fa697bf531015a9a9d3ff Mon Sep 17 00:00:00 2001
From: Sven Fuchs <svenfuchs@artweb-design.de>
Date: Thu, 19 Nov 2009 22:39:17 +0100
Subject: [PATCH] [i18n] update vendored I18n gem to version 0.2.2

---
 activesupport/lib/active_support/vendor.rb         |    4 +-
 .../active_support/vendor/i18n-0.1.3/MIT-LICENSE   |   20 -
 .../vendor/i18n-0.1.3/README.textile               |   20 -
 .../lib/active_support/vendor/i18n-0.1.3/Rakefile  |    5 -
 .../active_support/vendor/i18n-0.1.3/i18n.gemspec  |   27 -
 .../active_support/vendor/i18n-0.1.3/lib/i18n.rb   |  199 -------
 .../vendor/i18n-0.1.3/lib/i18n/backend/simple.rb   |  214 --------
 .../vendor/i18n-0.1.3/lib/i18n/exceptions.rb       |   53 --
 .../active_support/vendor/i18n-0.1.3/test/all.rb   |    5 -
 .../vendor/i18n-0.1.3/test/i18n_exceptions_test.rb |   99 ----
 .../vendor/i18n-0.1.3/test/i18n_test.rb            |  124 -----
 .../vendor/i18n-0.1.3/test/locale/en.rb            |    1 -
 .../vendor/i18n-0.1.3/test/locale/en.yml           |    3 -
 .../vendor/i18n-0.1.3/test/simple_backend_test.rb  |  567 --------------------
 .../active_support/vendor/i18n-0.2.2/lib/i18n.rb   |  229 ++++++++
 .../vendor/i18n-0.2.2/lib/i18n/backend/simple.rb   |  234 ++++++++
 .../vendor/i18n-0.2.2/lib/i18n/exceptions.rb       |   59 ++
 .../vendor/i18n-0.2.2/lib/i18n/string.rb           |   93 ++++
 18 files changed, 617 insertions(+), 1339 deletions(-)
 delete mode 100755 activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec
 delete mode 100755 activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb
 create mode 100755 activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/backend/simple.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/exceptions.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/string.rb

diff --git a/activesupport/lib/active_support/vendor.rb b/activesupport/lib/active_support/vendor.rb
index cf2af4a..97c33fe 100644
--- a/activesupport/lib/active_support/vendor.rb
+++ b/activesupport/lib/active_support/vendor.rb
@@ -21,8 +21,8 @@ rescue Gem::LoadError
 end
 
 begin
-  gem 'i18n', '>= 0.1.3'
+  gem 'i18n', '>= 0.2.2'
 rescue Gem::LoadError
-  $:.unshift "#{File.dirname(__FILE__)}/vendor/i18n-0.1.3/lib"
+  $:.unshift "#{File.dirname(__FILE__)}/vendor/i18n-0.2.2/lib"
 end
 require 'i18n'
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE b/activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE
deleted file mode 100755
index ed8e9ee..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE
+++ /dev/null
@@ -1,20 +0,0 @@
-Copyright (c) 2008 The Ruby I18n team
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile b/activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile
deleted file mode 100644
index a07fc84..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile
+++ /dev/null
@@ -1,20 +0,0 @@
-h1. Ruby I18n gem
-
-I18n and localization solution for Ruby.
-
-For information please refer to http://rails-i18n.org
-
-h2. Authors
-
-* "Matt Aimonetti":http://railsontherun.com
-* "Sven Fuchs":http://www.artweb-design.de
-* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
-* "Saimon Moore":http://saimonmoore.net
-* "Stephan Soller":http://www.arkanis-development.de
-
-h2. License
-
-MIT License. See the included MIT-LICENCE file.
-
-
-
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile b/activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile
deleted file mode 100644
index 2164e13..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile
+++ /dev/null
@@ -1,5 +0,0 @@
-task :default => [:test]
-
-task :test do
-  ruby "test/all.rb"
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec b/activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec
deleted file mode 100644
index f102689..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec
+++ /dev/null
@@ -1,27 +0,0 @@
-Gem::Specification.new do |s|
-  s.name = "i18n"
-  s.version = "0.1.3"
-  s.date = "2009-01-09"
-  s.summary = "Internationalization support for Ruby"
-  s.email = "rails-i18n@googlegroups.com"
-  s.homepage = "http://rails-i18n.org"
-  s.description = "Add Internationalization support to your Ruby application."
-  s.has_rdoc = false
-  s.authors = ['Sven Fuchs', 'Joshua Harvey', 'Matt Aimonetti', 'Stephan Soller', 'Saimon Moore']
-  s.files = [
-    'i18n.gemspec',
-    'lib/i18n/backend/simple.rb',
-    'lib/i18n/exceptions.rb',
-    'lib/i18n.rb',
-    'MIT-LICENSE',
-    'README.textile'
-  ]
-  s.test_files = [
-    'test/all.rb',
-    'test/i18n_exceptions_test.rb',
-    'test/i18n_test.rb',
-    'test/locale/en.rb',
-    'test/locale/en.yml',
-    'test/simple_backend_test.rb'
-  ]
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb
deleted file mode 100755
index 76361be..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb
+++ /dev/null
@@ -1,199 +0,0 @@
-# Authors::   Matt Aimonetti (http://railsontherun.com/),
-#             Sven Fuchs (http://www.artweb-design.de),
-#             Joshua Harvey (http://www.workingwithrails.com/person/759-joshua-harvey),
-#             Saimon Moore (http://saimonmoore.net),
-#             Stephan Soller (http://www.arkanis-development.de/)
-# Copyright:: Copyright (c) 2008 The Ruby i18n Team
-# License::   MIT
-require 'i18n/backend/simple'
-require 'i18n/exceptions'
-
-module I18n
-  @@backend = nil
-  @@load_path = nil
-  @@default_locale = :'en'
-  @@exception_handler = :default_exception_handler
-
-  class << self
-    # Returns the current backend. Defaults to +Backend::Simple+.
-    def backend
-      @@backend ||= Backend::Simple.new
-    end
-
-    # Sets the current backend. Used to set a custom backend.
-    def backend=(backend)
-      @@backend = backend
-    end
-
-    # Returns the current default locale. Defaults to :'en'
-    def default_locale
-      @@default_locale
-    end
-
-    # Sets the current default locale. Used to set a custom default locale.
-    def default_locale=(locale)
-      @@default_locale = locale
-    end
-
-    # Returns the current locale. Defaults to I18n.default_locale.
-    def locale
-      Thread.current[:locale] ||= default_locale
-    end
-
-    # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
-    def locale=(locale)
-      Thread.current[:locale] = locale
-    end
-
-    # Returns an array of locales for which translations are available
-    def available_locales
-      backend.available_locales
-    end
-
-    # Sets the exception handler.
-    def exception_handler=(exception_handler)
-      @@exception_handler = exception_handler
-    end
-
-    # Allow clients to register paths providing translation data sources. The
-    # backend defines acceptable sources.
-    #
-    # E.g. the provided SimpleBackend accepts a list of paths to translation
-    # files which are either named *.rb and contain plain Ruby Hashes or are
-    # named *.yml and contain YAML data. So for the SimpleBackend clients may
-    # register translation files like this:
-    #   I18n.load_path << 'path/to/locale/en.yml'
-    def load_path
-      @@load_path ||= []
-    end
-
-    # Sets the load path instance. Custom implementations are expected to
-    # behave like a Ruby Array.
-    def load_path=(load_path)
-      @@load_path = load_path
-    end
-
-    # Tells the backend to reload translations. Used in situations like the
-    # Rails development environment. Backends can implement whatever strategy
-    # is useful.
-    def reload!
-      backend.reload!
-    end
-
-    # Translates, pluralizes and interpolates a given key using a given locale,
-    # scope, and default, as well as interpolation values.
-    #
-    # *LOOKUP*
-    #
-    # Translation data is organized as a nested hash using the upper-level keys
-    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
-    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
-    #
-    # Translations can be looked up at any level of this hash using the key argument
-    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
-    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
-    #
-    # Key can be either a single key or a dot-separated key (both Strings and Symbols
-    # work). <em>E.g.</em>, the short format can be looked up using both:
-    #   I18n.t 'date.formats.short'
-    #   I18n.t :'date.formats.short'
-    #
-    # Scope can be either a single key, a dot-separated key or an array of keys
-    # or dot-separated keys. Keys and scopes can be combined freely. So these
-    # examples will all look up the same short date format:
-    #   I18n.t 'date.formats.short'
-    #   I18n.t 'formats.short', :scope => 'date'
-    #   I18n.t 'short', :scope => 'date.formats'
-    #   I18n.t 'short', :scope => %w(date formats)
-    #
-    # *INTERPOLATION*
-    #
-    # Translations can contain interpolation variables which will be replaced by
-    # values passed to #translate as part of the options hash, with the keys matching
-    # the interpolation variable names.
-    #
-    # <em>E.g.</em>, with a translation <tt>:foo => "foo {{bar}}"</tt> the option
-    # value for the key +bar+ will be interpolated into the translation:
-    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
-    #
-    # *PLURALIZATION*
-    #
-    # Translation data can contain pluralized translations. Pluralized translations
-    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
-    #
-    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
-    # pluralization rules. Other algorithms can be supported by custom backends.
-    #
-    # This returns the singular version of a pluralized translation:
-    #   I18n.t :foo, :count => 1 # => 'Foo'
-    #
-    # These both return the plural version of a pluralized translation:
-    #   I18n.t :foo, :count => 0 # => 'Foos'
-    #   I18n.t :foo, :count => 2 # => 'Foos'
-    #
-    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
-    # <em>E.g.</em>, with the translation
-    # <tt>:foo => ['{{count}} foo', '{{count}} foos']</tt>, count will
-    # be interpolated to the pluralized translation:
-    #   I18n.t :foo, :count => 1 # => '1 foo'
-    #
-    # *DEFAULTS*
-    #
-    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
-    #   I18n.t :foo, :default => 'default'
-    #
-    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
-    # translation for <tt>:foo</tt> was found:
-    #   I18n.t :foo, :default => :bar
-    #
-    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
-    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
-    #   I18n.t :foo, :default => [:bar, 'default']
-    #
-    # <b>BULK LOOKUP</b>
-    #
-    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
-    #   I18n.t [:foo, :bar]
-    #
-    # Can be used with dot-separated nested keys:
-    #   I18n.t [:'baz.foo', :'baz.bar']
-    #
-    # Which is the same as using a scope option:
-    #   I18n.t [:foo, :bar], :scope => :baz
-    def translate(key, options = {})
-      locale = options.delete(:locale) || I18n.locale
-      backend.translate(locale, key, options)
-    rescue I18n::ArgumentError => e
-      raise e if options[:raise]
-      send(@@exception_handler, e, locale, key, options)
-    end
-    alias :t :translate
-
-    # Localizes certain objects, such as dates and numbers to local formatting.
-    def localize(object, options = {})
-      locale = options[:locale] || I18n.locale
-      format = options[:format] || :default
-      backend.localize(locale, object, format)
-    end
-    alias :l :localize
-
-  protected
-    # Handles exceptions raised in the backend. All exceptions except for
-    # MissingTranslationData exceptions are re-raised. When a MissingTranslationData
-    # was caught and the option :raise is not set the handler returns an error
-    # message string containing the key/scope.
-    def default_exception_handler(exception, locale, key, options)
-      return exception.message if MissingTranslationData === exception
-      raise exception
-    end
-
-    # Merges the given locale, key and scope into a single array of keys.
-    # Splits keys that contain dots into multiple keys. Makes sure all
-    # keys are Symbols.
-    def normalize_translation_keys(locale, key, scope)
-      keys = [locale] + Array(scope) + [key]
-      keys = keys.map { |k| k.to_s.split(/\./) }
-      keys.flatten.map { |k| k.to_sym }
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb
deleted file mode 100644
index c09acd7..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb
+++ /dev/null
@@ -1,214 +0,0 @@
-require 'yaml'
-
-module I18n
-  module Backend
-    class Simple
-      INTERPOLATION_RESERVED_KEYS = %w(scope default)
-      MATCH = /(\\\\)?\{\{([^\}]+)\}\}/
-
-      # Accepts a list of paths to translation files. Loads translations from
-      # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
-      # for details.
-      def load_translations(*filenames)
-        filenames.each { |filename| load_file(filename) }
-      end
-
-      # Stores translations for the given locale in memory.
-      # This uses a deep merge for the translations hash, so existing
-      # translations will be overwritten by new ones only at the deepest
-      # level of the hash.
-      def store_translations(locale, data)
-        merge_translations(locale, data)
-      end
-
-      def translate(locale, key, options = {})
-        raise InvalidLocale.new(locale) if locale.nil?
-        return key.map { |k| translate(locale, k, options) } if key.is_a? Array
-
-        reserved = :scope, :default
-        count, scope, default = options.values_at(:count, *reserved)
-        options.delete(:default)
-        values = options.reject { |name, value| reserved.include?(name) }
-
-        entry = lookup(locale, key, scope)
-        if entry.nil?
-          entry = default(locale, default, options)
-          if entry.nil?
-            raise(I18n::MissingTranslationData.new(locale, key, options))
-          end
-        end
-        entry = pluralize(locale, entry, count)
-        entry = interpolate(locale, entry, values)
-        entry
-      end
-
-      # Acts the same as +strftime+, but returns a localized version of the
-      # formatted date string. Takes a key from the date/time formats
-      # translations as a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
-      def localize(locale, object, format = :default)
-        raise ArgumentError, "Object must be a Date, DateTime or Time object. #{object.inspect} given." unless object.respond_to?(:strftime)
-
-        type = object.respond_to?(:sec) ? 'time' : 'date'
-        # TODO only translate these if format is a String?
-        formats = translate(locale, :"#{type}.formats")
-        format = formats[format.to_sym] if formats && formats[format.to_sym]
-        # TODO raise exception unless format found?
-        format = format.to_s.dup
-
-        # TODO only translate these if the format string is actually present
-        # TODO check which format strings are present, then bulk translate then, then replace them
-        format.gsub!(/%a/, translate(locale, :"date.abbr_day_names")[object.wday])
-        format.gsub!(/%A/, translate(locale, :"date.day_names")[object.wday])
-        format.gsub!(/%b/, translate(locale, :"date.abbr_month_names")[object.mon])
-        format.gsub!(/%B/, translate(locale, :"date.month_names")[object.mon])
-        format.gsub!(/%p/, translate(locale, :"time.#{object.hour < 12 ? :am : :pm}")) if object.respond_to? :hour
-        object.strftime(format)
-      end
-
-      def initialized?
-        @initialized ||= false
-      end
-
-      # Returns an array of locales for which translations are available
-      def available_locales
-        init_translations unless initialized?
-        translations.keys
-      end
-
-      def reload!
-        @initialized = false
-        @translations = nil
-      end
-
-      protected
-        def init_translations
-          load_translations(*I18n.load_path.flatten)
-          @initialized = true
-        end
-
-        def translations
-          @translations ||= {}
-        end
-
-        # Looks up a translation from the translations hash. Returns nil if
-        # eiher key is nil, or locale, scope or key do not exist as a key in the
-        # nested translations hash. Splits keys or scopes containing dots
-        # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
-        # <tt>%w(currency format)</tt>.
-        def lookup(locale, key, scope = [])
-          return unless key
-          init_translations unless initialized?
-          keys = I18n.send(:normalize_translation_keys, locale, key, scope)
-          keys.inject(translations) do |result, k|
-            if (x = result[k.to_sym]).nil?
-              return nil
-            else
-              x
-            end
-          end
-        end
-
-        # Evaluates a default translation.
-        # If the given default is a String it is used literally. If it is a Symbol
-        # it will be translated with the given options. If it is an Array the first
-        # translation yielded will be returned.
-        #
-        # <em>I.e.</em>, <tt>default(locale, [:foo, 'default'])</tt> will return +default+ if
-        # <tt>translate(locale, :foo)</tt> does not yield a result.
-        def default(locale, default, options = {})
-          case default
-            when String then default
-            when Symbol then translate locale, default, options
-            when Array  then default.each do |obj|
-              result = default(locale, obj, options.dup) and return result
-            end and nil
-          end
-        rescue MissingTranslationData
-          nil
-        end
-
-        # Picks a translation from an array according to English pluralization
-        # rules. It will pick the first translation if count is not equal to 1
-        # and the second translation if it is equal to 1. Other backends can
-        # implement more flexible or complex pluralization rules.
-        def pluralize(locale, entry, count)
-          return entry unless entry.is_a?(Hash) and count
-          # raise InvalidPluralizationData.new(entry, count) unless entry.is_a?(Hash)
-          key = :zero if count == 0 && entry.has_key?(:zero)
-          key ||= count == 1 ? :one : :other
-          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
-          entry[key]
-        end
-
-        # Interpolates values into a given string.
-        #
-        #   interpolate "file {{file}} opened by \\{{user}}", :file => 'test.txt', :user => 'Mr. X'
-        #   # => "file test.txt opened by {{user}}"
-        #
-        # Note that you have to double escape the <tt>\\</tt> when you want to escape
-        # the <tt>{{...}}</tt> key in a string (once for the string and once for the
-        # interpolation).
-        def interpolate(locale, string, values = {})
-          return string unless string.is_a?(String)
-
-          string.gsub(MATCH) do
-            escaped, pattern, key = $1, $2, $2.to_sym
-
-            if escaped
-              pattern
-            elsif INTERPOLATION_RESERVED_KEYS.include?(pattern)
-              raise ReservedInterpolationKey.new(pattern, string)
-            elsif !values.include?(key)
-              raise MissingInterpolationArgument.new(pattern, string)
-            else
-              values[key].to_s
-            end
-          end
-        end
-
-        # Loads a single translations file by delegating to #load_rb or
-        # #load_yml depending on the file extension and directly merges the
-        # data to the existing translations. Raises I18n::UnknownFileType
-        # for all other file extensions.
-        def load_file(filename)
-          type = File.extname(filename).tr('.', '').downcase
-          raise UnknownFileType.new(type, filename) unless respond_to?(:"load_#{type}")
-          data = send :"load_#{type}", filename # TODO raise a meaningful exception if this does not yield a Hash
-          data.each { |locale, d| merge_translations(locale, d) }
-        end
-
-        # Loads a plain Ruby translations file. eval'ing the file must yield
-        # a Hash containing translation data with locales as toplevel keys.
-        def load_rb(filename)
-          eval(IO.read(filename), binding, filename)
-        end
-
-        # Loads a YAML translations file. The data must have locales as
-        # toplevel keys.
-        def load_yml(filename)
-          YAML::load(IO.read(filename))
-        end
-
-        # Deep merges the given translations hash with the existing translations
-        # for the given locale
-        def merge_translations(locale, data)
-          locale = locale.to_sym
-          translations[locale] ||= {}
-          data = deep_symbolize_keys(data)
-
-          # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
-          merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
-          translations[locale].merge!(data, &merger)
-        end
-
-        # Return a new hash with all keys and nested keys converted to symbols.
-        def deep_symbolize_keys(hash)
-          hash.inject({}) { |result, (key, value)|
-            value = deep_symbolize_keys(value) if value.is_a? Hash
-            result[(key.to_sym rescue key) || key] = value
-            result
-          }
-        end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb
deleted file mode 100644
index b5cea7a..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb
+++ /dev/null
@@ -1,53 +0,0 @@
-module I18n
-  class ArgumentError < ::ArgumentError; end
-
-  class InvalidLocale < ArgumentError
-    attr_reader :locale
-    def initialize(locale)
-      @locale = locale
-      super "#{locale.inspect} is not a valid locale"
-    end
-  end
-
-  class MissingTranslationData < ArgumentError
-    attr_reader :locale, :key, :options
-    def initialize(locale, key, options)
-      @key, @locale, @options = key, locale, options
-      keys = I18n.send(:normalize_translation_keys, locale, key, options[:scope])
-      keys << 'no key' if keys.size < 2
-      super "translation missing: #{keys.join(', ')}"
-    end
-  end
-
-  class InvalidPluralizationData < ArgumentError
-    attr_reader :entry, :count
-    def initialize(entry, count)
-      @entry, @count = entry, count
-      super "translation data #{entry.inspect} can not be used with :count => #{count}"
-    end
-  end
-
-  class MissingInterpolationArgument < ArgumentError
-    attr_reader :key, :string
-    def initialize(key, string)
-      @key, @string = key, string
-      super "interpolation argument #{key} missing in #{string.inspect}"
-    end
-  end
-
-  class ReservedInterpolationKey < ArgumentError
-    attr_reader :key, :string
-    def initialize(key, string)
-      @key, @string = key, string
-      super "reserved key #{key.inspect} used in #{string.inspect}"
-    end
-  end
-
-  class UnknownFileType < ArgumentError
-    attr_reader :type, :filename
-    def initialize(type, filename)
-      @type, @filename = type, filename
-      super "can not load translations from #{filename}, the file type #{type} is not known"
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb
deleted file mode 100644
index 353712d..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-dir = File.dirname(__FILE__)
-require dir + '/i18n_test.rb'
-require dir + '/simple_backend_test.rb'
-require dir + '/i18n_exceptions_test.rb'
-# *require* dir + '/custom_backend_test.rb'
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb
deleted file mode 100644
index 4e78e71..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb
+++ /dev/null
@@ -1,99 +0,0 @@
-$:.unshift "lib"
-
-require 'rubygems'
-require 'test/unit'
-require 'i18n'
-require 'active_support'
-
-class I18nExceptionsTest < Test::Unit::TestCase
-  def test_invalid_locale_stores_locale
-    force_invalid_locale
-  rescue I18n::ArgumentError => e
-    assert_nil e.locale
-  end
-
-  def test_invalid_locale_message
-    force_invalid_locale
-  rescue I18n::ArgumentError => e
-    assert_equal 'nil is not a valid locale', e.message
-  end
-
-  def test_missing_translation_data_stores_locale_key_and_options
-    force_missing_translation_data
-  rescue I18n::ArgumentError => e
-    options = {:scope => :bar}
-    assert_equal 'de', e.locale
-    assert_equal :foo, e.key
-    assert_equal options, e.options
-  end
-
-  def test_missing_translation_data_message
-    force_missing_translation_data
-  rescue I18n::ArgumentError => e
-    assert_equal 'translation missing: de, bar, foo', e.message
-  end
-
-  def test_invalid_pluralization_data_stores_entry_and_count
-    force_invalid_pluralization_data
-  rescue I18n::ArgumentError => e
-    assert_equal [:bar], e.entry
-    assert_equal 1, e.count
-  end
-
-  def test_invalid_pluralization_data_message
-    force_invalid_pluralization_data
-  rescue I18n::ArgumentError => e
-    assert_equal 'translation data [:bar] can not be used with :count => 1', e.message
-  end
-
-  def test_missing_interpolation_argument_stores_key_and_string
-    force_missing_interpolation_argument
-  rescue I18n::ArgumentError => e
-    assert_equal 'bar', e.key
-    assert_equal "{{bar}}", e.string
-  end
-
-  def test_missing_interpolation_argument_message
-    force_missing_interpolation_argument
-  rescue I18n::ArgumentError => e
-    assert_equal 'interpolation argument bar missing in "{{bar}}"', e.message
-  end
-
-  def test_reserved_interpolation_key_stores_key_and_string
-    force_reserved_interpolation_key
-  rescue I18n::ArgumentError => e
-    assert_equal 'scope', e.key
-    assert_equal "{{scope}}", e.string
-  end
-
-  def test_reserved_interpolation_key_message
-    force_reserved_interpolation_key
-  rescue I18n::ArgumentError => e
-    assert_equal 'reserved key "scope" used in "{{scope}}"', e.message
-  end
-
-  private
-    def force_invalid_locale
-      I18n.backend.translate nil, :foo
-    end
-
-    def force_missing_translation_data
-      I18n.backend.store_translations 'de', :bar => nil
-      I18n.backend.translate 'de', :foo, :scope => :bar
-    end
-
-    def force_invalid_pluralization_data
-      I18n.backend.store_translations 'de', :foo => [:bar]
-      I18n.backend.translate 'de', :foo, :count => 1
-    end
-
-    def force_missing_interpolation_argument
-      I18n.backend.store_translations 'de', :foo => "{{bar}}"
-      I18n.backend.translate 'de', :foo, :baz => 'baz'
-    end
-
-    def force_reserved_interpolation_key
-      I18n.backend.store_translations 'de', :foo => "{{scope}}"
-      I18n.backend.translate 'de', :foo, :baz => 'baz'
-    end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb
deleted file mode 100644
index 2835ec4..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb
+++ /dev/null
@@ -1,124 +0,0 @@
-$:.unshift "lib"
-
-require 'rubygems'
-require 'test/unit'
-require 'i18n'
-require 'active_support'
-
-class I18nTest < Test::Unit::TestCase
-  def setup
-    I18n.backend.store_translations :'en', {
-      :currency => {
-        :format => {
-          :separator => '.',
-          :delimiter => ',',
-        }
-      }
-    }
-  end
-
-  def test_uses_simple_backend_set_by_default
-    assert I18n.backend.is_a?(I18n::Backend::Simple)
-  end
-
-  def test_can_set_backend
-    assert_nothing_raised{ I18n.backend = self }
-    assert_equal self, I18n.backend
-    I18n.backend = I18n::Backend::Simple.new
-  end
-
-  def test_uses_en_us_as_default_locale_by_default
-    assert_equal 'en', I18n.default_locale
-  end
-
-  def test_can_set_default_locale
-    assert_nothing_raised{ I18n.default_locale = 'de' }
-    assert_equal 'de', I18n.default_locale
-    I18n.default_locale = 'en'
-  end
-
-  def test_uses_default_locale_as_locale_by_default
-    assert_equal I18n.default_locale, I18n.locale
-  end
-
-  def test_can_set_locale_to_thread_current
-    assert_nothing_raised{ I18n.locale = 'de' }
-    assert_equal 'de', I18n.locale
-    assert_equal 'de', Thread.current[:locale]
-    I18n.locale = 'en'
-  end
-
-  def test_can_set_exception_handler
-    assert_nothing_raised{ I18n.exception_handler = :custom_exception_handler }
-    I18n.exception_handler = :default_exception_handler # revert it
-  end
-
-  def test_uses_custom_exception_handler
-    I18n.exception_handler = :custom_exception_handler
-    I18n.expects(:custom_exception_handler)
-    I18n.translate :bogus
-    I18n.exception_handler = :default_exception_handler # revert it
-  end
-
-  def test_delegates_translate_to_backend
-    I18n.backend.expects(:translate).with 'de', :foo, {}
-    I18n.translate :foo, :locale => 'de'
-  end
-
-  def test_delegates_localize_to_backend
-    I18n.backend.expects(:localize).with 'de', :whatever, :default
-    I18n.localize :whatever, :locale => 'de'
-  end
-
-  def test_translate_given_no_locale_uses_i18n_locale
-    I18n.backend.expects(:translate).with 'en', :foo, {}
-    I18n.translate :foo
-  end
-
-  def test_translate_on_nested_symbol_keys_works
-    assert_equal ".", I18n.t(:'currency.format.separator')
-  end
-
-  def test_translate_with_nested_string_keys_works
-    assert_equal ".", I18n.t('currency.format.separator')
-  end
-
-  def test_translate_with_array_as_scope_works
-    assert_equal ".", I18n.t(:separator, :scope => ['currency.format'])
-  end
-
-  def test_translate_with_array_containing_dot_separated_strings_as_scope_works
-    assert_equal ".", I18n.t(:separator, :scope => ['currency.format'])
-  end
-
-  def test_translate_with_key_array_and_dot_separated_scope_works
-    assert_equal [".", ","], I18n.t(%w(separator delimiter), :scope => 'currency.format')
-  end
-
-  def test_translate_with_dot_separated_key_array_and_scope_works
-    assert_equal [".", ","], I18n.t(%w(format.separator format.delimiter), :scope => 'currency')
-  end
-
-  def test_translate_with_options_using_scope_works
-    I18n.backend.expects(:translate).with('de', :precision, :scope => :"currency.format")
-    I18n.with_options :locale => 'de', :scope => :'currency.format' do |locale|
-      locale.t :precision
-    end
-  end
-
-  # def test_translate_given_no_args_raises_missing_translation_data
-  #   assert_equal "translation missing: en, no key", I18n.t
-  # end
-
-  def test_translate_given_a_bogus_key_raises_missing_translation_data
-    assert_equal "translation missing: en, bogus", I18n.t(:bogus)
-  end
-
-  def test_localize_nil_raises_argument_error
-    assert_raise(I18n::ArgumentError) { I18n.l nil }
-  end
-
-  def test_localize_object_raises_argument_error
-    assert_raise(I18n::ArgumentError) { I18n.l Object.new }
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb
deleted file mode 100644
index 6044ce1..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb
+++ /dev/null
@@ -1 +0,0 @@
-{:'en-Ruby' => {:foo => {:bar => "baz"}}}
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml
deleted file mode 100644
index 0b298c9..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml
+++ /dev/null
@@ -1,3 +0,0 @@
-en-Yaml:
-  foo:
-    bar: baz
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb
deleted file mode 100644
index a1696c7..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb
+++ /dev/null
@@ -1,567 +0,0 @@
-# encoding: utf-8
-$:.unshift "lib"
-
-require 'rubygems'
-require 'test/unit'
-require 'i18n'
-require 'time'
-require 'yaml'
-
-module I18nSimpleBackendTestSetup
-  def setup_backend
-    # backend_reset_translations!
-    @backend = I18n::Backend::Simple.new
-    @backend.store_translations 'en', :foo => {:bar => 'bar', :baz => 'baz'}
-    @locale_dir = File.dirname(__FILE__) + '/locale'
-  end
-  alias :setup :setup_backend
-
-  # def backend_reset_translations!
-  #   I18n::Backend::Simple::ClassMethods.send :class_variable_set, :@@translations, {}
-  # end
-
-  def backend_get_translations
-    # I18n::Backend::Simple::ClassMethods.send :class_variable_get, :@@translations
-    @backend.instance_variable_get :@translations
-  end
-
-  def add_datetime_translations
-    @backend.store_translations :'de', {
-      :date => {
-        :formats => {
-          :default => "%d.%m.%Y",
-          :short => "%d. %b",
-          :long => "%d. %B %Y",
-        },
-        :day_names => %w(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag),
-        :abbr_day_names => %w(So Mo Di Mi Do Fr  Sa),
-        :month_names => %w(Januar Februar März April Mai Juni Juli August September Oktober November Dezember).unshift(nil),
-        :abbr_month_names => %w(Jan Feb Mar Apr Mai Jun Jul Aug Sep Okt Nov Dez).unshift(nil),
-        :order => [:day, :month, :year]
-      },
-      :time => {
-        :formats => {
-          :default => "%a, %d. %b %Y %H:%M:%S %z",
-          :short => "%d. %b %H:%M",
-          :long => "%d. %B %Y %H:%M",
-        },
-        :am => 'am',
-        :pm => 'pm'
-      },
-      :datetime => {
-        :distance_in_words => {
-          :half_a_minute => 'half a minute',
-          :less_than_x_seconds => {
-            :one => 'less than 1 second',
-            :other => 'less than {{count}} seconds'
-          },
-          :x_seconds => {
-            :one => '1 second',
-            :other => '{{count}} seconds'
-          },
-          :less_than_x_minutes => {
-            :one => 'less than a minute',
-            :other => 'less than {{count}} minutes'
-          },
-          :x_minutes => {
-            :one => '1 minute',
-            :other => '{{count}} minutes'
-          },
-          :about_x_hours => {
-            :one => 'about 1 hour',
-            :other => 'about {{count}} hours'
-          },
-          :x_days => {
-            :one => '1 day',
-            :other => '{{count}} days'
-          },
-          :about_x_months => {
-            :one => 'about 1 month',
-            :other => 'about {{count}} months'
-          },
-          :x_months => {
-            :one => '1 month',
-            :other => '{{count}} months'
-          },
-          :about_x_years => {
-            :one => 'about 1 year',
-            :other => 'about {{count}} year'
-          },
-          :over_x_years => {
-            :one => 'over 1 year',
-            :other => 'over {{count}} years'
-          }
-        }
-      }
-    }
-  end
-end
-
-class I18nSimpleBackendTranslationsTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_store_translations_adds_translations # no, really :-)
-    @backend.store_translations :'en', :foo => 'bar'
-    assert_equal Hash[:'en', {:foo => 'bar'}], backend_get_translations
-  end
-
-  def test_store_translations_deep_merges_translations
-    @backend.store_translations :'en', :foo => {:bar => 'bar'}
-    @backend.store_translations :'en', :foo => {:baz => 'baz'}
-    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], backend_get_translations
-  end
-
-  def test_store_translations_forces_locale_to_sym
-    @backend.store_translations 'en', :foo => 'bar'
-    assert_equal Hash[:'en', {:foo => 'bar'}], backend_get_translations
-  end
-
-  def test_store_translations_converts_keys_to_symbols
-    # backend_reset_translations!
-    @backend.store_translations 'en', 'foo' => {'bar' => 'bar', 'baz' => 'baz'}
-    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], backend_get_translations
-  end
-end
-
-class I18nSimpleBackendAvailableLocalesTest < Test::Unit::TestCase
-  def test_available_locales
-    @backend = I18n::Backend::Simple.new
-    @backend.store_translations 'de', :foo => 'bar'
-    @backend.store_translations 'en', :foo => 'foo'
-
-    assert_equal ['de', 'en'], @backend.available_locales.map{|locale| locale.to_s }.sort
-  end
-end
-
-class I18nSimpleBackendTranslateTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_translate_calls_lookup_with_locale_given
-    @backend.expects(:lookup).with('de', :bar, [:foo]).returns 'bar'
-    @backend.translate 'de', :bar, :scope => [:foo]
-  end
-
-  def test_given_no_keys_it_returns_the_default
-    assert_equal 'default', @backend.translate('en', nil, :default => 'default')
-  end
-
-  def test_translate_given_a_symbol_as_a_default_translates_the_symbol
-    assert_equal 'bar', @backend.translate('en', nil, :scope => [:foo], :default => :bar)
-  end
-
-  def test_translate_given_an_array_as_default_uses_the_first_match
-    assert_equal 'bar', @backend.translate('en', :does_not_exist, :scope => [:foo], :default => [:does_not_exist_2, :bar])
-  end
-
-  def test_translate_given_an_array_of_inexistent_keys_it_raises_missing_translation_data
-    assert_raise I18n::MissingTranslationData do
-      @backend.translate('en', :does_not_exist, :scope => [:foo], :default => [:does_not_exist_2, :does_not_exist_3])
-    end
-  end
-
-  def test_translate_an_array_of_keys_translates_all_of_them
-    assert_equal %w(bar baz), @backend.translate('en', [:bar, :baz], :scope => [:foo])
-  end
-
-  def test_translate_calls_pluralize
-    @backend.expects(:pluralize).with 'en', 'bar', 1
-    @backend.translate 'en', :bar, :scope => [:foo], :count => 1
-  end
-
-  def test_translate_calls_interpolate
-    @backend.expects(:interpolate).with 'en', 'bar', {}
-    @backend.translate 'en', :bar, :scope => [:foo]
-  end
-
-  def test_translate_calls_interpolate_including_count_as_a_value
-    @backend.expects(:interpolate).with 'en', 'bar', {:count => 1}
-    @backend.translate 'en', :bar, :scope => [:foo], :count => 1
-  end
-
-  def test_translate_given_nil_as_a_locale_raises_an_argument_error
-    assert_raise(I18n::InvalidLocale){ @backend.translate nil, :bar }
-  end
-
-  def test_translate_with_a_bogus_key_and_no_default_raises_missing_translation_data
-    assert_raise(I18n::MissingTranslationData){ @backend.translate 'de', :bogus }
-  end
-end
-
-class I18nSimpleBackendLookupTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  # useful because this way we can use the backend with no key for interpolation/pluralization
-  def test_lookup_given_nil_as_a_key_returns_nil
-    assert_nil @backend.send(:lookup, 'en', nil)
-  end
-
-  def test_lookup_given_nested_keys_looks_up_a_nested_hash_value
-    assert_equal 'bar', @backend.send(:lookup, 'en', :bar, [:foo])
-  end
-end
-
-class I18nSimpleBackendPluralizeTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_pluralize_given_nil_returns_the_given_entry
-    entry = {:one => 'bar', :other => 'bars'}
-    assert_equal entry, @backend.send(:pluralize, nil, entry, nil)
-  end
-
-  def test_pluralize_given_0_returns_zero_string_if_zero_key_given
-    assert_equal 'zero', @backend.send(:pluralize, nil, {:zero => 'zero', :one => 'bar', :other => 'bars'}, 0)
-  end
-
-  def test_pluralize_given_0_returns_plural_string_if_no_zero_key_given
-    assert_equal 'bars', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 0)
-  end
-
-  def test_pluralize_given_1_returns_singular_string
-    assert_equal 'bar', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 1)
-  end
-
-  def test_pluralize_given_2_returns_plural_string
-    assert_equal 'bars', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 2)
-  end
-
-  def test_pluralize_given_3_returns_plural_string
-    assert_equal 'bars', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 3)
-  end
-
-  def test_interpolate_given_incomplete_pluralization_data_raises_invalid_pluralization_data
-    assert_raise(I18n::InvalidPluralizationData){ @backend.send(:pluralize, nil, {:one => 'bar'}, 2) }
-  end
-
-  # def test_interpolate_given_a_string_raises_invalid_pluralization_data
-  #   assert_raise(I18n::InvalidPluralizationData){ @backend.send(:pluralize, nil, 'bar', 2) }
-  # end
-  #
-  # def test_interpolate_given_an_array_raises_invalid_pluralization_data
-  #   assert_raise(I18n::InvalidPluralizationData){ @backend.send(:pluralize, nil, ['bar'], 2) }
-  # end
-end
-
-class I18nSimpleBackendInterpolateTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_interpolate_given_a_value_hash_interpolates_the_values_to_the_string
-    assert_equal 'Hi David!', @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => 'David')
-  end
-
-  def test_interpolate_given_a_value_hash_interpolates_into_unicode_string
-    assert_equal 'Häi David!', @backend.send(:interpolate, nil, 'Häi {{name}}!', :name => 'David')
-  end
-
-  def test_interpolate_given_an_unicode_value_hash_interpolates_to_the_string
-    assert_equal 'Hi ゆきひろ!', @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => 'ゆきひろ')
-  end
-
-  def test_interpolate_given_an_unicode_value_hash_interpolates_into_unicode_string
-    assert_equal 'こんにちは、ゆきひろさん!', @backend.send(:interpolate, nil, 'こんにちは、{{name}}さん!', :name => 'ゆきひろ')
-  end
-
-  if Kernel.const_defined?(:Encoding)
-    def test_interpolate_given_a_non_unicode_multibyte_value_hash_interpolates_into_a_string_with_the_same_encoding
-      assert_equal euc_jp('Hi ゆきひろ!'), @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => euc_jp('ゆきひろ'))
-    end
-
-    def test_interpolate_given_an_unicode_value_hash_into_a_non_unicode_multibyte_string_raises_encoding_compatibility_error
-      assert_raise(Encoding::CompatibilityError) do
-        @backend.send(:interpolate, nil, euc_jp('こんにちは、{{name}}さん!'), :name => 'ゆきひろ')
-      end
-    end
-
-    def test_interpolate_given_a_non_unicode_multibyte_value_hash_into_an_unicode_string_raises_encoding_compatibility_error
-      assert_raise(Encoding::CompatibilityError) do
-        @backend.send(:interpolate, nil, 'こんにちは、{{name}}さん!', :name => euc_jp('ゆきひろ'))
-      end
-    end
-  end
-
-  def test_interpolate_given_nil_as_a_string_returns_nil
-    assert_nil @backend.send(:interpolate, nil, nil, :name => 'David')
-  end
-
-  def test_interpolate_given_an_non_string_as_a_string_returns_nil
-    assert_equal [], @backend.send(:interpolate, nil, [], :name => 'David')
-  end
-
-  def test_interpolate_given_a_values_hash_with_nil_values_interpolates_the_string
-    assert_equal 'Hi !', @backend.send(:interpolate, nil, 'Hi {{name}}!', {:name => nil})
-  end
-
-  def test_interpolate_given_an_empty_values_hash_raises_missing_interpolation_argument
-    assert_raise(I18n::MissingInterpolationArgument) { @backend.send(:interpolate, nil, 'Hi {{name}}!', {}) }
-  end
-
-  def test_interpolate_given_a_string_containing_a_reserved_key_raises_reserved_interpolation_key
-    assert_raise(I18n::ReservedInterpolationKey) { @backend.send(:interpolate, nil, '{{default}}', {:default => nil}) }
-  end
-  
-  private
-  
-  def euc_jp(string)
-    string.encode!(Encoding::EUC_JP)
-  end
-end
-
-class I18nSimpleBackendLocalizeDateTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def setup
-    @backend = I18n::Backend::Simple.new
-    add_datetime_translations
-    @date = Date.new 2008, 1, 1
-  end
-
-  def test_translate_given_the_short_format_it_uses_it
-    assert_equal '01. Jan', @backend.localize('de', @date, :short)
-  end
-
-  def test_translate_given_the_long_format_it_uses_it
-    assert_equal '01. Januar 2008', @backend.localize('de', @date, :long)
-  end
-
-  def test_translate_given_the_default_format_it_uses_it
-    assert_equal '01.01.2008', @backend.localize('de', @date, :default)
-  end
-
-  def test_translate_given_a_day_name_format_it_returns_a_day_name
-    assert_equal 'Dienstag', @backend.localize('de', @date, '%A')
-  end
-
-  def test_translate_given_an_abbr_day_name_format_it_returns_an_abbrevated_day_name
-    assert_equal 'Di', @backend.localize('de', @date, '%a')
-  end
-
-  def test_translate_given_a_month_name_format_it_returns_a_month_name
-    assert_equal 'Januar', @backend.localize('de', @date, '%B')
-  end
-
-  def test_translate_given_an_abbr_month_name_format_it_returns_an_abbrevated_month_name
-    assert_equal 'Jan', @backend.localize('de', @date, '%b')
-  end
-
-  def test_translate_given_no_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @date }
-  end
-
-  def test_translate_given_an_unknown_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @date, '%x' }
-  end
-
-  def test_localize_nil_raises_argument_error
-    assert_raise(I18n::ArgumentError) { @backend.localize 'de', nil }
-  end
-
-  def test_localize_object_raises_argument_error
-    assert_raise(I18n::ArgumentError) { @backend.localize 'de', Object.new }
-  end
-end
-
-class I18nSimpleBackendLocalizeDateTimeTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def setup
-    @backend = I18n::Backend::Simple.new
-    add_datetime_translations
-    @morning = DateTime.new 2008, 1, 1, 6
-    @evening = DateTime.new 2008, 1, 1, 18
-  end
-
-  def test_translate_given_the_short_format_it_uses_it
-    assert_equal '01. Jan 06:00', @backend.localize('de', @morning, :short)
-  end
-
-  def test_translate_given_the_long_format_it_uses_it
-    assert_equal '01. Januar 2008 06:00', @backend.localize('de', @morning, :long)
-  end
-
-  def test_translate_given_the_default_format_it_uses_it
-    assert_equal 'Di, 01. Jan 2008 06:00:00 +0000', @backend.localize('de', @morning, :default)
-  end
-
-  def test_translate_given_a_day_name_format_it_returns_the_correct_day_name
-    assert_equal 'Dienstag', @backend.localize('de', @morning, '%A')
-  end
-
-  def test_translate_given_an_abbr_day_name_format_it_returns_the_correct_abbrevated_day_name
-    assert_equal 'Di', @backend.localize('de', @morning, '%a')
-  end
-
-  def test_translate_given_a_month_name_format_it_returns_the_correct_month_name
-    assert_equal 'Januar', @backend.localize('de', @morning, '%B')
-  end
-
-  def test_translate_given_an_abbr_month_name_format_it_returns_the_correct_abbrevated_month_name
-    assert_equal 'Jan', @backend.localize('de', @morning, '%b')
-  end
-
-  def test_translate_given_a_meridian_indicator_format_it_returns_the_correct_meridian_indicator
-    assert_equal 'am', @backend.localize('de', @morning, '%p')
-    assert_equal 'pm', @backend.localize('de', @evening, '%p')
-  end
-
-  def test_translate_given_no_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning }
-  end
-
-  def test_translate_given_an_unknown_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning, '%x' }
-  end
-end
-
-class I18nSimpleBackendLocalizeTimeTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def setup
-    @old_timezone, ENV['TZ'] = ENV['TZ'], 'UTC'
-    @backend = I18n::Backend::Simple.new
-    add_datetime_translations
-    @morning = Time.parse '2008-01-01 6:00 UTC'
-    @evening = Time.parse '2008-01-01 18:00 UTC'
-  end
-
-  def teardown
-    @old_timezone ? ENV['TZ'] = @old_timezone : ENV.delete('TZ')
-  end
-
-  def test_translate_given_the_short_format_it_uses_it
-    assert_equal '01. Jan 06:00', @backend.localize('de', @morning, :short)
-  end
-
-  def test_translate_given_the_long_format_it_uses_it
-    assert_equal '01. Januar 2008 06:00', @backend.localize('de', @morning, :long)
-  end
-
-  # TODO Seems to break on Windows because ENV['TZ'] is ignored. What's a better way to do this?
-  # def test_translate_given_the_default_format_it_uses_it
-  #   assert_equal 'Di, 01. Jan 2008 06:00:00 +0000', @backend.localize('de', @morning, :default)
-  # end
-
-  def test_translate_given_a_day_name_format_it_returns_the_correct_day_name
-    assert_equal 'Dienstag', @backend.localize('de', @morning, '%A')
-  end
-
-  def test_translate_given_an_abbr_day_name_format_it_returns_the_correct_abbrevated_day_name
-    assert_equal 'Di', @backend.localize('de', @morning, '%a')
-  end
-
-  def test_translate_given_a_month_name_format_it_returns_the_correct_month_name
-    assert_equal 'Januar', @backend.localize('de', @morning, '%B')
-  end
-
-  def test_translate_given_an_abbr_month_name_format_it_returns_the_correct_abbrevated_month_name
-    assert_equal 'Jan', @backend.localize('de', @morning, '%b')
-  end
-
-  def test_translate_given_a_meridian_indicator_format_it_returns_the_correct_meridian_indicator
-    assert_equal 'am', @backend.localize('de', @morning, '%p')
-    assert_equal 'pm', @backend.localize('de', @evening, '%p')
-  end
-
-  def test_translate_given_no_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning }
-  end
-
-  def test_translate_given_an_unknown_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning, '%x' }
-  end
-end
-
-class I18nSimpleBackendHelperMethodsTest < Test::Unit::TestCase
-  def setup
-    @backend = I18n::Backend::Simple.new
-  end
-
-  def test_deep_symbolize_keys_works
-    result = @backend.send :deep_symbolize_keys, 'foo' => {'bar' => {'baz' => 'bar'}}
-    expected = {:foo => {:bar => {:baz => 'bar'}}}
-    assert_equal expected, result
-  end
-end
-
-class I18nSimpleBackendLoadTranslationsTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_load_translations_with_unknown_file_type_raises_exception
-    assert_raise(I18n::UnknownFileType) { @backend.load_translations "#{@locale_dir}/en.xml" }
-  end
-
-  def test_load_translations_with_ruby_file_type_does_not_raise_exception
-    assert_nothing_raised { @backend.load_translations "#{@locale_dir}/en.rb" }
-  end
-
-  def test_load_rb_loads_data_from_ruby_file
-    data = @backend.send :load_rb, "#{@locale_dir}/en.rb"
-    assert_equal({:'en-Ruby' => {:foo => {:bar => "baz"}}}, data)
-  end
-
-  def test_load_rb_loads_data_from_yaml_file
-    data = @backend.send :load_yml, "#{@locale_dir}/en.yml"
-    assert_equal({'en-Yaml' => {'foo' => {'bar' => 'baz'}}}, data)
-  end
-
-  def test_load_translations_loads_from_different_file_formats
-    @backend = I18n::Backend::Simple.new
-    @backend.load_translations "#{@locale_dir}/en.rb", "#{@locale_dir}/en.yml"
-    expected = {
-      :'en-Ruby' => {:foo => {:bar => "baz"}},
-      :'en-Yaml' => {:foo => {:bar => "baz"}}
-    }
-    assert_equal expected, backend_get_translations
-  end
-end
-
-class I18nSimpleBackendLoadPathTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def teardown
-    I18n.load_path = []
-  end
-
-  def test_nested_load_paths_do_not_break_locale_loading
-    @backend = I18n::Backend::Simple.new
-    I18n.load_path = [[File.dirname(__FILE__) + '/locale/en.yml']]
-    assert_nil backend_get_translations
-    assert_nothing_raised { @backend.send :init_translations }
-    assert_not_nil backend_get_translations
-  end
-
-  def test_adding_arrays_of_filenames_to_load_path_do_not_break_locale_loading
-    @backend = I18n::Backend::Simple.new
-    I18n.load_path << Dir[File.dirname(__FILE__) + '/locale/*.{rb,yml}']
-    assert_nil backend_get_translations
-    assert_nothing_raised { @backend.send :init_translations }
-    assert_not_nil backend_get_translations
-  end
-end
-
-class I18nSimpleBackendReloadTranslationsTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-  
-  def setup
-    @backend = I18n::Backend::Simple.new
-    I18n.load_path = [File.dirname(__FILE__) + '/locale/en.yml']
-    assert_nil backend_get_translations
-    @backend.send :init_translations
-  end
-  
-  def teardown
-    I18n.load_path = []
-  end
-  
-  def test_setup
-    assert_not_nil backend_get_translations
-  end
-  
-  def test_reload_translations_unloads_translations
-    @backend.reload!
-    assert_nil backend_get_translations
-  end
-  
-  def test_reload_translations_uninitializes_translations
-    @backend.reload!
-    assert_equal @backend.initialized?, false
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n.rb b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n.rb
new file mode 100755
index 0000000..d28de32
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n.rb
@@ -0,0 +1,229 @@
+# Authors::   Matt Aimonetti (http://railsontherun.com/),
+#             Sven Fuchs (http://www.artweb-design.de),
+#             Joshua Harvey (http://www.workingwithrails.com/person/759-joshua-harvey),
+#             Saimon Moore (http://saimonmoore.net),
+#             Stephan Soller (http://www.arkanis-development.de/)
+# Copyright:: Copyright (c) 2008 The Ruby i18n Team
+# License::   MIT
+require 'i18n/backend/simple'
+require 'i18n/exceptions'
+require 'i18n/string'
+
+module I18n
+  @@backend = nil
+  @@load_path = nil
+  @@default_locale = :'en'
+  @@default_separator = '.'
+  @@exception_handler = :default_exception_handler
+
+  class << self
+    # Returns the current backend. Defaults to +Backend::Simple+.
+    def backend
+      @@backend ||= Backend::Simple.new
+    end
+
+    # Sets the current backend. Used to set a custom backend.
+    def backend=(backend)
+      @@backend = backend
+    end
+
+    # Returns the current default locale. Defaults to :'en'
+    def default_locale
+      @@default_locale
+    end
+
+    # Sets the current default locale. Used to set a custom default locale.
+    def default_locale=(locale)
+      @@default_locale = locale
+    end
+
+    # Returns the current locale. Defaults to I18n.default_locale.
+    def locale
+      Thread.current[:locale] ||= default_locale
+    end
+
+    # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
+    def locale=(locale)
+      Thread.current[:locale] = locale
+    end
+
+    # Returns an array of locales for which translations are available
+    def available_locales
+      backend.available_locales
+    end
+
+    # Returns the current default scope separator. Defaults to '.'
+    def default_separator
+      @@default_separator
+    end
+
+    # Sets the current default scope separator.
+    def default_separator=(separator)
+      @@default_separator = separator
+    end
+
+    # Sets the exception handler.
+    def exception_handler=(exception_handler)
+      @@exception_handler = exception_handler
+    end
+
+    # Allow clients to register paths providing translation data sources. The
+    # backend defines acceptable sources.
+    #
+    # E.g. the provided SimpleBackend accepts a list of paths to translation
+    # files which are either named *.rb and contain plain Ruby Hashes or are
+    # named *.yml and contain YAML data. So for the SimpleBackend clients may
+    # register translation files like this:
+    #   I18n.load_path << 'path/to/locale/en.yml'
+    def load_path
+      @@load_path ||= []
+    end
+
+    # Sets the load path instance. Custom implementations are expected to
+    # behave like a Ruby Array.
+    def load_path=(load_path)
+      @@load_path = load_path
+    end
+
+    # Tells the backend to reload translations. Used in situations like the
+    # Rails development environment. Backends can implement whatever strategy
+    # is useful.
+    def reload!
+      backend.reload!
+    end
+
+    # Translates, pluralizes and interpolates a given key using a given locale,
+    # scope, and default, as well as interpolation values.
+    #
+    # *LOOKUP*
+    #
+    # Translation data is organized as a nested hash using the upper-level keys
+    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
+    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
+    #
+    # Translations can be looked up at any level of this hash using the key argument
+    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
+    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
+    #
+    # Key can be either a single key or a dot-separated key (both Strings and Symbols
+    # work). <em>E.g.</em>, the short format can be looked up using both:
+    #   I18n.t 'date.formats.short'
+    #   I18n.t :'date.formats.short'
+    #
+    # Scope can be either a single key, a dot-separated key or an array of keys
+    # or dot-separated keys. Keys and scopes can be combined freely. So these
+    # examples will all look up the same short date format:
+    #   I18n.t 'date.formats.short'
+    #   I18n.t 'formats.short', :scope => 'date'
+    #   I18n.t 'short', :scope => 'date.formats'
+    #   I18n.t 'short', :scope => %w(date formats)
+    #
+    # *INTERPOLATION*
+    #
+    # Translations can contain interpolation variables which will be replaced by
+    # values passed to #translate as part of the options hash, with the keys matching
+    # the interpolation variable names.
+    #
+    # <em>E.g.</em>, with a translation <tt>:foo => "foo {{bar}}"</tt> the option
+    # value for the key +bar+ will be interpolated into the translation:
+    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
+    #
+    # *PLURALIZATION*
+    #
+    # Translation data can contain pluralized translations. Pluralized translations
+    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
+    #
+    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
+    # pluralization rules. Other algorithms can be supported by custom backends.
+    #
+    # This returns the singular version of a pluralized translation:
+    #   I18n.t :foo, :count => 1 # => 'Foo'
+    #
+    # These both return the plural version of a pluralized translation:
+    #   I18n.t :foo, :count => 0 # => 'Foos'
+    #   I18n.t :foo, :count => 2 # => 'Foos'
+    #
+    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
+    # <em>E.g.</em>, with the translation
+    # <tt>:foo => ['{{count}} foo', '{{count}} foos']</tt>, count will
+    # be interpolated to the pluralized translation:
+    #   I18n.t :foo, :count => 1 # => '1 foo'
+    #
+    # *DEFAULTS*
+    #
+    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
+    #   I18n.t :foo, :default => 'default'
+    #
+    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
+    # translation for <tt>:foo</tt> was found:
+    #   I18n.t :foo, :default => :bar
+    #
+    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
+    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
+    #   I18n.t :foo, :default => [:bar, 'default']
+    #
+    # *BULK LOOKUP*
+    #
+    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
+    #   I18n.t [:foo, :bar]
+    #
+    # Can be used with dot-separated nested keys:
+    #   I18n.t [:'baz.foo', :'baz.bar']
+    #
+    # Which is the same as using a scope option:
+    #   I18n.t [:foo, :bar], :scope => :baz
+    #
+    # *LAMBDAS*
+    #
+    # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
+    # called and passed the key and options. 
+    #
+    # E.g. assuming the key <tt>:salutation</tt> resolves to:
+    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. {{options[:name]}}" : "Mrs. {{options[:name]}}" }
+    #
+    # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
+    # 
+    # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
+    # a cache layer is put in front of I18n.translate it will generate a cache key
+    # from the argument values passed to #translate. Therefor your lambdas should
+    # always return the same translations/values per unique combination of argument
+    # values.
+    def translate(*args)
+      options = args.last.is_a?(Hash) ? args.pop : {}
+      key     = args.shift
+      locale  = options.delete(:locale) || I18n.locale
+      backend.translate(locale, key, options)
+    rescue I18n::ArgumentError => e
+      raise e if options[:raise]
+      send(@@exception_handler, e, locale, key, options)
+    end
+    alias :t :translate
+
+    # Localizes certain objects, such as dates and numbers to local formatting.
+    def localize(object, options = {})
+      locale = options[:locale] || I18n.locale
+      format = options[:format] || :default
+      backend.localize(locale, object, format)
+    end
+    alias :l :localize
+
+  protected
+    # Handles exceptions raised in the backend. All exceptions except for
+    # MissingTranslationData exceptions are re-raised. When a MissingTranslationData
+    # was caught and the option :raise is not set the handler returns an error
+    # message string containing the key/scope.
+    def default_exception_handler(exception, locale, key, options)
+      return exception.message if MissingTranslationData === exception
+      raise exception
+    end
+
+    # Merges the given locale, key and scope into a single array of keys.
+    # Splits keys that contain dots into multiple keys. Makes sure all
+    # keys are Symbols.
+    def normalize_translation_keys(locale, key, scope, separator = nil)
+      keys = [locale] + Array(scope) + Array(key)
+      keys = keys.map { |k| k.to_s.split(separator || I18n.default_separator) }
+      keys.flatten.map { |k| k.to_sym }
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/backend/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/backend/simple.rb
new file mode 100644
index 0000000..4bcfd33
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/backend/simple.rb
@@ -0,0 +1,234 @@
+require 'yaml'
+
+module I18n
+  module Backend
+    class Simple
+      RESERVED_KEYS = [:scope, :default, :separator, :raise]
+      INTERPOLATION_SYNTAX_PATTERN = /(\\\\)?\{\{([^\}]+)\}\}/
+
+      # Accepts a list of paths to translation files. Loads translations from
+      # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
+      # for details.
+      def load_translations(*filenames)
+        filenames.each { |filename| load_file(filename) }
+      end
+
+      # Stores translations for the given locale in memory.
+      # This uses a deep merge for the translations hash, so existing
+      # translations will be overwritten by new ones only at the deepest
+      # level of the hash.
+      def store_translations(locale, data)
+        merge_translations(locale, data)
+      end
+
+      def translate(locale, key, options = {})
+        raise InvalidLocale.new(locale) if locale.nil?
+        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
+
+        count, scope, default, separator = options.values_at(:count, *RESERVED_KEYS)
+        values = options.reject { |name, value| RESERVED_KEYS.include?(name) }
+
+        entry = lookup(locale, key, scope, separator)
+        entry = entry.nil? ? default(locale, key, default, options) : resolve(locale, key, entry, options)
+
+        raise(I18n::MissingTranslationData.new(locale, key, options)) if entry.nil?
+        entry = pluralize(locale, entry, count)
+        entry = interpolate(locale, entry, values)
+        entry
+      end
+
+      # Acts the same as +strftime+, but returns a localized version of the
+      # formatted date string. Takes a key from the date/time formats
+      # translations as a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
+      def localize(locale, object, format = :default, options={})
+        raise ArgumentError, "Object must be a Date, DateTime or Time object. #{object.inspect} given." unless object.respond_to?(:strftime)
+
+        if Symbol === format
+          type = object.respond_to?(:sec) ? 'time' : 'date'
+          format = lookup(locale, :"#{type}.formats.#{format}")
+        end
+
+        format = resolve(locale, object, format, options.merge(:raise => true))
+        format = format.dup if format
+
+        # TODO check which format strings are present, then bulk translate them, then replace them
+        format.gsub!(/%a/, translate(locale, :"date.abbr_day_names",   :format => format)[object.wday])   if format.include?('%a')
+        format.gsub!(/%A/, translate(locale, :"date.day_names",        :format => format)[object.wday])   if format.include?('%A')
+        format.gsub!(/%b/, translate(locale, :"date.abbr_month_names", :format => format)[object.mon])    if format.include?('%b')
+        format.gsub!(/%B/, translate(locale, :"date.month_names",      :format => format)[object.mon])    if format.include?('%B')
+        format.gsub!(/%p/, translate(locale, :"time.#{object.hour < 12 ? :am : :pm}", :format => format)) if format.include?('%p') && object.respond_to?(:hour)
+
+        object.strftime(format)
+      end
+
+      def initialized?
+        @initialized ||= false
+      end
+
+      # Returns an array of locales for which translations are available
+      def available_locales
+        init_translations unless initialized?
+        translations.keys
+      end
+
+      def reload!
+        @initialized = false
+        @translations = nil
+      end
+
+      protected
+        def init_translations
+          load_translations(*I18n.load_path.flatten)
+          @initialized = true
+        end
+
+        def translations
+          @translations ||= {}
+        end
+
+        # Looks up a translation from the translations hash. Returns nil if
+        # eiher key is nil, or locale, scope or key do not exist as a key in the
+        # nested translations hash. Splits keys or scopes containing dots
+        # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
+        # <tt>%w(currency format)</tt>.
+        def lookup(locale, key, scope = [], separator = nil)
+          return unless key
+          init_translations unless initialized?
+          keys = I18n.send(:normalize_translation_keys, locale, key, scope, separator)
+          keys.inject(translations) do |result, k|
+            if (x = result[k.to_sym]).nil?
+              return nil
+            else
+              x
+            end
+          end
+        end
+
+        # Evaluates defaults.
+        # If given subject is an Array, it walks the array and returns the
+        # first translation that can be resolved. Otherwise it tries to resolve
+        # the translation directly.
+        def default(locale, object, subject, options = {})
+          options = options.dup.reject { |key, value| key == :default }
+          case subject
+          when Array
+            subject.each do |subject|
+              result = resolve(locale, object, subject, options) and return result
+            end and nil
+          else
+            resolve(locale, object, subject, options)
+          end
+        end
+
+        # Resolves a translation.
+        # If the given subject is a Symbol, it will be translated with the
+        # given options. If it is a Proc then it will be evaluated. All other
+        # subjects will be returned directly.
+        def resolve(locale, object, subject, options = {})
+          case subject
+          when Symbol
+            translate(locale, subject, options)
+          when Proc
+            resolve(locale, object, subject.call(object, options), options = {})
+          else
+            subject
+          end
+        rescue MissingTranslationData
+          nil
+        end
+
+        # Picks a translation from an array according to English pluralization
+        # rules. It will pick the first translation if count is not equal to 1
+        # and the second translation if it is equal to 1. Other backends can
+        # implement more flexible or complex pluralization rules.
+        def pluralize(locale, entry, count)
+          return entry unless entry.is_a?(Hash) and count
+
+          key = :zero if count == 0 && entry.has_key?(:zero)
+          key ||= count == 1 ? :one : :other
+          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
+          entry[key]
+        end
+
+        # Interpolates values into a given string.
+        #
+        #   interpolate "file {{file}} opened by \\{{user}}", :file => 'test.txt', :user => 'Mr. X'
+        #   # => "file test.txt opened by {{user}}"
+        #
+        # Note that you have to double escape the <tt>\\</tt> when you want to escape
+        # the <tt>{{...}}</tt> key in a string (once for the string and once for the
+        # interpolation).
+        def interpolate(locale, string, values = {})
+          return string unless string.is_a?(String) && !values.empty?
+
+          string.gsub(INTERPOLATION_SYNTAX_PATTERN) do
+            escaped, key = $1, $2.to_sym
+
+            if escaped
+              key
+            elsif RESERVED_KEYS.include?(key)
+              raise ReservedInterpolationKey.new(key, string)
+            else
+              "%{#{key}}"
+            end
+          end % values
+
+        rescue KeyError => e
+          raise MissingInterpolationArgument.new(values, string)
+        end
+
+        # Loads a single translations file by delegating to #load_rb or
+        # #load_yml depending on the file extension and directly merges the
+        # data to the existing translations. Raises I18n::UnknownFileType
+        # for all other file extensions.
+        def load_file(filename)
+          type = File.extname(filename).tr('.', '').downcase
+          raise UnknownFileType.new(type, filename) unless respond_to?(:"load_#{type}")
+          data = send :"load_#{type}", filename # TODO raise a meaningful exception if this does not yield a Hash
+          data.each { |locale, d| merge_translations(locale, d) }
+        end
+
+        # Loads a plain Ruby translations file. eval'ing the file must yield
+        # a Hash containing translation data with locales as toplevel keys.
+        def load_rb(filename)
+          eval(IO.read(filename), binding, filename)
+        end
+
+        # Loads a YAML translations file. The data must have locales as
+        # toplevel keys.
+        def load_yml(filename)
+          YAML::load(IO.read(filename))
+        end
+
+        # Deep merges the given translations hash with the existing translations
+        # for the given locale
+        def merge_translations(locale, data)
+          locale = locale.to_sym
+          translations[locale] ||= {}
+          data = deep_symbolize_keys(data)
+
+          # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
+          merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
+          translations[locale].merge!(data, &merger)
+        end
+
+        # Return a new hash with all keys and nested keys converted to symbols.
+        def deep_symbolize_keys(hash)
+          hash.inject({}) { |result, (key, value)|
+            value = deep_symbolize_keys(value) if value.is_a?(Hash)
+            result[(key.to_sym rescue key) || key] = value
+            result
+          }
+        end
+
+        # Flatten the given array once
+        def flatten_once(array)
+          result = []
+          for element in array # a little faster than each
+            result.push(*element)
+          end
+          result
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/exceptions.rb b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/exceptions.rb
new file mode 100644
index 0000000..7acc037
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/exceptions.rb
@@ -0,0 +1,59 @@
+class KeyError < IndexError
+  def initialize(message = nil)
+    super(message || "key not found")
+  end
+end unless defined?(KeyError)
+
+module I18n
+  class ArgumentError < ::ArgumentError; end
+
+  class InvalidLocale < ArgumentError
+    attr_reader :locale
+    def initialize(locale)
+      @locale = locale
+      super "#{locale.inspect} is not a valid locale"
+    end
+  end
+
+  class MissingTranslationData < ArgumentError
+    attr_reader :locale, :key, :options
+    def initialize(locale, key, options)
+      @key, @locale, @options = key, locale, options
+      keys = I18n.send(:normalize_translation_keys, locale, key, options[:scope])
+      keys << 'no key' if keys.size < 2
+      super "translation missing: #{keys.join(', ')}"
+    end
+  end
+
+  class InvalidPluralizationData < ArgumentError
+    attr_reader :entry, :count
+    def initialize(entry, count)
+      @entry, @count = entry, count
+      super "translation data #{entry.inspect} can not be used with :count => #{count}"
+    end
+  end
+
+  class MissingInterpolationArgument < ArgumentError
+    attr_reader :values, :string
+    def initialize(values, string)
+      @values, @string = values, string
+      super "missing interpolation argument in #{string.inspect} (#{values.inspect} given)"
+    end
+  end
+
+  class ReservedInterpolationKey < ArgumentError
+    attr_reader :key, :string
+    def initialize(key, string)
+      @key, @string = key, string
+      super "reserved key #{key.inspect} used in #{string.inspect}"
+    end
+  end
+
+  class UnknownFileType < ArgumentError
+    attr_reader :type, :filename
+    def initialize(type, filename)
+      @type, @filename = type, filename
+      super "can not load translations from #{filename}, the file type #{type} is not known"
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/string.rb b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/string.rb
new file mode 100644
index 0000000..d459c03
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.2.2/lib/i18n/string.rb
@@ -0,0 +1,93 @@
+=begin
+  heavily based on Masao Mutoh's gettext String interpolation extension
+  http://github.com/mutoh/gettext/blob/f6566738b981fe0952548c421042ad1e0cdfb31e/lib/gettext/core_ext/string.rb
+  Copyright (C) 2005-2009 Masao Mutoh
+  You may redistribute it and/or modify it under the same license terms as Ruby.
+=end
+
+if RUBY_VERSION < '1.9'
+
+  # KeyError is raised by String#% when the string contains a named placeholder
+  # that is not contained in the given arguments hash. Ruby 1.9 includes and
+  # raises this exception natively. We define it to mimic Ruby 1.9's behaviour
+  # in Ruby 1.8.x
+
+  class KeyError < IndexError
+    def initialize(message = nil)
+      super(message || "key not found")
+    end
+  end unless defined?(KeyError)
+
+  # Extension for String class. This feature is included in Ruby 1.9 or later but not occur TypeError.
+  #
+  # String#% method which accept "named argument". The translator can know
+  # the meaning of the msgids using "named argument" instead of %s/%d style.
+
+  class String
+    # For older ruby versions, such as ruby-1.8.5
+    alias :bytesize :size unless instance_methods.find {|m| m.to_s == 'bytesize'}
+    alias :interpolate_without_ruby_19_syntax :% # :nodoc:
+
+    INTERPOLATION_PATTERN = Regexp.union(
+      /%%/,
+      /%\{(\w+)\}/,                               # matches placeholders like "%{foo}"
+      /%<(\w+)>(.*?\d*\.?\d*[bBdiouxXeEfgGcps])/  # matches placeholders like "%<foo>.d"
+    )
+
+    # % uses self (i.e. the String) as a format specification and returns the
+    # result of applying it to the given arguments. In other words it interpolates
+    # the given arguments to the string according to the formats the string
+    # defines.
+    #
+    # There are three ways to use it:
+    #
+    # * Using a single argument or Array of arguments.
+    #
+    #   This is the default behaviour of the String class. See Kernel#sprintf for
+    #   more details about the format string.
+    #
+    #   Example:
+    #
+    #     "%d %s" % [1, "message"]
+    #     # => "1 message"
+    #
+    # * Using a Hash as an argument and unformatted, named placeholders.
+    #
+    #   When you pass a Hash as an argument and specify placeholders with %{foo}
+    #   it will interpret the hash values as named arguments.
+    #
+    #   Example:
+    #
+    #     "%{firstname}, %{lastname}" % {:firstname => "Masao", :lastname => "Mutoh"}
+    #     # => "Masao Mutoh"
+    #
+    # * Using a Hash as an argument and formatted, named placeholders.
+    #
+    #   When you pass a Hash as an argument and specify placeholders with %<foo>d
+    #   it will interpret the hash values as named arguments and format the value
+    #   according to the formatting instruction appended to the closing >.
+    #
+    #   Example:
+    #
+    #     "%<integer>d, %<float>.1f" % { :integer => 10, :float => 43.4 }
+    #     # => "10, 43.3"
+    def %(args)
+      if args.kind_of?(Hash)
+        dup.gsub(INTERPOLATION_PATTERN) do |match|
+          if match == '%%'
+            '%'
+          else
+            key = ($1 || $2).to_sym
+            raise KeyError unless args.has_key?(key)
+            $3 ? sprintf("%#{$3}", args[key]) : args[key]
+          end
+        end
+      elsif self =~ INTERPOLATION_PATTERN
+        raise ArgumentError.new('one hash required')
+      else
+        result = gsub(/%([{<])/, '%%\1')
+        result.send :'interpolate_without_ruby_19_syntax', args
+      end
+    end
+  end
+end
\ No newline at end of file
-- 
1.6.4.2

