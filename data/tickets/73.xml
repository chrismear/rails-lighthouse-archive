<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer">1</assigned-user-id>
  <attachments-count type="integer">1</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2008-05-01T08:33:43+01:00</created-at>
  <creator-id type="integer">18887</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer" nil="true"></milestone-id>
  <number type="integer">73</number>
  <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
  <priority type="integer">12443</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>resolved</state>
  <tag>actionpack request-forgery-protection security</tag>
  <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
  <updated-at type="datetime">2008-10-01T07:10:59+01:00</updated-at>
  <user-id type="integer">18887</user-id>
  <version type="integer">13</version>
  <user-name>Mathijs Kwik</user-name>
  <creator-name>Mathijs Kwik</creator-name>
  <assigned-user-name>Rick</assigned-user-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
  <priority-name nil="true"></priority-name>
  <original-body>JSON was recently added as input-type just as xml has been for some time.

While playing with it I noticed that I get ActionController::InvalidAuthenticityToken when submitting json-data that has the content-type set to application/json but without setting the accept-type. In this case rails wants to hand over a html response. 

Now, you won't usually send another type of data than that you want back, but this incident got me worried, since it seemed the wanted _output_ is somehow controlling the request-forgery security feature. This of course should be determined by the _incoming_ data.

The way I understand Request Forgery protection, it is only meant to protect against the posting of normal forms from different domains that abuse an 'open session' that a visitor might have. Ajax-requests are normally 'protected' by the same-origin-policy.

Normal forms cannot set the content-type nor the accept-header, but since the .:format convenience routes are generated by resources, this is easily abusable.

Just create a plain html form on a different domain(yourdomain.com), but instead of sending it to (for example) http://mydomain.com/posts, use http://mydomain.com/posts.json or http://mydomain.com/posts.xml
This will allow the post to be created without having to go through forgery protection.

Since normal forms always are www-form-encoded content, I believe request forgery should look for the content-type header instead of the accept-header, since this can be fooled by the .:format route. 

Also, in case of an xml/json request that wants html back, it makes no sence that forgery protection kicks in, since xml/json-content-requests are already 'safe'.

So to keep it short... the RF-protection should be changed to check for the content-header instead of the accept-header.

Thanks, Mathijs</original-body>
  <latest-body>JSON was recently added as input-type just as xml has been for some time.

While playing with it I noticed that I get ActionController::InvalidAuthenticityToken when submitting json-data that has the content-type set to application/json but without setting the accept-type. In this case rails wants to hand over a html response. 

Now, you won't usually send another type of data than that you want back, but this incident got me worried, since it seemed the wanted _output_ is somehow controlling the request-forgery security feature. This of course should be determined by the _incoming_ data.

The way I understand Request Forgery protection, it is only meant to protect against the posting of normal forms from different domains that abuse an 'open session' that a visitor might have. Ajax-requests are normally 'protected' by the same-origin-policy.

Normal forms cannot set the content-type nor the accept-header, but since the .:format convenience routes are generated by resources, this is easily abusable.

Just create a plain html form on a different domain(yourdomain.com), but instead of sending it to (for example) http://mydomain.com/posts, use http://mydomain.com/posts.json or http://mydomain.com/posts.xml
This will allow the post to be created without having to go through forgery protection.

Since normal forms always are www-form-encoded content, I believe request forgery should look for the content-type header instead of the accept-header, since this can be fooled by the .:format route. 

Also, in case of an xml/json request that wants html back, it makes no sence that forgery protection kicks in, since xml/json-content-requests are already 'safe'.

So to keep it short... the RF-protection should be changed to check for the content-header instead of the accept-header.

Thanks, Mathijs</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;
JSON was recently added as input-type just as xml has been for some time.
&lt;/p&gt;&lt;p&gt;
While playing with it I noticed that I get ActionController::InvalidAuthenticityToken when submitting json-data that has the content-type set to application/json but without setting the accept-type. In this case rails wants to hand over a html response.
&lt;/p&gt;&lt;p&gt;
Now, you won't usually send another type of data than that you want back, but this incident got me worried, since it seemed the wanted &lt;em&gt;output&lt;/em&gt; is somehow controlling the request-forgery security feature. This of course should be determined by the &lt;em&gt;incoming&lt;/em&gt; data.
&lt;/p&gt;&lt;p&gt;
The way I understand Request Forgery protection, it is only meant to protect against the posting of normal forms from different domains that abuse an 'open session' that a visitor might have. Ajax-requests are normally 'protected' by the same-origin-policy.
&lt;/p&gt;&lt;p&gt;
Normal forms cannot set the content-type nor the accept-header, but since the .:format convenience routes are generated by resources, this is easily abusable.
&lt;/p&gt;&lt;p&gt;
Just create a plain html form on a different domain(yourdomain.com), but instead of sending it to (for example) &lt;a href=&quot;http://mydomain.com/posts&quot;&gt;http://mydomain.com/posts&lt;/a&gt;, use &lt;a href=&quot;http://mydomain.com/posts.json&quot;&gt;http://mydomain.com/posts.json&lt;/a&gt; or &lt;a href=&quot;http://mydomain.com/posts.xml&quot;&gt;http://mydomain.com/posts.xml&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;
This will allow the post to be created without having to go through forgery protection.
&lt;/p&gt;&lt;p&gt;
Since normal forms always are www-form-encoded content, I believe request forgery should look for the content-type header instead of the accept-header, since this can be fooled by the .:format route.
&lt;/p&gt;&lt;p&gt;
Also, in case of an xml/json request that wants html back, it makes no sence that forgery protection kicks in, since xml/json-content-requests are already 'safe'.
&lt;/p&gt;&lt;p&gt;
So to keep it short... the RF-protection should be changed to check for the content-header instead of the accept-header.
&lt;/p&gt;&lt;p&gt;
Thanks, Mathijs
&lt;/p&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>JSON was recently added as input-type just as xml has been for some time.

While playing with it I noticed that I get ActionController::InvalidAuthenticityToken when submitting json-data that has the content-type set to application/json but without setting the accept-type. In this case rails wants to hand over a html response. 

Now, you won't usually send another type of data than that you want back, but this incident got me worried, since it seemed the wanted _output_ is somehow controlling the request-forgery security feature. This of course should be determined by the _incoming_ data.

The way I understand Request Forgery protection, it is only meant to protect against the posting of normal forms from different domains that abuse an 'open session' that a visitor might have. Ajax-requests are normally 'protected' by the same-origin-policy.

Normal forms cannot set the content-type nor the accept-header, but since the .:format convenience routes are generated by resources, this is easily abusable.

Just create a plain html form on a different domain(yourdomain.com), but instead of sending it to (for example) http://mydomain.com/posts, use http://mydomain.com/posts.json or http://mydomain.com/posts.xml
This will allow the post to be created without having to go through forgery protection.

Since normal forms always are www-form-encoded content, I believe request forgery should look for the content-type header instead of the accept-header, since this can be fooled by the .:format route. 

Also, in case of an xml/json request that wants html back, it makes no sence that forgery protection kicks in, since xml/json-content-requests are already 'safe'.

So to keep it short... the RF-protection should be changed to check for the content-header instead of the accept-header.

Thanks, Mathijs</body>
      <body-html>&lt;div&gt;&lt;p&gt;
JSON was recently added as input-type just as xml has been for some time.
&lt;/p&gt;&lt;p&gt;
While playing with it I noticed that I get ActionController::InvalidAuthenticityToken when submitting json-data that has the content-type set to application/json but without setting the accept-type. In this case rails wants to hand over a html response.
&lt;/p&gt;&lt;p&gt;
Now, you won't usually send another type of data than that you want back, but this incident got me worried, since it seemed the wanted &lt;em&gt;output&lt;/em&gt; is somehow controlling the request-forgery security feature. This of course should be determined by the &lt;em&gt;incoming&lt;/em&gt; data.
&lt;/p&gt;&lt;p&gt;
The way I understand Request Forgery protection, it is only meant to protect against the posting of normal forms from different domains that abuse an 'open session' that a visitor might have. Ajax-requests are normally 'protected' by the same-origin-policy.
&lt;/p&gt;&lt;p&gt;
Normal forms cannot set the content-type nor the accept-header, but since the .:format convenience routes are generated by resources, this is easily abusable.
&lt;/p&gt;&lt;p&gt;
Just create a plain html form on a different domain(yourdomain.com), but instead of sending it to (for example) &lt;a href=&quot;http://mydomain.com/posts&quot;&gt;http://mydomain.com/posts&lt;/a&gt;, use &lt;a href=&quot;http://mydomain.com/posts.json&quot;&gt;http://mydomain.com/posts.json&lt;/a&gt; or &lt;a href=&quot;http://mydomain.com/posts.xml&quot;&gt;http://mydomain.com/posts.xml&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;
This will allow the post to be created without having to go through forgery protection.
&lt;/p&gt;&lt;p&gt;
Since normal forms always are www-form-encoded content, I believe request forgery should look for the content-type header instead of the accept-header, since this can be fooled by the .:format route.
&lt;/p&gt;&lt;p&gt;
Also, in case of an xml/json request that wants html back, it makes no sence that forgery protection kicks in, since xml/json-content-requests are already 'safe'.
&lt;/p&gt;&lt;p&gt;
So to keep it short... the RF-protection should be changed to check for the content-header instead of the accept-header.
&lt;/p&gt;&lt;p&gt;
Thanks, Mathijs
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-01T08:33:44+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-01T08:33:44+01:00</updated-at>
      <user-id type="integer">18887</user-id>
      <version type="integer">1</version>
      <user-name>Mathijs Kwik</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>As i see it this is only a problem if you implicitly trust json input more than a 'normal' http post, and i can't think why you would do that (and indeed ajax posts also need to include the auth token).</body>
      <body-html>&lt;div&gt;&lt;p&gt;
As i see it this is only a problem if you implicitly trust json input more than a 'normal' http post, and i can't think why you would do that (and indeed ajax posts also need to include the auth token).
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-01T10:43:02+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-01T10:43:02+01:00</updated-at>
      <user-id type="integer">17477</user-id>
      <version type="integer">2</version>
      <user-name>Frederick Cheung</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>That's not what I'm reporting here.
The thing is, that in the case I mentioned (submitting a form from a different domain to a url ending in .json or .xml) bypasses the RF-protection completely!
So this is a security-bug, since the feature doesn't work as 'advertised'.

What you are talking about is extending RF-protection to include other kinds of requests.
I think this really isn't needed, since RF-protection was only meant to protect against forms being submitted from different domains.
At the moment, ajax posts are protected automatically because of the same-origin policy, so it's not possible for an attacker to set-up a site that sends ajax-requests to your domain.

This is why XML and JSON requests aren't checked by RF-protection.
To include RF-protection in xml/json requests would mean a lot of stuff (including ActiveResource) would have to be patched.

I personally don't think it is needed to extend RF-protection in these areas, but like I said, this is a different subject.

My report was only about RF-protection not working in a case that it should work.
So this is an exploitable bug to bypass a security-feature.
My solution would be to check for the Content-Type header instead of the Accept header.</body>
      <body-html>&lt;div&gt;&lt;p&gt;
That's not what I'm reporting here.
&lt;/p&gt;&lt;p&gt;
The thing is, that in the case I mentioned (submitting a form from a different domain to a url ending in .json or .xml) bypasses the RF-protection completely!
&lt;/p&gt;&lt;p&gt;
So this is a security-bug, since the feature doesn't work as 'advertised'.
&lt;/p&gt;&lt;p&gt;
What you are talking about is extending RF-protection to include other kinds of requests.
&lt;/p&gt;&lt;p&gt;
I think this really isn't needed, since RF-protection was only meant to protect against forms being submitted from different domains.
&lt;/p&gt;&lt;p&gt;
At the moment, ajax posts are protected automatically because of the same-origin policy, so it's not possible for an attacker to set-up a site that sends ajax-requests to your domain.
&lt;/p&gt;&lt;p&gt;
This is why XML and JSON requests aren't checked by RF-protection.
&lt;/p&gt;&lt;p&gt;
To include RF-protection in xml/json requests would mean a lot of stuff (including ActiveResource) would have to be patched.
&lt;/p&gt;&lt;p&gt;
I personally don't think it is needed to extend RF-protection in these areas, but like I said, this is a different subject.
&lt;/p&gt;&lt;p&gt;
My report was only about RF-protection not working in a case that it should work.
&lt;/p&gt;&lt;p&gt;
So this is an exploitable bug to bypass a security-feature.
&lt;/p&gt;&lt;p&gt;
My solution would be to check for the Content-Type header instead of the Accept header.
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-01T11:57:21+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-01T11:57:21+01:00</updated-at>
      <user-id type="integer">18887</user-id>
      <version type="integer">3</version>
      <user-name>Mathijs Kwik</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-04T04:52:53+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- 
:assigned_user: 
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-04T04:52:53+01:00</updated-at>
      <user-id type="integer">83</user-id>
      <version type="integer">4</version>
      <user-name>DHH</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Here's my &quot;commit with the change&quot;:http://github.com/technoweenie/rails/commit/0697d17d121fcf9f46b5dd2dd1034dffa19ebdf2.  It's in my personal fork until I've tested it in Lighthouse and deployed it.  I'd appreciate if anyone else using CSRF protection in rails would do the same.  This makes sense to use content-type since the REST routes for the POST/PUT/DELETE methods check the content type too.</body>
      <body-html>&lt;div&gt;&lt;p&gt;
Here's my &lt;a href=&quot;http://github.com/technoweenie/rails/commit/0697d17d121fcf9f46b5dd2dd1034dffa19ebdf2&quot;&gt;commit with the change&lt;/a&gt;.  It's in my personal fork until I've tested it in Lighthouse and deployed it.  I'd appreciate if anyone else using CSRF protection in rails would do the same.  This makes sense to use content-type since the REST routes for the POST/PUT/DELETE methods check the content type too.
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-06T09:34:48+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-06T09:34:48+01:00</updated-at>
      <user-id type="integer">1</user-id>
      <version type="integer">5</version>
      <user-name>Rick</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Ah, forgot about Mime::MULTIPART_FORM and Mime::URL_ENCODED_FORM. &quot;Wee&quot;:http://github.com/technoweenie/rails/commit/c8451aeeea200043d8a3e6eae9c49def3a154ddb.</body>
      <body-html>&lt;div&gt;&lt;p&gt;
Ah, forgot about Mime::MULTIPART_FORM and Mime::URL_ENCODED_FORM. &lt;a href=&quot;http://github.com/technoweenie/rails/commit/c8451aeeea200043d8a3e6eae9c49def3a154ddb&quot;&gt;Wee&lt;/a&gt;.
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-06T10:59:42+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-06T10:59:42+01:00</updated-at>
      <user-id type="integer">1</user-id>
      <version type="integer">6</version>
      <user-name>Rick</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>If you want to protect your Rails 2.0 app:

@@@ ruby
class ApplicationController &lt; ActionController::Base
  def verifiable_request_format?
    request.content_type != Mime::JSON &amp;&amp; request.content_type != Mime::XML
  end
end
@@@

You want to check any request that isn't JSON or XML.  Though to be honest it doesn't matter much since you can tweak headers with AJAX or Flash.  Tokens should be checked on every request, or sessions should also be disabled on non-html requests.

@@@ ruby
class ApplicationController &lt; ActionController::Base
  session :off, 
    :if =&gt; Proc.new { |req| !(req.format.html? || req.format.js?) }
end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;
If you want to protect your Rails 2.0 app:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;class ApplicationController &amp;lt; ActionController::Base
  def verifiable_request_format?
    request.content_type != Mime::JSON &amp;amp;&amp;amp; request.content_type != Mime::XML
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
You want to check any request that isn't JSON or XML.  Though to be honest it doesn't matter much since you can tweak headers with AJAX or Flash.  Tokens should be checked on every request, or sessions should also be disabled on non-html requests.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;class ApplicationController &amp;lt; ActionController::Base
  session :off, 
    :if =&amp;gt; Proc.new { |req| !(req.format.html? || req.format.js?) }
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-06T11:08:01+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-06T11:08:01+01:00</updated-at>
      <user-id type="integer">1</user-id>
      <version type="integer">7</version>
      <user-name>Rick</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Rick, Thanks for the patch,

I will look into it at the end of the day.

One thing about turning off the session and about protecting ajax-requests in general...

I use a lot of json to communicate between my front-end application(ExtJS) and my rails-resources. I wish to use the normal session to authenticate these requests, since sending user/pass on every request would be insecure on HTTP (logging in is HTTPS). Furthermore, since all this still takes place in the web-browser, it feels natural to have 1 session for all communication.
Is there a danger if I don't disable the session for json/xml requests as you say?

All non-ajax (simple form) requests from any domain will be blocked by CSRF because of their content-type now.

Like you said, you can tweak headers with AJAX.
But to the best of my knowledge, AJAX is protected by the same-origin-policy, so I think protecting ajax-requests isn't needed anyway, since there is no way for an attacker to forge an ajax-request(using javascript on his own website) that talks with my server. Even if the content-type is html.

What about Flash?
I know flash isn't subject to the same-origin-policy, but is it possible for flash to use a session the browser might have with my server?

Any thoughts about this are very welcome.

I'll let you know if the patch works for me.</body>
      <body-html>&lt;div&gt;&lt;p&gt;
Rick, Thanks for the patch,
&lt;/p&gt;&lt;p&gt;
I will look into it at the end of the day.
&lt;/p&gt;&lt;p&gt;
One thing about turning off the session and about protecting ajax-requests in general...
&lt;/p&gt;&lt;p&gt;
I use a lot of json to communicate between my front-end application(ExtJS) and my rails-resources. I wish to use the normal session to authenticate these requests, since sending user/pass on every request would be insecure on HTTP (logging in is HTTPS). Furthermore, since all this still takes place in the web-browser, it feels natural to have 1 session for all communication.
&lt;/p&gt;&lt;p&gt;
Is there a danger if I don't disable the session for json/xml requests as you say?
&lt;/p&gt;&lt;p&gt;
All non-ajax (simple form) requests from any domain will be blocked by CSRF because of their content-type now.
&lt;/p&gt;&lt;p&gt;
Like you said, you can tweak headers with AJAX.
&lt;/p&gt;&lt;p&gt;
But to the best of my knowledge, AJAX is protected by the same-origin-policy, so I think protecting ajax-requests isn't needed anyway, since there is no way for an attacker to forge an ajax-request(using javascript on his own website) that talks with my server. Even if the content-type is html.
&lt;/p&gt;&lt;p&gt;
What about Flash?
&lt;/p&gt;&lt;p&gt;
I know flash isn't subject to the same-origin-policy, but is it possible for flash to use a session the browser might have with my server?
&lt;/p&gt;&lt;p&gt;
Any thoughts about this are very welcome.
&lt;/p&gt;&lt;p&gt;
I'll let you know if the patch works for me.
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-06T12:45:19+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-06T12:45:19+01:00</updated-at>
      <user-id type="integer">18887</user-id>
      <version type="integer">8</version>
      <user-name>Mathijs Kwik</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>(from [c8451aeeea200043d8a3e6eae9c49def3a154ddb]) change ActionController::RequestForgeryProtection to use Mime::Type#verify_request? [#73]
http://github.com/rails/rails/commit/c8451aeeea200043d8a3e6eae9c49def3a154ddb</body>
      <body-html>&lt;div&gt;&lt;p&gt;
(from [c8451aeeea200043d8a3e6eae9c49def3a154ddb]) change ActionController::RequestForgeryProtection to use Mime::Type#verify_request? [#73]
&lt;/p&gt;&lt;p&gt;
&lt;a href=&quot;http://github.com/rails/rails/commit/c8451aeeea200043d8a3e6eae9c49def3a154ddb&quot;&gt;http://github.com/rails/rails/co...&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-05-13T17:46:25+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-13T17:46:25+01:00</updated-at>
      <user-id type="integer">17393</user-id>
      <version type="integer">9</version>
      <user-name>Repository</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>(from [0697d17d121fcf9f46b5dd2dd1034dffa19ebdf2]) Change the request forgery protection to go by Content-Type instead of request.format so that you can't bypass it by POSTing to &quot;#{request.uri}.xml&quot; [#73 state:resolved]
http://github.com/rails/rails/commit/0697d17d121fcf9f46b5dd2dd1034dffa19ebdf2</body>
      <body-html>&lt;div&gt;&lt;p&gt;
(from [0697d17d121fcf9f46b5dd2dd1034dffa19ebdf2]) Change the request forgery protection to go by Content-Type instead of request.format so that you can't bypass it by POSTing to &quot;#{request.uri}.xml&quot; [#73 state:resolved]
&lt;/p&gt;&lt;p&gt;
&lt;a href=&quot;http://github.com/rails/rails/commit/0697d17d121fcf9f46b5dd2dd1034dffa19ebdf2&quot;&gt;http://github.com/rails/rails/co...&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-05-13T17:46:26+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>resolved</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-13T17:46:26+01:00</updated-at>
      <user-id type="integer">17393</user-id>
      <version type="integer">10</version>
      <user-name>Repository</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I've been testing these out on Lighthouse for the past week without problems.  I think we're doing better now, but please shower us with patches/failing test cases/complaints...</body>
      <body-html>&lt;div&gt;&lt;p&gt;
I've been testing these out on Lighthouse for the past week without problems.  I think we're doing better now, but please shower us with patches/failing test cases/complaints...
&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-05-13T17:55:23+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>resolved</state>
      <tag nil="true"></tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-05-13T17:55:23+01:00</updated-at>
      <user-id type="integer">1</user-id>
      <version type="integer">11</version>
      <user-name>Rick</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>This actually causes problems for XML delete requests, especially when using ActiveResource.

The problem stems from the assumption that an XML delete request will have an XML content-type.  A correct XML Delete request shouldn't have a content payload at all.  Instead, it should just have the correct format (xml), and correct HTTP_ACCEPTs set.

This test isn't right:

@@@ ruby
   def test_should_allow_delete_with_xml
    @request.env['CONTENT_TYPE'] = Mime::XML.to_s
     delete :index, :format =&gt; 'xml'
     assert_response :success
   end
@@@

If we're assuming a &quot;correct&quot; delete request via XML, the test would look more like the following, which currently fails:

@@@ ruby
   def test_should_allow_delete_with_xml
    @request.env['HTTP_ACCEPT'] = Mime::XML.to_s
     delete :index, :format =&gt; 'xml'
     assert_response :success
   end
@@@

I've put up a ticket here: [Bug: InvalidAuthenticityToken incorrectly raised for XML controller#destroy request](http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/1145-bug-invalidauthenticitytoken-incorrectly-raised-for-xml-controllerdestroy-request#ticket-1145-3 &quot;Bug: InvalidAuthenticityToken incorrectly raised for XML controller#destroy request&quot;)</body>
      <body-html>&lt;div&gt;&lt;p&gt;This actually causes problems for XML delete requests,
especially when using ActiveResource.&lt;/p&gt;
&lt;p&gt;The problem stems from the assumption that an XML delete request
will have an XML content-type. A correct XML Delete request
shouldn't have a content payload at all. Instead, it should just
have the correct format (xml), and correct HTTP_ACCEPTs set.&lt;/p&gt;
&lt;p&gt;This test isn't right:&lt;/p&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
   def test_should_allow_delete_with_xml
    @request.env['CONTENT_TYPE'] = Mime::XML.to_s
     delete :index, :format =&amp;gt; 'xml'
     assert_response :success
   end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we're assuming a &quot;correct&quot; delete request via XML, the test
would look more like the following, which currently fails:&lt;/p&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
   def test_should_allow_delete_with_xml
    @request.env['HTTP_ACCEPT'] = Mime::XML.to_s
     delete :index, :format =&amp;gt; 'xml'
     assert_response :success
   end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've put up a ticket here: &lt;a href=&quot;http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/1145-bug-invalidauthenticitytoken-incorrectly-raised-for-xml-controllerdestroy-request#ticket-1145-3&quot; title=&quot;Bug: InvalidAuthenticityToken incorrectly raised for XML controller#destroy request&quot;&gt;
Bug: InvalidAuthenticityToken incorrectly raised for XML
controller#destroy request&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-09-30T20:51:04+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: 
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>resolved</state>
      <tag>actionpack &quot;request-forgery-protection&quot; security</tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-09-30T20:51:05+01:00</updated-at>
      <user-id type="integer">18806</user-id>
      <version type="integer">12</version>
      <user-name>Matthew Moore</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">1</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I responded to your post at http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/1145-bug-invalidauthenticitytoken-incorrectly-raised-for-xml-controllerdestroy-request#ticket-1145-3

I don't think this ticket should be re-opened, let's discuss the issue there.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I responded to your post at &lt;a href=&quot;http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/1145-bug-invalidauthenticitytoken-incorrectly-raised-for-xml-controllerdestroy-request#ticket-1145-3&quot;&gt;
http://rails.lighthouseapp.com/p...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I don't think this ticket should be re-opened, let's discuss the
issue there.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-10-01T07:10:58+01:00</created-at>
      <creator-id type="integer">18887</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">73</number>
      <permalink>security-bug-request-forgery-protection-checks-for-accept-header-instead-of-content-type-header</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>resolved</state>
      <tag>actionpack &quot;request-forgery-protection&quot; security</tag>
      <title>SECURITY BUG - Request Forgery protection checks for 'Accept' header instead of 'Content-Type' header</title>
      <updated-at type="datetime">2008-10-01T07:10:59+01:00</updated-at>
      <user-id type="integer">18887</user-id>
      <version type="integer">13</version>
      <user-name>Mathijs Kwik</user-name>
      <creator-name>Mathijs Kwik</creator-name>
      <assigned-user-name>Rick</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/73</url>
      <priority-name nil="true"></priority-name>
    </version>
  </versions>
  <attachments type="array">
    <attachment type="Attachment">
      <code>52c3169d610b57ca939a12fda1d23f7c5ab7d710</code>
      <content-type>text/plain</content-type>
      <created-at type="datetime">2008-05-06T09:33:03+01:00</created-at>
      <filename>0001-Change-the-request-forgery-protection-to-go-by-Conte.patch</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">21675</id>
      <size type="integer">3989</size>
      <uploader-id type="integer">1</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/21675/0001-Change-the-request-forgery-protection-to-go-by-Conte.patch</url>
    </attachment>
  </attachments>
</ticket>
