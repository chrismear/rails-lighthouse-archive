<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer" nil="true"></assigned-user-id>
  <attachments-count type="integer">0</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2008-10-15T23:31:37+01:00</created-at>
  <creator-id type="integer">27426</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer">9903</milestone-id>
  <number type="integer">1222</number>
  <permalink>mixing-joins-and-include-conflicts</permalink>
  <priority type="integer">629</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>duplicate</state>
  <tag nil="true"></tag>
  <title>Mixing joins and include conflicts</title>
  <updated-at type="datetime">2008-12-18T11:33:00+00:00</updated-at>
  <user-id type="integer">17477</user-id>
  <version type="integer">2</version>
  <user-name>Frederick Cheung</user-name>
  <creator-name>El&#237;as Orozco</creator-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/1222</url>
  <milestone-title>2.x</milestone-title>
  <priority-name nil="true"></priority-name>
  <original-body>I have found that Rails doesn't works well when mixing joins and includes. For example I have the following models: Event, Attendance and User. 

@@@
class Event &lt; ActiveRecord::Base

# User that creates the event
belongs_to :created_by, 
           :select =&gt; &quot;id, name, lastname&quot;,
           :foreign_key =&gt; &quot;user_id&quot;, 
           :class_name =&gt; &quot;User&quot;
has_many :attendances
has_many :users, :through =&gt; :attendances

############################################

class Attendance &lt; ActiveRecord::Base

belongs_to :event
belongs_to :user

############################################

class User &lt; ActiveRecord::Base

has_many :attendances
has_many :events, :through =&gt; :attendances

@@@

The events table has a boolean attribute called private (1 if event is private, 0 instead). So basically let's imagine we want to fetch all the events I can attend, that is, all the events that are public and those that are private and I've been invited. 

The query should be like this:                

@@@
Event.find(:all, 
           :include =&gt; [:created_by],
           :joins =&gt; &quot;LEFT OUTER JOIN attendances ON 
                      attendances.event_id = events.id&quot;,
           :conditions =&gt; [&quot;((events.private = 0) OR 
                             (events.private = 1 AND  
                              attendances.user_id = ?))&quot;,
                              current_user],  
           :order =&gt; &quot;events.start_date DESC&quot;)
@@@

From this query I should expect something like this on my development log.

@@@

SELECT events.* 
FROM events
LEFT OUTER JOIN attendances ON attendances.event_id = events.id
WHERE ((events.private = 0) OR 
       (events.private = 1 AND  
        attendances.user_id = 1))
ORDER BY events.start_date DESC

SELECT id, name, lastname FROM users WHERE id IN (3,4,7)

@@@

But this is what really happens. Here's the real query generated by rails on my development log. 

@@@
SELECT `events`.`id` AS t0_r0, `events`.`start_date` AS t0_r1, `events`.`title` AS t0_r2, `events`.`place` AS t0_r3, `events`.`description` AS t0_r4, `events`.`user_id` AS t0_r5, `events`.`event_category_id` AS t0_r6, `events`.`created_at` AS t0_r7, `events`.`updated_at` AS t0_r8, `events`.`neighborhood_id` AS t0_r9, `events`.`end_date` AS t0_r10, `events`.`private` AS t0_r11, `users`.`id` AS t1_r0, `users`.`email` AS t1_r1, `users`.`crypted_password` AS t1_r2, `users`.`salt` AS t1_r3, `users`.`name` AS t1_r4, `users`.`lastname` AS t1_r5, `users`.`gender` AS t1_r6, `users`.`zipcode` AS t1_r7, `users`.`birthday` AS t1_r8, `users`.`remember_token` AS t1_r9, `users`.`remember_token_expires_at` AS t1_r10, `users`.`activation_code` AS t1_r11, `users`.`activated_at` AS t1_r12, `users`.`created_at` AS t1_r13, `users`.`updated_at` AS t1_r14, `users`.`photo_file_name` AS t1_r15, `users`.`photo_content_type` AS t1_r16, `users`.`photo_file_size` AS t1_r17, `users`.`status_message` AS t1_r18, `users`.`status_update` AS t1_r19, `users`.`state` AS t1_r20 FROM `events` LEFT OUTER JOIN `users` ON `users`.id = `events`.user_id LEFT OUTER JOIN attendances ON attendances.event_id = events.id WHERE (((events.private = 0) OR (events.private = 1 AND attendances.user_id = 1))) ORDER BY events.start_date DESC
@@@

As you can see the query sort of works, but not in the way it should. A lot of alias are created and more columns are selected than the ones I specify. So well, here I leave it and hope someone has noticed this too so we can work on it.</original-body>
  <latest-body>I have found that Rails doesn't works well when mixing joins and includes. For example I have the following models: Event, Attendance and User. 

@@@
class Event &lt; ActiveRecord::Base

# User that creates the event
belongs_to :created_by, 
           :select =&gt; &quot;id, name, lastname&quot;,
           :foreign_key =&gt; &quot;user_id&quot;, 
           :class_name =&gt; &quot;User&quot;
has_many :attendances
has_many :users, :through =&gt; :attendances

############################################

class Attendance &lt; ActiveRecord::Base

belongs_to :event
belongs_to :user

############################################

class User &lt; ActiveRecord::Base

has_many :attendances
has_many :events, :through =&gt; :attendances

@@@

The events table has a boolean attribute called private (1 if event is private, 0 instead). So basically let's imagine we want to fetch all the events I can attend, that is, all the events that are public and those that are private and I've been invited. 

The query should be like this:                

@@@
Event.find(:all, 
           :include =&gt; [:created_by],
           :joins =&gt; &quot;LEFT OUTER JOIN attendances ON 
                      attendances.event_id = events.id&quot;,
           :conditions =&gt; [&quot;((events.private = 0) OR 
                             (events.private = 1 AND  
                              attendances.user_id = ?))&quot;,
                              current_user],  
           :order =&gt; &quot;events.start_date DESC&quot;)
@@@

From this query I should expect something like this on my development log.

@@@

SELECT events.* 
FROM events
LEFT OUTER JOIN attendances ON attendances.event_id = events.id
WHERE ((events.private = 0) OR 
       (events.private = 1 AND  
        attendances.user_id = 1))
ORDER BY events.start_date DESC

SELECT id, name, lastname FROM users WHERE id IN (3,4,7)

@@@

But this is what really happens. Here's the real query generated by rails on my development log. 

@@@
SELECT `events`.`id` AS t0_r0, `events`.`start_date` AS t0_r1, `events`.`title` AS t0_r2, `events`.`place` AS t0_r3, `events`.`description` AS t0_r4, `events`.`user_id` AS t0_r5, `events`.`event_category_id` AS t0_r6, `events`.`created_at` AS t0_r7, `events`.`updated_at` AS t0_r8, `events`.`neighborhood_id` AS t0_r9, `events`.`end_date` AS t0_r10, `events`.`private` AS t0_r11, `users`.`id` AS t1_r0, `users`.`email` AS t1_r1, `users`.`crypted_password` AS t1_r2, `users`.`salt` AS t1_r3, `users`.`name` AS t1_r4, `users`.`lastname` AS t1_r5, `users`.`gender` AS t1_r6, `users`.`zipcode` AS t1_r7, `users`.`birthday` AS t1_r8, `users`.`remember_token` AS t1_r9, `users`.`remember_token_expires_at` AS t1_r10, `users`.`activation_code` AS t1_r11, `users`.`activated_at` AS t1_r12, `users`.`created_at` AS t1_r13, `users`.`updated_at` AS t1_r14, `users`.`photo_file_name` AS t1_r15, `users`.`photo_content_type` AS t1_r16, `users`.`photo_file_size` AS t1_r17, `users`.`status_message` AS t1_r18, `users`.`status_update` AS t1_r19, `users`.`state` AS t1_r20 FROM `events` LEFT OUTER JOIN `users` ON `users`.id = `events`.user_id LEFT OUTER JOIN attendances ON attendances.event_id = events.id WHERE (((events.private = 0) OR (events.private = 1 AND attendances.user_id = 1))) ORDER BY events.start_date DESC
@@@

As you can see the query sort of works, but not in the way it should. A lot of alias are created and more columns are selected than the ones I specify. So well, here I leave it and hope someone has noticed this too so we can work on it.</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;I have found that Rails doesn't works well when mixing joins and
includes. For example I have the following models: Event,
Attendance and User.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
class Event &amp;lt; ActiveRecord::Base

# User that creates the event
belongs_to :created_by,
           :select =&amp;gt; &amp;quot;id, name, lastname&amp;quot;,
           :foreign_key =&amp;gt; &amp;quot;user_id&amp;quot;,
           :class_name =&amp;gt; &amp;quot;User&amp;quot;
has_many :attendances
has_many :users, :through =&amp;gt; :attendances

############################################

class Attendance &amp;lt; ActiveRecord::Base

belongs_to :event
belongs_to :user

############################################

class User &amp;lt; ActiveRecord::Base

has_many :attendances
has_many :events, :through =&amp;gt; :attendances

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The events table has a boolean attribute called private (1 if
event is private, 0 instead). So basically let's imagine we want to
fetch all the events I can attend, that is, all the events that are
public and those that are private and I've been invited.&lt;/p&gt;
&lt;p&gt;The query should be like this:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
Event.find(:all,
           :include =&amp;gt; [:created_by],
           :joins =&amp;gt; &amp;quot;LEFT OUTER JOIN attendances ON
                      attendances.event_id = events.id&amp;quot;,
           :conditions =&amp;gt; [&amp;quot;((events.private = 0) OR
                             (events.private = 1 AND
                              attendances.user_id = ?))&amp;quot;,
                              current_user],
           :order =&amp;gt; &amp;quot;events.start_date DESC&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this query I should expect something like this on my
development log.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;

SELECT events.*
FROM events
LEFT OUTER JOIN attendances ON attendances.event_id = events.id
WHERE ((events.private = 0) OR
       (events.private = 1 AND
        attendances.user_id = 1))
ORDER BY events.start_date DESC

SELECT id, name, lastname FROM users WHERE id IN (3,4,7)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this is what really happens. Here's the real query generated
by rails on my development log.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
SELECT `events`.`id` AS t0_r0, `events`.`start_date` AS t0_r1, `events`.`title` AS t0_r2, `events`.`place` AS t0_r3, `events`.`description` AS t0_r4, `events`.`user_id` AS t0_r5, `events`.`event_category_id` AS t0_r6, `events`.`created_at` AS t0_r7, `events`.`updated_at` AS t0_r8, `events`.`neighborhood_id` AS t0_r9, `events`.`end_date` AS t0_r10, `events`.`private` AS t0_r11, `users`.`id` AS t1_r0, `users`.`email` AS t1_r1, `users`.`crypted_password` AS t1_r2, `users`.`salt` AS t1_r3, `users`.`name` AS t1_r4, `users`.`lastname` AS t1_r5, `users`.`gender` AS t1_r6, `users`.`zipcode` AS t1_r7, `users`.`birthday` AS t1_r8, `users`.`remember_token` AS t1_r9, `users`.`remember_token_expires_at` AS t1_r10, `users`.`activation_code` AS t1_r11, `users`.`activated_at` AS t1_r12, `users`.`created_at` AS t1_r13, `users`.`updated_at` AS t1_r14, `users`.`photo_file_name` AS t1_r15, `users`.`photo_content_type` AS t1_r16, `users`.`photo_file_size` AS t1_r17, `users`.`status_message` AS t1_r18, `users`.`status_update` AS t1_r19, `users`.`state` AS t1_r20 FROM `events` LEFT OUTER JOIN `users` ON `users`.id = `events`.user_id LEFT OUTER JOIN attendances ON attendances.event_id = events.id WHERE (((events.private = 0) OR (events.private = 1 AND attendances.user_id = 1))) ORDER BY events.start_date DESC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see the query sort of works, but not in the way it
should. A lot of alias are created and more columns are selected
than the ones I specify. So well, here I leave it and hope someone
has noticed this too so we can work on it.&lt;/p&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I have found that Rails doesn't works well when mixing joins and includes. For example I have the following models: Event, Attendance and User. 

@@@
class Event &lt; ActiveRecord::Base

# User that creates the event
belongs_to :created_by, 
           :select =&gt; &quot;id, name, lastname&quot;,
           :foreign_key =&gt; &quot;user_id&quot;, 
           :class_name =&gt; &quot;User&quot;
has_many :attendances
has_many :users, :through =&gt; :attendances

############################################

class Attendance &lt; ActiveRecord::Base

belongs_to :event
belongs_to :user

############################################

class User &lt; ActiveRecord::Base

has_many :attendances
has_many :events, :through =&gt; :attendances

@@@

The events table has a boolean attribute called private (1 if event is private, 0 instead). So basically let's imagine we want to fetch all the events I can attend, that is, all the events that are public and those that are private and I've been invited. 

The query should be like this:                

@@@
Event.find(:all, 
           :include =&gt; [:created_by],
           :joins =&gt; &quot;LEFT OUTER JOIN attendances ON 
                      attendances.event_id = events.id&quot;,
           :conditions =&gt; [&quot;((events.private = 0) OR 
                             (events.private = 1 AND  
                              attendances.user_id = ?))&quot;,
                              current_user],  
           :order =&gt; &quot;events.start_date DESC&quot;)
@@@

From this query I should expect something like this on my development log.

@@@

SELECT events.* 
FROM events
LEFT OUTER JOIN attendances ON attendances.event_id = events.id
WHERE ((events.private = 0) OR 
       (events.private = 1 AND  
        attendances.user_id = 1))
ORDER BY events.start_date DESC

SELECT id, name, lastname FROM users WHERE id IN (3,4,7)

@@@

But this is what really happens. Here's the real query generated by rails on my development log. 

@@@
SELECT `events`.`id` AS t0_r0, `events`.`start_date` AS t0_r1, `events`.`title` AS t0_r2, `events`.`place` AS t0_r3, `events`.`description` AS t0_r4, `events`.`user_id` AS t0_r5, `events`.`event_category_id` AS t0_r6, `events`.`created_at` AS t0_r7, `events`.`updated_at` AS t0_r8, `events`.`neighborhood_id` AS t0_r9, `events`.`end_date` AS t0_r10, `events`.`private` AS t0_r11, `users`.`id` AS t1_r0, `users`.`email` AS t1_r1, `users`.`crypted_password` AS t1_r2, `users`.`salt` AS t1_r3, `users`.`name` AS t1_r4, `users`.`lastname` AS t1_r5, `users`.`gender` AS t1_r6, `users`.`zipcode` AS t1_r7, `users`.`birthday` AS t1_r8, `users`.`remember_token` AS t1_r9, `users`.`remember_token_expires_at` AS t1_r10, `users`.`activation_code` AS t1_r11, `users`.`activated_at` AS t1_r12, `users`.`created_at` AS t1_r13, `users`.`updated_at` AS t1_r14, `users`.`photo_file_name` AS t1_r15, `users`.`photo_content_type` AS t1_r16, `users`.`photo_file_size` AS t1_r17, `users`.`status_message` AS t1_r18, `users`.`status_update` AS t1_r19, `users`.`state` AS t1_r20 FROM `events` LEFT OUTER JOIN `users` ON `users`.id = `events`.user_id LEFT OUTER JOIN attendances ON attendances.event_id = events.id WHERE (((events.private = 0) OR (events.private = 1 AND attendances.user_id = 1))) ORDER BY events.start_date DESC
@@@

As you can see the query sort of works, but not in the way it should. A lot of alias are created and more columns are selected than the ones I specify. So well, here I leave it and hope someone has noticed this too so we can work on it.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I have found that Rails doesn't works well when mixing joins and
includes. For example I have the following models: Event,
Attendance and User.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
class Event &amp;lt; ActiveRecord::Base

# User that creates the event
belongs_to :created_by,
           :select =&amp;gt; &amp;quot;id, name, lastname&amp;quot;,
           :foreign_key =&amp;gt; &amp;quot;user_id&amp;quot;,
           :class_name =&amp;gt; &amp;quot;User&amp;quot;
has_many :attendances
has_many :users, :through =&amp;gt; :attendances

############################################

class Attendance &amp;lt; ActiveRecord::Base

belongs_to :event
belongs_to :user

############################################

class User &amp;lt; ActiveRecord::Base

has_many :attendances
has_many :events, :through =&amp;gt; :attendances

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The events table has a boolean attribute called private (1 if
event is private, 0 instead). So basically let's imagine we want to
fetch all the events I can attend, that is, all the events that are
public and those that are private and I've been invited.&lt;/p&gt;
&lt;p&gt;The query should be like this:&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
Event.find(:all,
           :include =&amp;gt; [:created_by],
           :joins =&amp;gt; &amp;quot;LEFT OUTER JOIN attendances ON
                      attendances.event_id = events.id&amp;quot;,
           :conditions =&amp;gt; [&amp;quot;((events.private = 0) OR
                             (events.private = 1 AND
                              attendances.user_id = ?))&amp;quot;,
                              current_user],
           :order =&amp;gt; &amp;quot;events.start_date DESC&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this query I should expect something like this on my
development log.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;

SELECT events.*
FROM events
LEFT OUTER JOIN attendances ON attendances.event_id = events.id
WHERE ((events.private = 0) OR
       (events.private = 1 AND
        attendances.user_id = 1))
ORDER BY events.start_date DESC

SELECT id, name, lastname FROM users WHERE id IN (3,4,7)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this is what really happens. Here's the real query generated
by rails on my development log.&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;
SELECT `events`.`id` AS t0_r0, `events`.`start_date` AS t0_r1, `events`.`title` AS t0_r2, `events`.`place` AS t0_r3, `events`.`description` AS t0_r4, `events`.`user_id` AS t0_r5, `events`.`event_category_id` AS t0_r6, `events`.`created_at` AS t0_r7, `events`.`updated_at` AS t0_r8, `events`.`neighborhood_id` AS t0_r9, `events`.`end_date` AS t0_r10, `events`.`private` AS t0_r11, `users`.`id` AS t1_r0, `users`.`email` AS t1_r1, `users`.`crypted_password` AS t1_r2, `users`.`salt` AS t1_r3, `users`.`name` AS t1_r4, `users`.`lastname` AS t1_r5, `users`.`gender` AS t1_r6, `users`.`zipcode` AS t1_r7, `users`.`birthday` AS t1_r8, `users`.`remember_token` AS t1_r9, `users`.`remember_token_expires_at` AS t1_r10, `users`.`activation_code` AS t1_r11, `users`.`activated_at` AS t1_r12, `users`.`created_at` AS t1_r13, `users`.`updated_at` AS t1_r14, `users`.`photo_file_name` AS t1_r15, `users`.`photo_content_type` AS t1_r16, `users`.`photo_file_size` AS t1_r17, `users`.`status_message` AS t1_r18, `users`.`status_update` AS t1_r19, `users`.`state` AS t1_r20 FROM `events` LEFT OUTER JOIN `users` ON `users`.id = `events`.user_id LEFT OUTER JOIN attendances ON attendances.event_id = events.id WHERE (((events.private = 0) OR (events.private = 1 AND attendances.user_id = 1))) ORDER BY events.start_date DESC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see the query sort of works, but not in the way it
should. A lot of alias are created and more columns are selected
than the ones I specify. So well, here I leave it and hope someone
has noticed this too so we can work on it.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2008-10-15T23:31:37+01:00</created-at>
      <creator-id type="integer">27426</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1222</number>
      <permalink>mixing-joins-and-include-conflicts</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>Mixing joins and include conflicts</title>
      <updated-at type="datetime">2008-10-15T23:31:38+01:00</updated-at>
      <user-id type="integer">27426</user-id>
      <version type="integer">1</version>
      <user-name>El&#237;as Orozco</user-name>
      <creator-name>El&#237;as Orozco</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1222</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Duplicate of #528</body>
      <body-html>&lt;div&gt;&lt;p&gt;Duplicate of &lt;a href=&quot;/projects/8994/tickets/528&quot; title=&quot;Ticket #528&quot;&gt;#528&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2008-12-18T11:32:55+00:00</created-at>
      <creator-id type="integer">27426</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
</diffable-attributes>
      <milestone-id type="integer">9903</milestone-id>
      <number type="integer">1222</number>
      <permalink>mixing-joins-and-include-conflicts</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag nil="true"></tag>
      <title>Mixing joins and include conflicts</title>
      <updated-at type="datetime">2008-12-18T11:33:00+00:00</updated-at>
      <user-id type="integer">17477</user-id>
      <version type="integer">2</version>
      <user-name>Frederick Cheung</user-name>
      <creator-name>El&#237;as Orozco</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/1222</url>
      <milestone-title>2.x</milestone-title>
      <priority-name nil="true"></priority-name>
    </version>
  </versions>
</ticket>
