<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer" nil="true"></assigned-user-id>
  <attachments-count type="integer">1</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2011-02-19T09:28:21+00:00</created-at>
  <creator-id type="integer">82126</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer" nil="true"></milestone-id>
  <number type="integer">3680</number>
  <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
  <priority type="integer">3</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>stale</state>
  <tag nil="true"></tag>
  <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
  <updated-at type="datetime">2011-02-19T09:28:21+00:00</updated-at>
  <user-id type="integer">40272</user-id>
  <version type="integer">11</version>
  <user-name>Santiago Pastorino</user-name>
  <creator-name>Matthew O'Riordan</creator-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
  <priority-name>Low</priority-name>
  <original-body>I have discovered an easily replicable bug in ActiveRecord when calling the create method on a scope.  However, strangely when using the build method and then calling save immediately afterwards, it works perfectly, which leads me to believe there is definitely a bug in the way create is implemented.

The error I receive is &quot;ActiveRecord::RecordNotFound: Couldn't find Thing with ID=446545869&quot;, yet a Thing does exist in the database with that ID.  When using the build method, this error does not occur.

Here is how the problem is replicated:

### db/migrate/20100101_create_things.rb Migration code to set up model ###

@@@
class CreateThings &lt; ActiveRecord::Migration
  def self.up
    create_table :things do |t|
      t.string :name
      t.integer :parent_id
      t.timestamps
    end
  end

  def self.down
    drop_table :things
  end
end
@@@

### test/fixutres/things.yml Fixtures code used to run tests which fail ###
@@@
us:
  name: United States

california:
  name: California
  parent_id: &lt;%= Fixtures.identify(:us) %&gt;
  
florida:
  name: Florida
  parent_id: &lt;%= Fixtures.identify(:us) %&gt;

sanfran:
  name: San Francisco
  parent_id: &lt;%= Fixtures.identify(:california) %&gt;
  
sandiego:
  name: San Diego
  parent_id: &lt;%= Fixtures.identify(:california) %&gt;
  
miami:
  name: Miami
  parent_id: &lt;%= Fixtures.identify(:florida) %&gt;
  
daytona:
  name: Daytona
  parent_id: &lt;%= Fixtures.identify(:florida) %&gt;
@@@

### models/thing.rb Model code which has named scopes ###
@@@
class Thing &lt; ActiveRecord::Base
  # some debugging output to demonstrate the error 
  def before_save
    puts &quot;Before save called for #{name}, parent id: #{parent_id}, self: #{self.inspect}&quot;
    puts &quot;Parent #{parent.name} with id #{parent.id} found&quot; if parent # this fails when create method called
  end
  
  def children
    self.class.scoped :conditions =&gt; { &quot;parent_id&quot; =&gt; id }
  end
  
  def parent 
    self.class.find(parent_id) if parent_id
  end
end
@@@

### /test/unit/thing_test.rb Unit test code which fails ###
@@@
require 'test_helper'

class ThingTest &lt; ActiveSupport::TestCase
  test &quot;creation of children objects&quot; do
    us = things(:us)
    assert_not_nil(Thing.create(:name =&gt; &quot;United Kingdom&quot;), &quot;Created a root element&quot;)
    assert(us.children.first.children.first.parent.parent == us, &quot;Iterate down tree and back up to US did not work&quot;)
    assert(things(:daytona).parent == things(:florida), &quot;Parent not working&quot;)
    
    nevada = us.children.build(:name =&gt; &quot;Nevada&quot;)
    assert(nevada.save, &quot;Could not save Nevada with build statement&quot;)
    assert(nevada.parent == us, &quot;Nevada's parent should be the US&quot;)
    
    arizona = us.children.create(:name =&gt; &quot;Arizona&quot;) # a runtime error is raised when this method is called
    assert_not_nil(arizona, &quot;Could not save Arizona with create statement&quot;)
    assert(arizona.parent == us, &quot;Arizona's parent should be the US&quot;)
  end
end
@@@

As you will see when you run the unit test, the us.children.create method will fail.
Strangely when inspecting the actual Thing objet, it looks exactly the same when it fails versus when it does not i.e. it is &quot;#&lt;Thing id: nil, name: &quot;Nevada&quot;, parent_id: 446545869, created_at: nil, updated_at: nil&gt;&quot;

Give me a shout if there is anything I can help with.  I have attached the code I used to replicate this issue if that helps.

Matt
http://mattheworiordan.com</original-body>
  <latest-body>I have discovered an easily replicable bug in ActiveRecord when calling the create method on a scope.  However, strangely when using the build method and then calling save immediately afterwards, it works perfectly, which leads me to believe there is definitely a bug in the way create is implemented.

The error I receive is &quot;ActiveRecord::RecordNotFound: Couldn't find Thing with ID=446545869&quot;, yet a Thing does exist in the database with that ID.  When using the build method, this error does not occur.

Here is how the problem is replicated:

### db/migrate/20100101_create_things.rb Migration code to set up model ###

@@@
class CreateThings &lt; ActiveRecord::Migration
  def self.up
    create_table :things do |t|
      t.string :name
      t.integer :parent_id
      t.timestamps
    end
  end

  def self.down
    drop_table :things
  end
end
@@@

### test/fixutres/things.yml Fixtures code used to run tests which fail ###
@@@
us:
  name: United States

california:
  name: California
  parent_id: &lt;%= Fixtures.identify(:us) %&gt;
  
florida:
  name: Florida
  parent_id: &lt;%= Fixtures.identify(:us) %&gt;

sanfran:
  name: San Francisco
  parent_id: &lt;%= Fixtures.identify(:california) %&gt;
  
sandiego:
  name: San Diego
  parent_id: &lt;%= Fixtures.identify(:california) %&gt;
  
miami:
  name: Miami
  parent_id: &lt;%= Fixtures.identify(:florida) %&gt;
  
daytona:
  name: Daytona
  parent_id: &lt;%= Fixtures.identify(:florida) %&gt;
@@@

### models/thing.rb Model code which has named scopes ###
@@@
class Thing &lt; ActiveRecord::Base
  # some debugging output to demonstrate the error 
  def before_save
    puts &quot;Before save called for #{name}, parent id: #{parent_id}, self: #{self.inspect}&quot;
    puts &quot;Parent #{parent.name} with id #{parent.id} found&quot; if parent # this fails when create method called
  end
  
  def children
    self.class.scoped :conditions =&gt; { &quot;parent_id&quot; =&gt; id }
  end
  
  def parent 
    self.class.find(parent_id) if parent_id
  end
end
@@@

### /test/unit/thing_test.rb Unit test code which fails ###
@@@
require 'test_helper'

class ThingTest &lt; ActiveSupport::TestCase
  test &quot;creation of children objects&quot; do
    us = things(:us)
    assert_not_nil(Thing.create(:name =&gt; &quot;United Kingdom&quot;), &quot;Created a root element&quot;)
    assert(us.children.first.children.first.parent.parent == us, &quot;Iterate down tree and back up to US did not work&quot;)
    assert(things(:daytona).parent == things(:florida), &quot;Parent not working&quot;)
    
    nevada = us.children.build(:name =&gt; &quot;Nevada&quot;)
    assert(nevada.save, &quot;Could not save Nevada with build statement&quot;)
    assert(nevada.parent == us, &quot;Nevada's parent should be the US&quot;)
    
    arizona = us.children.create(:name =&gt; &quot;Arizona&quot;) # a runtime error is raised when this method is called
    assert_not_nil(arizona, &quot;Could not save Arizona with create statement&quot;)
    assert(arizona.parent == us, &quot;Arizona's parent should be the US&quot;)
  end
end
@@@

As you will see when you run the unit test, the us.children.create method will fail.
Strangely when inspecting the actual Thing objet, it looks exactly the same when it fails versus when it does not i.e. it is &quot;#&lt;Thing id: nil, name: &quot;Nevada&quot;, parent_id: 446545869, created_at: nil, updated_at: nil&gt;&quot;

Give me a shout if there is anything I can help with.  I have attached the code I used to replicate this issue if that helps.

Matt
http://mattheworiordan.com</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;I have discovered an easily replicable bug in ActiveRecord when
calling the create method on a scope. However, strangely when using
the build method and then calling save immediately afterwards, it
works perfectly, which leads me to believe there is definitely a
bug in the way create is implemented.&lt;/p&gt;
&lt;p&gt;The error I receive is &quot;ActiveRecord::RecordNotFound: Couldn't
find Thing with ID=446545869&quot;, yet a Thing does exist in the
database with that ID. When using the build method, this error does
not occur.&lt;/p&gt;
&lt;p&gt;Here is how the problem is replicated:&lt;/p&gt;
&lt;h3&gt;db/migrate/20100101_create_things.rb Migration code to set up
model&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class CreateThings &amp;lt; ActiveRecord::Migration
  def self.up
    create_table :things do |t|
      t.string :name
      t.integer :parent_id
      t.timestamps
    end
  end

  def self.down
    drop_table :things
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;test/fixutres/things.yml Fixtures code used to run tests which
fail&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;us:
  name: United States

california:
  name: California
  parent_id: &amp;lt;%= Fixtures.identify(:us) %&amp;gt;
  
florida:
  name: Florida
  parent_id: &amp;lt;%= Fixtures.identify(:us) %&amp;gt;

sanfran:
  name: San Francisco
  parent_id: &amp;lt;%= Fixtures.identify(:california) %&amp;gt;
  
sandiego:
  name: San Diego
  parent_id: &amp;lt;%= Fixtures.identify(:california) %&amp;gt;
  
miami:
  name: Miami
  parent_id: &amp;lt;%= Fixtures.identify(:florida) %&amp;gt;
  
daytona:
  name: Daytona
  parent_id: &amp;lt;%= Fixtures.identify(:florida) %&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;models/thing.rb Model code which has named scopes&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class Thing &amp;lt; ActiveRecord::Base
  # some debugging output to demonstrate the error 
  def before_save
    puts &quot;Before save called for #{name}, parent id: #{parent_id}, self: #{self.inspect}&quot;
    puts &quot;Parent #{parent.name} with id #{parent.id} found&quot; if parent # this fails when create method called
  end
  
  def children
    self.class.scoped :conditions =&amp;gt; { &quot;parent_id&quot; =&amp;gt; id }
  end
  
  def parent 
    self.class.find(parent_id) if parent_id
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;/test/unit/thing_test.rb Unit test code which fails&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;require 'test_helper'

class ThingTest &amp;lt; ActiveSupport::TestCase
  test &quot;creation of children objects&quot; do
    us = things(:us)
    assert_not_nil(Thing.create(:name =&amp;gt; &quot;United Kingdom&quot;), &quot;Created a root element&quot;)
    assert(us.children.first.children.first.parent.parent == us, &quot;Iterate down tree and back up to US did not work&quot;)
    assert(things(:daytona).parent == things(:florida), &quot;Parent not working&quot;)
    
    nevada = us.children.build(:name =&amp;gt; &quot;Nevada&quot;)
    assert(nevada.save, &quot;Could not save Nevada with build statement&quot;)
    assert(nevada.parent == us, &quot;Nevada's parent should be the US&quot;)
    
    arizona = us.children.create(:name =&amp;gt; &quot;Arizona&quot;) # a runtime error is raised when this method is called
    assert_not_nil(arizona, &quot;Could not save Arizona with create statement&quot;)
    assert(arizona.parent == us, &quot;Arizona's parent should be the US&quot;)
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;As you will see when you run the unit test, the
us.children.create method will fail.&lt;br&gt;
Strangely when inspecting the actual Thing objet, it looks exactly
the same when it fails versus when it does not i.e. it is &quot;#&quot;&lt;/p&gt;
&lt;p&gt;Give me a shout if there is anything I can help with. I have
attached the code I used to replicate this issue if that helps.&lt;/p&gt;
&lt;p&gt;Matt&lt;br&gt;
&lt;a href=
&quot;http://mattheworiordan.com&quot;&gt;http://mattheworiordan.com&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I have discovered an easily replicable bug in ActiveRecord when calling the create method on a scope.  However, strangely when using the build method and then calling save immediately afterwards, it works perfectly, which leads me to believe there is definitely a bug in the way create is implemented.

The error I receive is &quot;ActiveRecord::RecordNotFound: Couldn't find Thing with ID=446545869&quot;, yet a Thing does exist in the database with that ID.  When using the build method, this error does not occur.

Here is how the problem is replicated:

### db/migrate/20100101_create_things.rb Migration code to set up model ###

@@@
class CreateThings &lt; ActiveRecord::Migration
  def self.up
    create_table :things do |t|
      t.string :name
      t.integer :parent_id
      t.timestamps
    end
  end

  def self.down
    drop_table :things
  end
end
@@@

### test/fixutres/things.yml Fixtures code used to run tests which fail ###
@@@
us:
  name: United States

california:
  name: California
  parent_id: &lt;%= Fixtures.identify(:us) %&gt;
  
florida:
  name: Florida
  parent_id: &lt;%= Fixtures.identify(:us) %&gt;

sanfran:
  name: San Francisco
  parent_id: &lt;%= Fixtures.identify(:california) %&gt;
  
sandiego:
  name: San Diego
  parent_id: &lt;%= Fixtures.identify(:california) %&gt;
  
miami:
  name: Miami
  parent_id: &lt;%= Fixtures.identify(:florida) %&gt;
  
daytona:
  name: Daytona
  parent_id: &lt;%= Fixtures.identify(:florida) %&gt;
@@@

### models/thing.rb Model code which has named scopes ###
@@@
class Thing &lt; ActiveRecord::Base
  # some debugging output to demonstrate the error 
  def before_save
    puts &quot;Before save called for #{name}, parent id: #{parent_id}, self: #{self.inspect}&quot;
    puts &quot;Parent #{parent.name} with id #{parent.id} found&quot; if parent # this fails when create method called
  end
  
  def children
    self.class.scoped :conditions =&gt; { &quot;parent_id&quot; =&gt; id }
  end
  
  def parent 
    self.class.find(parent_id) if parent_id
  end
end
@@@

### /test/unit/thing_test.rb Unit test code which fails ###
@@@
require 'test_helper'

class ThingTest &lt; ActiveSupport::TestCase
  test &quot;creation of children objects&quot; do
    us = things(:us)
    assert_not_nil(Thing.create(:name =&gt; &quot;United Kingdom&quot;), &quot;Created a root element&quot;)
    assert(us.children.first.children.first.parent.parent == us, &quot;Iterate down tree and back up to US did not work&quot;)
    assert(things(:daytona).parent == things(:florida), &quot;Parent not working&quot;)
    
    nevada = us.children.build(:name =&gt; &quot;Nevada&quot;)
    assert(nevada.save, &quot;Could not save Nevada with build statement&quot;)
    assert(nevada.parent == us, &quot;Nevada's parent should be the US&quot;)
    
    arizona = us.children.create(:name =&gt; &quot;Arizona&quot;) # a runtime error is raised when this method is called
    assert_not_nil(arizona, &quot;Could not save Arizona with create statement&quot;)
    assert(arizona.parent == us, &quot;Arizona's parent should be the US&quot;)
  end
end
@@@

As you will see when you run the unit test, the us.children.create method will fail.
Strangely when inspecting the actual Thing objet, it looks exactly the same when it fails versus when it does not i.e. it is &quot;#&lt;Thing id: nil, name: &quot;Nevada&quot;, parent_id: 446545869, created_at: nil, updated_at: nil&gt;&quot;

Give me a shout if there is anything I can help with.  I have attached the code I used to replicate this issue if that helps.

Matt
http://mattheworiordan.com</body>
      <body-html>&lt;div&gt;&lt;p&gt;I have discovered an easily replicable bug in ActiveRecord when
calling the create method on a scope. However, strangely when using
the build method and then calling save immediately afterwards, it
works perfectly, which leads me to believe there is definitely a
bug in the way create is implemented.&lt;/p&gt;
&lt;p&gt;The error I receive is &quot;ActiveRecord::RecordNotFound: Couldn't
find Thing with ID=446545869&quot;, yet a Thing does exist in the
database with that ID. When using the build method, this error does
not occur.&lt;/p&gt;
&lt;p&gt;Here is how the problem is replicated:&lt;/p&gt;
&lt;h3&gt;db/migrate/20100101_create_things.rb Migration code to set up
model&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class CreateThings &amp;lt; ActiveRecord::Migration
  def self.up
    create_table :things do |t|
      t.string :name
      t.integer :parent_id
      t.timestamps
    end
  end

  def self.down
    drop_table :things
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;test/fixutres/things.yml Fixtures code used to run tests which
fail&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;us:
  name: United States

california:
  name: California
  parent_id: &amp;lt;%= Fixtures.identify(:us) %&amp;gt;
  
florida:
  name: Florida
  parent_id: &amp;lt;%= Fixtures.identify(:us) %&amp;gt;

sanfran:
  name: San Francisco
  parent_id: &amp;lt;%= Fixtures.identify(:california) %&amp;gt;
  
sandiego:
  name: San Diego
  parent_id: &amp;lt;%= Fixtures.identify(:california) %&amp;gt;
  
miami:
  name: Miami
  parent_id: &amp;lt;%= Fixtures.identify(:florida) %&amp;gt;
  
daytona:
  name: Daytona
  parent_id: &amp;lt;%= Fixtures.identify(:florida) %&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;models/thing.rb Model code which has named scopes&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class Thing &amp;lt; ActiveRecord::Base
  # some debugging output to demonstrate the error 
  def before_save
    puts &quot;Before save called for #{name}, parent id: #{parent_id}, self: #{self.inspect}&quot;
    puts &quot;Parent #{parent.name} with id #{parent.id} found&quot; if parent # this fails when create method called
  end
  
  def children
    self.class.scoped :conditions =&amp;gt; { &quot;parent_id&quot; =&amp;gt; id }
  end
  
  def parent 
    self.class.find(parent_id) if parent_id
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;/test/unit/thing_test.rb Unit test code which fails&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;require 'test_helper'

class ThingTest &amp;lt; ActiveSupport::TestCase
  test &quot;creation of children objects&quot; do
    us = things(:us)
    assert_not_nil(Thing.create(:name =&amp;gt; &quot;United Kingdom&quot;), &quot;Created a root element&quot;)
    assert(us.children.first.children.first.parent.parent == us, &quot;Iterate down tree and back up to US did not work&quot;)
    assert(things(:daytona).parent == things(:florida), &quot;Parent not working&quot;)
    
    nevada = us.children.build(:name =&amp;gt; &quot;Nevada&quot;)
    assert(nevada.save, &quot;Could not save Nevada with build statement&quot;)
    assert(nevada.parent == us, &quot;Nevada's parent should be the US&quot;)
    
    arizona = us.children.create(:name =&amp;gt; &quot;Arizona&quot;) # a runtime error is raised when this method is called
    assert_not_nil(arizona, &quot;Could not save Arizona with create statement&quot;)
    assert(arizona.parent == us, &quot;Arizona's parent should be the US&quot;)
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;As you will see when you run the unit test, the
us.children.create method will fail.&lt;br&gt;
Strangely when inspecting the actual Thing objet, it looks exactly
the same when it fails versus when it does not i.e. it is &quot;#&quot;&lt;/p&gt;
&lt;p&gt;Give me a shout if there is anything I can help with. I have
attached the code I used to replicate this issue if that helps.&lt;/p&gt;
&lt;p&gt;Matt&lt;br&gt;
&lt;a href=
&quot;http://mattheworiordan.com&quot;&gt;http://mattheworiordan.com&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-01-10T17:07:55+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-01-10T17:11:40+00:00</updated-at>
      <user-id type="integer">82126</user-id>
      <version type="integer">1</version>
      <user-name>Matthew O'Riordan</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Hi Matt,

This is (arguably) a subtle problem with your code rather than a bug in ActiveRecord.

The issue is that `find` and `create` methods called within a scope execute with that scope applied, i.e. for the duration of the method's execution you inherit the scope's arguments on every `find`/`create` that you call, which of course is the whole point of a scope.

This is causing problems here because, when you call `create` on the scoped class returned by `children`, it executes with `:conditions =&gt; { :parent_id =&gt; ... }` applied to every resulting call to `find` and `create`, which includes not only the initial `create` call but also the `find` you do in `#parent` as part of your `#before_save` callback. If you watch the SQL log you'll see that this query looks like

@@@
SELECT * FROM &quot;things&quot; WHERE (&quot;things&quot;.&quot;id&quot; = 446545869) AND (&quot;things&quot;.&quot;parent_id&quot; = 446545869)
@@@

where the first condition is being supplied by your call to `find(parent_id)` and the second is being supplied by the overall scope (from `children`) that you're executing within; of course this query is going to fail because no `Thing` is its own parent.

(The reason `build` works is because you're calling the `save` yourself afterwards, outside of the scope, whereas `create` is taking care of the `save` while the scope is still in effect.)

But that's not what you meant: you were expecting the call to `self.class.find(parent_id)` to ignore any scope that might currently be in effect and just have the single condition on the primary key. In Rails you have to say that explicitly by using ActiveRecord's `with_exclusive_scope` class method, so the na&#239;ve solution is to refactor `#parent` like this:

@@@
def parent 
  self.class.find_parent(parent_id) if parent_id
end

def self.find_parent(parent_id)
  with_exclusive_scope do
    find(parent_id)
  end
end
@@@

This makes your tests pass, but it's not very handsome. Why should you have to fiddle around with obscure methods like `with_exclusive_scope`? Why should you need to drop out to a class method every time you want to ignore the current scope? Why don't Rails programmers run into subtle problems like this all of the time?

Because associations take care of these details for you, so the underlying problem here is that you're using scopes to simulate associations without dealing with the necessary subtleties. A much better refactoring is to throw away your `#children` and `#parent` methods entirely and replace them with:

@@@
belongs_to :parent, :class_name =&gt; 'Thing'
has_many :children, :class_name =&gt; 'Thing', :foreign_key =&gt; :parent_id
@@@

This will give you effectively the same behaviour that you were going for, but without any of the mucking about with scopes. Calling `us.children` will then return an association proxy (not an actual array of children), so this still lets you do `thing.children.create(:name =&gt; ...)`, except this time it'll work properly because the association proxy provides the right additional arguments to the `create` (i.e. `parent_id`) but doesn't create a scope that would interfere with any unrelated `find`s that you do in your callbacks.

This is much cleaner and more conventional. I'm not sure why you were trying to use scopes in the first place (I'm sure you know about associations!) but it's worth noting that association proxies have the same sort of power. You can call finders on them, for example, and they're scoped in the right way:

@@@
&gt;&gt; us.children.find_by_name('Florida')
=&gt; #&lt;Thing id: 743108299, name: &quot;Florida&quot;, parent_id: 446545869, created_at: &quot;2010-01-14 09:21:48&quot;, updated_at: &quot;2010-01-14 09:21:48&quot;&gt;
&gt;&gt; us.children.find_by_name('San Francisco')
=&gt; nil
@@@

You can also define additional methods on association proxies (see the [Association extensions](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html) section) or even call through to existing class methods, by which I mean that if you define a class method like

@@@
class Thing &lt; ActiveRecord::Base
  # ...

  def self.names
    all.map(&amp;:name).join(', ')
  end
end
@@@

then you can call it on either the class itself or any proxy for an association of objects of that class, and it'll do the right thing:

@@@
&gt;&gt; Thing.names
=&gt; &quot;California, San Diego, Miami, United States, Florida, Daytona, San Francisco, Nevada&quot;
&gt;&gt; us = Thing.find_by_name('United States')
=&gt; #&lt;Thing id: 446545869, name: &quot;United States&quot;, parent_id: nil, created_at: &quot;2010-01-14 09:21:48&quot;, updated_at: &quot;2010-01-14 09:21:48&quot;&gt;
&gt;&gt; us.children.names
=&gt; &quot;California, Florida, Nevada&quot;
@@@

All this means that associations are usually powerful enough for the job, so you can generally avoid scopes unless you're doing something that isn't association-like.

And finally, you could make the `Thing` class even simpler again by using the official [acts_as_tree](http://github.com/rails/acts_as_tree) plugin, which defines the associations for you and throws a couple more handy methods (`#siblings`, `#root` etc) into the bargain.

Cheers,
-Tom</body>
      <body-html>&lt;div&gt;&lt;p&gt;Hi Matt,&lt;/p&gt;
&lt;p&gt;This is (arguably) a subtle problem with your code rather than a
bug in ActiveRecord.&lt;/p&gt;
&lt;p&gt;The issue is that &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt;
methods called within a scope execute with that scope applied, i.e.
for the duration of the method's execution you inherit the scope's
arguments on every &lt;code&gt;find&lt;/code&gt;/&lt;code&gt;create&lt;/code&gt; that you
call, which of course is the whole point of a scope.&lt;/p&gt;
&lt;p&gt;This is causing problems here because, when you call
&lt;code&gt;create&lt;/code&gt; on the scoped class returned by
&lt;code&gt;children&lt;/code&gt;, it executes with &lt;code&gt;:conditions =&amp;gt; {
:parent_id =&amp;gt; ... }&lt;/code&gt; applied to every resulting call to
&lt;code&gt;find&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt;, which includes not only
the initial &lt;code&gt;create&lt;/code&gt; call but also the &lt;code&gt;find&lt;/code&gt;
you do in &lt;code&gt;#parent&lt;/code&gt; as part of your
&lt;code&gt;#before_save&lt;/code&gt; callback. If you watch the SQL log you'll
see that this query looks like&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM &quot;things&quot; WHERE (&quot;things&quot;.&quot;id&quot; = 446545869) AND (&quot;things&quot;.&quot;parent_id&quot; = 446545869)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;where the first condition is being supplied by your call to
&lt;code&gt;find(parent_id)&lt;/code&gt; and the second is being supplied by
the overall scope (from &lt;code&gt;children&lt;/code&gt;) that you're
executing within; of course this query is going to fail because no
&lt;code&gt;Thing&lt;/code&gt; is its own parent.&lt;/p&gt;
&lt;p&gt;(The reason &lt;code&gt;build&lt;/code&gt; works is because you're calling
the &lt;code&gt;save&lt;/code&gt; yourself afterwards, outside of the scope,
whereas &lt;code&gt;create&lt;/code&gt; is taking care of the &lt;code&gt;save&lt;/code&gt;
while the scope is still in effect.)&lt;/p&gt;
&lt;p&gt;But that's not what you meant: you were expecting the call to
&lt;code&gt;self.class.find(parent_id)&lt;/code&gt; to ignore any scope that
might currently be in effect and just have the single condition on
the primary key. In Rails you have to say that explicitly by using
ActiveRecord's &lt;code&gt;with_exclusive_scope&lt;/code&gt; class method, so
the na&amp;iuml;ve solution is to refactor &lt;code&gt;#parent&lt;/code&gt; like
this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parent 
  self.class.find_parent(parent_id) if parent_id
end

def self.find_parent(parent_id)
  with_exclusive_scope do
    find(parent_id)
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;This makes your tests pass, but it's not very handsome. Why
should you have to fiddle around with obscure methods like
&lt;code&gt;with_exclusive_scope&lt;/code&gt;? Why should you need to drop out
to a class method every time you want to ignore the current scope?
Why don't Rails programmers run into subtle problems like this all
of the time?&lt;/p&gt;
&lt;p&gt;Because associations take care of these details for you, so the
underlying problem here is that you're using scopes to simulate
associations without dealing with the necessary subtleties. A much
better refactoring is to throw away your &lt;code&gt;#children&lt;/code&gt; and
&lt;code&gt;#parent&lt;/code&gt; methods entirely and replace them with:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;belongs_to :parent, :class_name =&amp;gt; 'Thing'
has_many :children, :class_name =&amp;gt; 'Thing', :foreign_key =&amp;gt; :parent_id&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;This will give you effectively the same behaviour that you were
going for, but without any of the mucking about with scopes.
Calling &lt;code&gt;us.children&lt;/code&gt; will then return an association
proxy (not an actual array of children), so this still lets you do
&lt;code&gt;thing.children.create(:name =&amp;gt; ...)&lt;/code&gt;, except this
time it'll work properly because the association proxy provides the
right additional arguments to the &lt;code&gt;create&lt;/code&gt; (i.e.
&lt;code&gt;parent_id&lt;/code&gt;) but doesn't create a scope that would
interfere with any unrelated &lt;code&gt;find&lt;/code&gt;s that you do in your
callbacks.&lt;/p&gt;
&lt;p&gt;This is much cleaner and more conventional. I'm not sure why you
were trying to use scopes in the first place (I'm sure you know
about associations!) but it's worth noting that association proxies
have the same sort of power. You can call finders on them, for
example, and they're scoped in the right way:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; us.children.find_by_name('Florida')
=&amp;gt; #&amp;lt;Thing id: 743108299, name: &quot;Florida&quot;, parent_id: 446545869, created_at: &quot;2010-01-14 09:21:48&quot;, updated_at: &quot;2010-01-14 09:21:48&quot;&amp;gt;
&amp;gt;&amp;gt; us.children.find_by_name('San Francisco')
=&amp;gt; nil&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You can also define additional methods on association proxies
(see the &lt;a href=
&quot;http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html&quot;&gt;
Association extensions&lt;/a&gt; section) or even call through to
existing class methods, by which I mean that if you define a class
method like&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Thing &amp;lt; ActiveRecord::Base
  # ...

  def self.names
    all.map(&amp;amp;:name).join(', ')
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;then you can call it on either the class itself or any proxy for
an association of objects of that class, and it'll do the right
thing:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Thing.names
=&amp;gt; &quot;California, San Diego, Miami, United States, Florida, Daytona, San Francisco, Nevada&quot;
&amp;gt;&amp;gt; us = Thing.find_by_name('United States')
=&amp;gt; #&amp;lt;Thing id: 446545869, name: &quot;United States&quot;, parent_id: nil, created_at: &quot;2010-01-14 09:21:48&quot;, updated_at: &quot;2010-01-14 09:21:48&quot;&amp;gt;
&amp;gt;&amp;gt; us.children.names
=&amp;gt; &quot;California, Florida, Nevada&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;All this means that associations are usually powerful enough for
the job, so you can generally avoid scopes unless you're doing
something that isn't association-like.&lt;/p&gt;
&lt;p&gt;And finally, you could make the &lt;code&gt;Thing&lt;/code&gt; class even
simpler again by using the official &lt;a href=
&quot;http://github.com/rails/acts_as_tree&quot;&gt;acts_as_tree&lt;/a&gt; plugin,
which defines the associations for you and throws a couple more
handy methods (&lt;code&gt;#siblings&lt;/code&gt;, &lt;code&gt;#root&lt;/code&gt; etc) into
the bargain.&lt;/p&gt;
&lt;p&gt;Cheers,&lt;br&gt;
-Tom&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-01-14T09:37:19+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-01-14T09:37:20+00:00</updated-at>
      <user-id type="integer">813</user-id>
      <version type="integer">2</version>
      <user-name>Tom Stuart</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Hi Tom

Thanks for that reply, and can certainly understand the view that this is not necessarily a bug, but perhaps a subtlety of the way my code was implemented.  However, I am not sure I agree entirely as I do not understand why the scope in a callback event should be different when calling the save method over the build method?  Whilst there are numerous other ways in which the child/parent relationships can be achieved to avoid this issue (which I have had to do), surely ActiveRecord should be consistent in the way it behaves?  According to the &quot;documentation&quot;:http://api.rubyonrails.org/classes/ActiveRecord/Base.html#M002329 within ActiveRecord, there is no indication that the scope should be different - it simply states the callback events will be executed.

Surely if ActiveRecord save &amp; create methods have different scopes, then this should be *either* documented as a feature or side effect of the implementation, *or* it should behave consistently?  If neither of those conditions are met, then I believe this constitues a bug as other people will be affected by this.

BTW. In regards to your suggestion about using &quot;acts_as_tree&quot;:http://github.com/rails/acts_as_tree to avoid these sorts of issues, I have been using a another plugin called &quot;ancestry&quot;:http://github.com/stefankroes/ancestry as it provides a richer set of functionality to acts_as_tree. Please see this &quot;issue in Github&quot;:http://github.com/stefankroes/ancestry/issues/closed/#issue/9 where I explained the problem to Stefan, and he told me that he felt that this was an ActiveRecord issue.  I then created a simplified version of the problem experienced in ancestry, and posted it here.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Hi Tom&lt;/p&gt;
&lt;p&gt;Thanks for that reply, and can certainly understand the view
that this is not necessarily a bug, but perhaps a subtlety of the
way my code was implemented. However, I am not sure I agree
entirely as I do not understand why the scope in a callback event
should be different when calling the save method over the build
method? Whilst there are numerous other ways in which the
child/parent relationships can be achieved to avoid this issue
(which I have had to do), surely ActiveRecord should be consistent
in the way it behaves? According to the &lt;a href=
&quot;http://api.rubyonrails.org/classes/ActiveRecord/Base.html#M002329&quot;&gt;
documentation&lt;/a&gt; within ActiveRecord, there is no indication that
the scope should be different - it simply states the callback
events will be executed.&lt;/p&gt;
&lt;p&gt;Surely if ActiveRecord save &amp;amp; create methods have different
scopes, then this should be &lt;em&gt;either&lt;/em&gt; documented as a feature
or side effect of the implementation, &lt;em&gt;or&lt;/em&gt; it should behave
consistently? If neither of those conditions are met, then I
believe this constitues a bug as other people will be affected by
this.&lt;/p&gt;
&lt;p&gt;BTW. In regards to your suggestion about using &lt;a href=
&quot;http://github.com/rails/acts_as_tree&quot;&gt;acts_as_tree&lt;/a&gt; to avoid
these sorts of issues, I have been using a another plugin called
&lt;a href=&quot;http://github.com/stefankroes/ancestry&quot;&gt;ancestry&lt;/a&gt; as it
provides a richer set of functionality to acts_as_tree. Please see
this &lt;a href=
&quot;http://github.com/stefankroes/ancestry/issues/closed/#issue/9&quot;&gt;issue
in Github&lt;/a&gt; where I explained the problem to Stefan, and he told
me that he felt that this was an ActiveRecord issue. I then created
a simplified version of the problem experienced in ancestry, and
posted it here.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-01-15T11:33:43+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-01-15T11:33:47+00:00</updated-at>
      <user-id type="integer">82126</user-id>
      <version type="integer">3</version>
      <user-name>Matthew O'Riordan</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>&gt; I do not understand why the scope in a callback event should be
&gt; different when calling the save method over the build method

The callback doesn't fire when you call `build`, it fires when you call `save` later, but because you don't call that `save` while a scope is active it doesn't cause a problem.

In your example you're calling `create` on a named scope -- a special proxy object, specifically an instance of `ActiveRecord::NamedScope::Scope`, which is returned by your `scoped` call in `#children`. Calling a method on a named scope will activate that scope for the duration of the method call, and `create` calls `save` as part of doing its job, so the `save` executes while the scope is still active. And because calling `save` in turn fires the `before_save` callback, that callback executes while the scope's active too.

Callbacks don't get any special treatment: any call to `find` or `create` while the scope is active (i.e. between the time when the `create` method starts executing and the time when it returns) will respect that scope, so the fact you're seeing the problem in a callback is just because it's a method which calls `find` on the scoped class at a time when the scope is active, not specifically because it's a callback.

This is just how scopes work; none of it would have been a problem for you if Ancestry didn't have a bug. The underlying mechanism (of a per-class thread-local stack of currently active scopes) is not perfect but it does the job of making scopes work transparently by exposing them to every `find` and `create` that happens while they're active, regardless of where they're being called and by whom, which more often than not is exactly the right behaviour. There are certain occasions where you explicitly want to disregard any active scope (e.g. when trying to find a record by its primary key as in your `parent` example), which is why `with_exclusive_scope` exists, but those occasions are the exception rather than the rule.

The bug in Ancestry is that it's simulating associations with named scopes but not accounting for the effect of those scopes. When you call `scoped` on a class, you get a proxy object which activates a scope for the duration of any methods called on it; when you call `find` on a class, any scope currently active will be respected. Things are therefore going to go wrong if some of your instance methods return named scopes and some of your other instance methods make calls to `find` or `create` which will go wrong when a scope is active.

So when Ancestry says

@@@
def parent
  if parent_id.blank?
    nil
  else
    self.base_class.find(parent_id)
  end
end
@@@

it actually means

@@@
def parent
  if parent_id.blank?
    nil
  else
    self.base_class.send(:with_exclusive_scope) do
      self.base_class.find(parent_id)
    end
  end
end
@@@

(or, perhaps more tidily, it should elsewhere define a class method like `find_with_exclusive_scope` and call that in `parent`, `parent=` and `root`). If it did this, its simulated associations would work fine.

Cheers,
-Tom</body>
      <body-html>&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;I do not understand why the scope in a callback event should be
different when calling the save method over the build method&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The callback doesn't fire when you call &lt;code&gt;build&lt;/code&gt;, it
fires when you call &lt;code&gt;save&lt;/code&gt; later, but because you don't
call that &lt;code&gt;save&lt;/code&gt; while a scope is active it doesn't
cause a problem.&lt;/p&gt;
&lt;p&gt;In your example you're calling &lt;code&gt;create&lt;/code&gt; on a named
scope -- a special proxy object, specifically an instance of
&lt;code&gt;ActiveRecord::NamedScope::Scope&lt;/code&gt;, which is returned by
your &lt;code&gt;scoped&lt;/code&gt; call in &lt;code&gt;#children&lt;/code&gt;. Calling a
method on a named scope will activate that scope for the duration
of the method call, and &lt;code&gt;create&lt;/code&gt; calls &lt;code&gt;save&lt;/code&gt;
as part of doing its job, so the &lt;code&gt;save&lt;/code&gt; executes while
the scope is still active. And because calling &lt;code&gt;save&lt;/code&gt; in
turn fires the &lt;code&gt;before_save&lt;/code&gt; callback, that callback
executes while the scope's active too.&lt;/p&gt;
&lt;p&gt;Callbacks don't get any special treatment: any call to
&lt;code&gt;find&lt;/code&gt; or &lt;code&gt;create&lt;/code&gt; while the scope is active
(i.e. between the time when the &lt;code&gt;create&lt;/code&gt; method starts
executing and the time when it returns) will respect that scope, so
the fact you're seeing the problem in a callback is just because
it's a method which calls &lt;code&gt;find&lt;/code&gt; on the scoped class at
a time when the scope is active, not specifically because it's a
callback.&lt;/p&gt;
&lt;p&gt;This is just how scopes work; none of it would have been a
problem for you if Ancestry didn't have a bug. The underlying
mechanism (of a per-class thread-local stack of currently active
scopes) is not perfect but it does the job of making scopes work
transparently by exposing them to every &lt;code&gt;find&lt;/code&gt; and
&lt;code&gt;create&lt;/code&gt; that happens while they're active, regardless
of where they're being called and by whom, which more often than
not is exactly the right behaviour. There are certain occasions
where you explicitly want to disregard any active scope (e.g. when
trying to find a record by its primary key as in your
&lt;code&gt;parent&lt;/code&gt; example), which is why
&lt;code&gt;with_exclusive_scope&lt;/code&gt; exists, but those occasions are
the exception rather than the rule.&lt;/p&gt;
&lt;p&gt;The bug in Ancestry is that it's simulating associations with
named scopes but not accounting for the effect of those scopes.
When you call &lt;code&gt;scoped&lt;/code&gt; on a class, you get a proxy
object which activates a scope for the duration of any methods
called on it; when you call &lt;code&gt;find&lt;/code&gt; on a class, any scope
currently active will be respected. Things are therefore going to
go wrong if some of your instance methods return named scopes and
some of your other instance methods make calls to &lt;code&gt;find&lt;/code&gt;
or &lt;code&gt;create&lt;/code&gt; which will go wrong when a scope is
active.&lt;/p&gt;
&lt;p&gt;So when Ancestry says&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parent
  if parent_id.blank?
    nil
  else
    self.base_class.find(parent_id)
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;it actually means&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parent
  if parent_id.blank?
    nil
  else
    self.base_class.send(:with_exclusive_scope) do
      self.base_class.find(parent_id)
    end
  end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(or, perhaps more tidily, it should elsewhere define a class
method like &lt;code&gt;find_with_exclusive_scope&lt;/code&gt; and call that in
&lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;parent=&lt;/code&gt; and &lt;code&gt;root&lt;/code&gt;).
If it did this, its simulated associations would work fine.&lt;/p&gt;
&lt;p&gt;Cheers,&lt;br&gt;
-Tom&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-01-15T20:35:32+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-01-15T20:35:33+00:00</updated-at>
      <user-id type="integer">813</user-id>
      <version type="integer">4</version>
      <user-name>Tom Stuart</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I think you can argue all you want about the intricacies of this bug. The bottom line is that it is definitely unexpected behavior. And following the principle of least surprise it should be eliminated.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I think you can argue all you want about the intricacies of this
bug. The bottom line is that it is definitely unexpected behavior.
And following the principle of least surprise it should be
eliminated.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-01-18T10:48:17+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-01-18T10:48:21+00:00</updated-at>
      <user-id type="integer">44016</user-id>
      <version type="integer">5</version>
      <user-name>Stefan Kroes</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Hi Tom

Thanks for explaining that to me.  The per class thread local stack certainly makes sense, and I do understand now why this is happening.    I do think this could be confusing for others though as a call such as:
   us.children.build(:name =&gt; &quot;New York&quot;).save
would appear to be the same as 
   us.children.create(:name =&gt; &quot;Arizona&quot;)
but is clearly not when you consider how the scope within proxy_options is applied to build &amp; create, but not to save as the proxy object is no longer once the model instance is created. 

Makes sense to me.

Matt</body>
      <body-html>&lt;div&gt;&lt;p&gt;Hi Tom&lt;/p&gt;
&lt;p&gt;Thanks for explaining that to me. The per class thread local
stack certainly makes sense, and I do understand now why this is
happening. I do think this could be confusing for others though as
a call such as:&lt;br&gt;
us.children.build(:name =&amp;gt; &quot;New York&quot;).save would appear to be
the same as&lt;br&gt;
us.children.create(:name =&amp;gt; &quot;Arizona&quot;) but is clearly not when
you consider how the scope within proxy_options is applied to build
&amp;amp; create, but not to save as the proxy object is no longer once
the model instance is created.&lt;/p&gt;
&lt;p&gt;Makes sense to me.&lt;/p&gt;
&lt;p&gt;Matt&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-01-18T12:28:32+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-01-18T12:28:33+00:00</updated-at>
      <user-id type="integer">82126</user-id>
      <version type="integer">6</version>
      <user-name>Matthew O'Riordan</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Please supply a patch which duplicates this issue in Rails or if it's now fixed (please try 2-3-stable and 3.0), a comment saying that this ticket can be closed would be good too.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Please supply a patch which duplicates this issue in Rails or if
it's now fixed (please try 2-3-stable and 3.0), a comment saying
that this ticket can be closed would be good too.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-06-12T03:22:37+01:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag>activerecord scope</tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-06-12T03:22:42+01:00</updated-at>
      <user-id type="integer">14998</user-id>
      <version type="integer">7</version>
      <user-name>Ryan Bigg</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Automatic cleanup of spam.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Automatic cleanup of spam.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-10-09T21:54:16+01:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: activerecord scope
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag nil="true"></tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2010-10-09T21:54:18+01:00</updated-at>
      <user-id type="integer">14998</user-id>
      <version type="integer">9</version>
      <user-name>Ryan Bigg</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>This issue has been automatically marked as stale because it has not been commented on for at least three months.

The resources of the Rails core team are limited, and so we are asking for your help. If you can still reproduce this error on the 3-0-stable branch or on master, please reply with all of the information you have about it and add &quot;[state:open]&quot; to your comment. This will reopen the ticket for review. Likewise, if you feel that this is a very important feature for Rails to include, please reply with your explanation so we can consider it.

Thank you for all your contributions, and we hope you will understand this step to focus our efforts where they are most helpful.</body>
      <body-html>&lt;div&gt;&lt;p&gt;This issue has been automatically marked as stale because it has
not been commented on for at least three months.&lt;/p&gt;
&lt;p&gt;The resources of the Rails core team are limited, and so we are
asking for your help. If you can still reproduce this error on the
3-0-stable branch or on master, please reply with all of the
information you have about it and add &quot;[state:open]&quot; to your
comment. This will reopen the ticket for review. Likewise, if you
feel that this is a very important feature for Rails to include,
please reply with your explanation so we can consider it.&lt;/p&gt;
&lt;p&gt;Thank you for all your contributions, and we hope you will
understand this step to focus our efforts where they are most
helpful.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-02T16:30:53+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag nil="true"></tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2011-02-02T16:46:45+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">10</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body nil="true"></body>
      <body-html nil="true"></body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-02-02T16:30:55+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- 
:state: open
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>stale</state>
      <tag nil="true"></tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2011-02-02T16:46:56+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">11</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Good &lt;a href=http://www.sale-puma.com&gt;Puma shoes sale&lt;/a&gt; information for &lt;a href=http://www.sale-puma.com&gt;Puma shoes&lt;/a&gt; fans: Yesterday, German sportswear maker Cheap Running Shoes purchased effectively lot of money Brands. The transaction entails the Cobra brand, too as linked inventory, intellectual house and endorsement contracts. It also helps make &lt;a href=http://www.sale-puma.com&gt;puma speed cat&lt;/a&gt; Shoes . They provide you with the utmost game and support all through the feet.You can happen around several types of basketball sneakers such as high-top,low-top and mid-top.The &lt;a href=http://www.sale-puma.com&gt;Puma shoes online&lt;/a&gt; and boots give you best ankle support will support want you to obtain steadiness.
As we konw,Trail &lt;a href=http://www.sale-puma.com&gt;Puma Drift Cat&lt;/a&gt; Shoes black, Trail &lt;a href=http://www.sale-puma.com&gt;Puma future cat&lt;/a&gt; ShoesWhite Black? 50 many years backshore are actually released within a great accomplishment. Trail Running Shoes speed cat shoes?go in add-on to King Pele into planet tournament finals, bottom tennis discs matchrs within pasture inhabit an vital area in hold out in Wimbledon Dun; Its working firms have premier manufacturers and major marketplace positions in distilled spirits, residence and security, and golf products. The reply go all through the &lt;a href=http://www.sale-puma.com&gt;Cheap puma shoes&lt;/a&gt; on sale-here you are able to happen around several distcoun.&lt;a href=http://www.sale-puma.com&gt;puma shoes on sale &lt;/a&gt;.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Good &lt;a href=&quot;http:&quot;&gt;Puma shoes sale information for &lt;a href=
&quot;http:&quot;&gt;Puma shoes fans: Yesterday, German sportswear maker Cheap
Running Shoes purchased effectively lot of money Brands. The
transaction entails the Cobra brand, too as linked inventory,
intellectual house and endorsement contracts. It also helps make
&lt;a href=&quot;http:&quot;&gt;puma speed cat Shoes . They provide you with the
utmost game and support all through the feet.You can happen around
several types of basketball sneakers such as high-top,low-top and
mid-top.The &lt;a href=&quot;http:&quot;&gt;Puma shoes online and boots give you
best ankle support will support want you to obtain steadiness.&lt;br&gt;
As we konw,Trail &lt;a href=&quot;http:&quot;&gt;Puma Drift Cat Shoes black, Trail
&lt;a href=&quot;http:&quot;&gt;Puma future cat ShoesWhite Black? 50 many years
backshore are actually released within a great accomplishment.
Trail Running Shoes speed cat shoes?go in add-on to King Pele into
planet tournament finals, bottom tennis discs matchrs within
pasture inhabit an vital area in hold out in Wimbledon Dun; Its
working firms have premier manufacturers and major marketplace
positions in distilled spirits, residence and security, and golf
products. The reply go all through the &lt;a href=&quot;http:&quot;&gt;Cheap puma
shoes on sale-here you are able to happen around several
distcoun.&lt;a href=&quot;http:&quot;&gt;puma shoes on sale .&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-02-16T06:54:55+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>stale</state>
      <tag nil="true"></tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2011-02-16T07:20:08+00:00</updated-at>
      <user-id type="integer">137258</user-id>
      <version type="integer">12</version>
      <user-name>fgfhnmn</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Today, kids as babyish as Ashcan School or nine name-conscious and trend-alert, puma ducati buying at for solid garments rather than just throwing on what&#8217;s pure. Here are just some of the brands and trends your children hungered over 2011. The 80&#8242;s Are Back. You may have noticed a trend this year for evisu jeans, supra shoes, leggings petticoats, oversized tees, and big &lt;a href=http://www.sale-puma.com&gt;puma speed cat&lt;/a&gt; shoes. This is a look that appeals to babies girls-it&#8217;s quirky and yet smart at the same time.
&lt;a href=http://www.sale-puma.com&gt;Puma future cat&lt;/a&gt; with success sets the charm for manner, lifestyle and gambols. This has been believed to serve for an ideal cross flight simulator. This has been fine-looking by most jocks and the Speed Cat is an old name for the industriousness which made &lt;a href=http://www.sale-puma.com&gt;Puma shoes&lt;/a&gt; gain millions with this business. With many people converting more wellness conscious in time, a lot wants also to commit on a good pair of cross trainers. These are very indestructible and forward-looking just like the real carrying out of a real &lt;a href=http://www.sale-puma.com&gt;Puma future cat&lt;/a&gt;. It consumes been systematically on the forefront of design and carrying out when it pertains comfort and style commingled.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Today, kids as babyish as Ashcan School or nine name-conscious
and trend-alert, puma ducati buying at for solid garments rather
than just throwing on what&amp;#8217;s pure. Here are just some of the
brands and trends your children hungered over 2011. The 80&amp;#8242;s
Are Back. You may have noticed a trend this year for evisu jeans,
supra shoes, leggings petticoats, oversized tees, and big &lt;a href=
&quot;http:&quot;&gt;puma speed cat shoes. This is a look that appeals to babies
girls-it&amp;#8217;s quirky and yet smart at the same time.&lt;br&gt;
&lt;a href=&quot;http:&quot;&gt;Puma future cat with success sets the charm for
manner, lifestyle and gambols. This has been believed to serve for
an ideal cross flight simulator. This has been fine-looking by most
jocks and the Speed Cat is an old name for the industriousness
which made &lt;a href=&quot;http:&quot;&gt;Puma shoes gain millions with this
business. With many people converting more wellness conscious in
time, a lot wants also to commit on a good pair of cross trainers.
These are very indestructible and forward-looking just like the
real carrying out of a real &lt;a href=&quot;http:&quot;&gt;Puma future cat. It
consumes been systematically on the forefront of design and
carrying out when it pertains comfort and style commingled.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-02-19T01:57:49+00:00</created-at>
      <creator-id type="integer">82126</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">3680</number>
      <permalink>scope-problem-with-activerecord-in-before_save-or-after_save-when-using-create-method-as-opposed-to-build</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>stale</state>
      <tag nil="true"></tag>
      <title>Scope problem with ActiveRecord in before_save or after_save when using create method as opposed to build</title>
      <updated-at type="datetime">2011-02-19T09:28:21+00:00</updated-at>
      <user-id type="integer">137759</user-id>
      <version type="integer">13</version>
      <user-name>mklo</user-name>
      <creator-name>Matthew O'Riordan</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/3680</url>
      <priority-name>Low</priority-name>
    </version>
  </versions>
  <attachments type="array">
    <attachment type="Attachment">
      <code>18ce53ff30f4c241a7fbe46b421fcda5a8f15c38</code>
      <content-type>application/octet-stream</content-type>
      <created-at type="datetime">2010-01-10T17:07:56+00:00</created-at>
      <filename>activerecord_scope_bug.tgz</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">373120</id>
      <size type="integer">84547</size>
      <uploader-id type="integer">82126</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/373120/activerecord_scope_bug.tgz</url>
    </attachment>
  </attachments>
</ticket>
