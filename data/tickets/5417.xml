<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer" nil="true"></assigned-user-id>
  <attachments-count type="integer">2</attachments-count>
  <closed type="boolean">false</closed>
  <created-at type="datetime">2010-08-19T23:30:45+01:00</created-at>
  <creator-id type="integer">89989</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer" nil="true"></milestone-id>
  <number type="integer">5417</number>
  <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
  <priority type="integer">3</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>open</state>
  <tag nil="true"></tag>
  <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
  <updated-at type="datetime">2011-02-09T03:01:05+00:00</updated-at>
  <user-id type="integer">65953</user-id>
  <version type="integer">12</version>
  <user-name>2kan</user-name>
  <creator-name>Javier Fernandez-Ivern</creator-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
  <priority-name>Low</priority-name>
  <original-body>When editing multiple records in one form via fields_for, if these records belong to a model with a uniqueness constraint and you happen to delete a record and create a new one with the same value in the unique field, the validation will fail because it's ignoring the fact that one of them is marked for destruction.

I've put together the following test for it.  Given the following class definition:

@@@ ruby
class UniqueParrot &lt; Parrot
  validates_uniqueness_of :name
end
@@@

I believe the last assertion in this test should succeed:

@@@ ruby
  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    copycat = UniqueParrot.new(:name =&gt; 'Roger')
    
    @pirate.parrots &lt;&lt; UniqueParrot.new(:name =&gt; 'Roger')
    assert_raise(ActiveRecord::RecordInvalid) { assert !(@pirate.parrots &lt;&lt; copycat) }
    
    @pirate.parrots.first.mark_for_destruction
    assert @pirate.parrots &lt;&lt; copycat
  end
@@@

Instead, the validation triggers:

@@@
  1) Error:
test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction(TestDestroyAsPartOfAutosaveAssociation):
ActiveRecord::RecordInvalid: Validation failed: Name has already been taken
    /Users/javier/Projects/rails/activerecord/lib/active_record/validations.rb:49:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/attribute_methods/dirty.rb:30:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:289:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:287:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/has_and_belongs_to_many_association.rb:39:in `insert_record'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:136:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:479:in `add_record_to_target_with_callbacks'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:135:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `each'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:158:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:157:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:132:in `&lt;&lt;'
    ./test/cases/autosave_association_test.rb:642:in `test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `__send__'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `run'
    /Users/javier/Projects/rails/activesupport/lib/active_support/callbacks.rb:413:in `_run_setup_callbacks'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:65:in `run'
@@@

I've been able to work around this in my application by forcing a delete of all destroyed records (and removing them from the params hash) before calling update_attributes on the model, so I'm ok for now.  However, this probably needs fixing.</original-body>
  <latest-body>When editing multiple records in one form via fields_for, if these records belong to a model with a uniqueness constraint and you happen to delete a record and create a new one with the same value in the unique field, the validation will fail because it's ignoring the fact that one of them is marked for destruction.

I've put together the following test for it.  Given the following class definition:

@@@ ruby
class UniqueParrot &lt; Parrot
  validates_uniqueness_of :name
end
@@@

I believe the last assertion in this test should succeed:

@@@ ruby
  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    copycat = UniqueParrot.new(:name =&gt; 'Roger')
    
    @pirate.parrots &lt;&lt; UniqueParrot.new(:name =&gt; 'Roger')
    assert_raise(ActiveRecord::RecordInvalid) { assert !(@pirate.parrots &lt;&lt; copycat) }
    
    @pirate.parrots.first.mark_for_destruction
    assert @pirate.parrots &lt;&lt; copycat
  end
@@@

Instead, the validation triggers:

@@@
  1) Error:
test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction(TestDestroyAsPartOfAutosaveAssociation):
ActiveRecord::RecordInvalid: Validation failed: Name has already been taken
    /Users/javier/Projects/rails/activerecord/lib/active_record/validations.rb:49:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/attribute_methods/dirty.rb:30:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:289:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:287:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/has_and_belongs_to_many_association.rb:39:in `insert_record'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:136:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:479:in `add_record_to_target_with_callbacks'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:135:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `each'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:158:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:157:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:132:in `&lt;&lt;'
    ./test/cases/autosave_association_test.rb:642:in `test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `__send__'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `run'
    /Users/javier/Projects/rails/activesupport/lib/active_support/callbacks.rb:413:in `_run_setup_callbacks'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:65:in `run'
@@@

I've been able to work around this in my application by forcing a delete of all destroyed records (and removing them from the params hash) before calling update_attributes on the model, so I'm ok for now.  However, this probably needs fixing.</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;When editing multiple records in one form via fields_for, if
these records belong to a model with a uniqueness constraint and
you happen to delete a record and create a new one with the same
value in the unique field, the validation will fail because it's
ignoring the fact that one of them is marked for destruction.&lt;/p&gt;
&lt;p&gt;I've put together the following test for it. Given the following
class definition:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;class UniqueParrot &amp;lt; Parrot
  validates_uniqueness_of :name
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I believe the last assertion in this test should succeed:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;ruby&quot;&gt;  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    copycat = UniqueParrot.new(:name =&amp;gt; 'Roger')
    
    @pirate.parrots &amp;lt;&amp;lt; UniqueParrot.new(:name =&amp;gt; 'Roger')
    assert_raise(ActiveRecord::RecordInvalid) { assert !(@pirate.parrots &amp;lt;&amp;lt; copycat) }
    
    @pirate.parrots.first.mark_for_destruction
    assert @pirate.parrots &amp;lt;&amp;lt; copycat
  end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Instead, the validation triggers:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1) Error:
test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction(TestDestroyAsPartOfAutosaveAssociation):
ActiveRecord::RecordInvalid: Validation failed: Name has already been taken
    /Users/javier/Projects/rails/activerecord/lib/active_record/validations.rb:49:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/attribute_methods/dirty.rb:30:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:289:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:287:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/has_and_belongs_to_many_association.rb:39:in `insert_record'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:136:in `&amp;lt;&amp;lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:479:in `add_record_to_target_with_callbacks'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:135:in `&amp;lt;&amp;lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `each'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `&amp;lt;&amp;lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:158:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:157:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:132:in `&amp;lt;&amp;lt;'
    ./test/cases/autosave_association_test.rb:642:in `test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `__send__'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `run'
    /Users/javier/Projects/rails/activesupport/lib/active_support/callbacks.rb:413:in `_run_setup_callbacks'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:65:in `run'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I've been able to work around this in my application by forcing
a delete of all destroyed records (and removing them from the
params hash) before calling update_attributes on the model, so I'm
ok for now. However, this probably needs fixing.&lt;/p&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>When editing multiple records in one form via fields_for, if these records belong to a model with a uniqueness constraint and you happen to delete a record and create a new one with the same value in the unique field, the validation will fail because it's ignoring the fact that one of them is marked for destruction.

I've put together the following test for it.  Given the following class definition:

@@@ ruby
class UniqueParrot &lt; Parrot
  validates_uniqueness_of :name
end
@@@

I believe the last assertion in this test should succeed:

@@@ ruby
  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    copycat = UniqueParrot.new(:name =&gt; 'Roger')
    
    @pirate.parrots &lt;&lt; UniqueParrot.new(:name =&gt; 'Roger')
    assert_raise(ActiveRecord::RecordInvalid) { assert !(@pirate.parrots &lt;&lt; copycat) }
    
    @pirate.parrots.first.mark_for_destruction
    assert @pirate.parrots &lt;&lt; copycat
  end
@@@

Instead, the validation triggers:

@@@
  1) Error:
test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction(TestDestroyAsPartOfAutosaveAssociation):
ActiveRecord::RecordInvalid: Validation failed: Name has already been taken
    /Users/javier/Projects/rails/activerecord/lib/active_record/validations.rb:49:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/attribute_methods/dirty.rb:30:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:289:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:287:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/has_and_belongs_to_many_association.rb:39:in `insert_record'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:136:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:479:in `add_record_to_target_with_callbacks'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:135:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `each'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `&lt;&lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:158:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:157:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:132:in `&lt;&lt;'
    ./test/cases/autosave_association_test.rb:642:in `test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `__send__'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `run'
    /Users/javier/Projects/rails/activesupport/lib/active_support/callbacks.rb:413:in `_run_setup_callbacks'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:65:in `run'
@@@

I've been able to work around this in my application by forcing a delete of all destroyed records (and removing them from the params hash) before calling update_attributes on the model, so I'm ok for now.  However, this probably needs fixing.</body>
      <body-html>&lt;div&gt;&lt;p&gt;When editing multiple records in one form via fields_for, if
these records belong to a model with a uniqueness constraint and
you happen to delete a record and create a new one with the same
value in the unique field, the validation will fail because it's
ignoring the fact that one of them is marked for destruction.&lt;/p&gt;
&lt;p&gt;I've put together the following test for it. Given the following
class definition:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;class UniqueParrot &amp;lt; Parrot
  validates_uniqueness_of :name
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I believe the last assertion in this test should succeed:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;ruby&quot;&gt;  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    copycat = UniqueParrot.new(:name =&amp;gt; 'Roger')
    
    @pirate.parrots &amp;lt;&amp;lt; UniqueParrot.new(:name =&amp;gt; 'Roger')
    assert_raise(ActiveRecord::RecordInvalid) { assert !(@pirate.parrots &amp;lt;&amp;lt; copycat) }
    
    @pirate.parrots.first.mark_for_destruction
    assert @pirate.parrots &amp;lt;&amp;lt; copycat
  end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Instead, the validation triggers:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1) Error:
test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction(TestDestroyAsPartOfAutosaveAssociation):
ActiveRecord::RecordInvalid: Validation failed: Name has already been taken
    /Users/javier/Projects/rails/activerecord/lib/active_record/validations.rb:49:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/attribute_methods/dirty.rb:30:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:289:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:287:in `with_transaction_returning_status'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:242:in `save!'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/has_and_belongs_to_many_association.rb:39:in `insert_record'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:136:in `&amp;lt;&amp;lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:479:in `add_record_to_target_with_callbacks'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:135:in `&amp;lt;&amp;lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `each'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:133:in `&amp;lt;&amp;lt;'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:158:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb:139:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/transactions.rb:204:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:157:in `transaction'
    /Users/javier/Projects/rails/activerecord/lib/active_record/associations/association_collection.rb:132:in `&amp;lt;&amp;lt;'
    ./test/cases/autosave_association_test.rb:642:in `test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `__send__'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:67:in `run'
    /Users/javier/Projects/rails/activesupport/lib/active_support/callbacks.rb:413:in `_run_setup_callbacks'
    /Users/javier/Projects/rails/activesupport/lib/active_support/testing/setup_and_teardown.rb:65:in `run'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I've been able to work around this in my application by forcing
a delete of all destroyed records (and removing them from the
params hash) before calling update_attributes on the model, so I'm
ok for now. However, this probably needs fixing.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-19T23:30:45+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>&quot;mark_for_destruction validates_uniqueness_of fields_for update_attributes&quot;</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-19T23:55:31+01:00</updated-at>
      <user-id type="integer">89989</user-id>
      <version type="integer">1</version>
      <user-name>Javier Fernandez-Ivern</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Javier can you do a test case following this http://rails.lighthouseapp.com/projects/8994/sending-patches Thanks very much.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Javier can you do a test case following this &lt;a href=
&quot;http://rails.lighthouseapp.com/projects/8994/sending-patches&quot;&gt;http://rails.lighthouseapp.com/projects/8994/sending-patches&lt;/a&gt;
Thanks very much.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-20T00:24:56+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:priority: 0
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>&quot;mark_for_destruction validates_uniqueness_of fields_for update_attributes&quot;</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-20T00:24:59+01:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">2</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Done.  Sorry, I thought that process was only for people sending solutions not just tests.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Done. Sorry, I thought that process was only for people sending
solutions not just tests.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-20T00:56:23+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: &quot;\&quot;mark_for_destruction validates_uniqueness_of fields_for update_attributes\&quot;&quot;
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>fields_for mark_for_destruction patch update_attributes validates_uniqueness_of</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-20T00:56:26+01:00</updated-at>
      <user-id type="integer">89989</user-id>
      <version type="integer">3</version>
      <user-name>Javier Fernandez-Ivern</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-20T00:56:46+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: fields_for mark_for_destruction patch update_attributes validates_uniqueness_of
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>fields_for mark_for_destruction patch test update_attributes validates_uniqueness_of</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-20T00:56:49+01:00</updated-at>
      <user-id type="integer">89989</user-id>
      <version type="integer">4</version>
      <user-name>Javier Fernandez-Ivern</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Javier, it's ok a test case help others to make a patch, so when someone post the solution your test and the solution are applied, giving some credit to you too ;). 
Now ... do you want to try a patch? ;).
Thanks.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Javier, it's ok a test case help others to make a patch, so when
someone post the solution your test and the solution are applied,
giving some credit to you too ;).&lt;br&gt;
Now ... do you want to try a patch? ;).&lt;br&gt;
Thanks.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-20T05:50:57+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>fields_for mark_for_destruction patch test update_attributes validates_uniqueness_of</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-20T05:50:59+01:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">5</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Yes, but would you mind discussing the problem a little bit first?  I no longer like my test case, because there's no guarantee that the record that is marked_for_deletion is actually going to be saved.  So in the general case of the target record being marked for deletion, I'm not sure this is a change that needs to be made.

The case that's more clear-cut is when an association is being saved and it contains items that are marked for deletion *and* items that conflict with them in uniqueness.  In this case, we know both changes are going to happen (barring a transaction blowup or another validation failure).  I'd therefore focus on addressing this problem at the association save level, by ordering the child saves so that elements to be destroyed go first.

Does this seem like the right approach?  If so I'll rewrite the test case and take a shot at a patch.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Yes, but would you mind discussing the problem a little bit
first? I no longer like my test case, because there's no guarantee
that the record that is marked_for_deletion is actually going to be
saved. So in the general case of the target record being marked for
deletion, I'm not sure this is a change that needs to be made.&lt;/p&gt;
&lt;p&gt;The case that's more clear-cut is when an association is being
saved and it contains items that are marked for deletion
&lt;em&gt;and&lt;/em&gt; items that conflict with them in uniqueness. In this
case, we know both changes are going to happen (barring a
transaction blowup or another validation failure). I'd therefore
focus on addressing this problem at the association save level, by
ordering the child saves so that elements to be destroyed go
first.&lt;/p&gt;
&lt;p&gt;Does this seem like the right approach? If so I'll rewrite the
test case and take a shot at a patch.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-20T06:07:31+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>fields_for mark_for_destruction patch test update_attributes validates_uniqueness_of</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-20T06:07:33+01:00</updated-at>
      <user-id type="integer">89989</user-id>
      <version type="integer">6</version>
      <user-name>Javier Fernandez-Ivern</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Well, I'm looking into resolving this, it's somewhat tricky (to me, at least) since I need to make it work when validating the association, not just when saving.  Else it'd be pretty strange.

Until then, I'm attaching a better test:

@@@ ruby
  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    roger = UniqueParrot.create(:name =&gt; &quot;Roger&quot;)
    wilco = UniqueParrot.create(:name =&gt; &quot;Wilco&quot;)
    
    @pirate.parrots &lt;&lt; roger &lt;&lt; wilco
    assert @pirate.valid?
    assert @pirate.save
    
    wilco.name = roger.name
    assert !@pirate.valid?
    assert !@pirate.save
    
    roger.mark_for_destruction
    assert @pirate.valid?
    assert @pirate.save
  end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;Well, I'm looking into resolving this, it's somewhat tricky (to
me, at least) since I need to make it work when validating the
association, not just when saving. Else it'd be pretty strange.&lt;/p&gt;
&lt;p&gt;Until then, I'm attaching a better test:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=
&quot;ruby&quot;&gt;  def test_should_skip_uniqueness_validation_if_existing_record_is_marked_for_destruction
    roger = UniqueParrot.create(:name =&amp;gt; &quot;Roger&quot;)
    wilco = UniqueParrot.create(:name =&amp;gt; &quot;Wilco&quot;)
    
    @pirate.parrots &amp;lt;&amp;lt; roger &amp;lt;&amp;lt; wilco
    assert @pirate.valid?
    assert @pirate.save
    
    wilco.name = roger.name
    assert !@pirate.valid?
    assert !@pirate.save
    
    roger.mark_for_destruction
    assert @pirate.valid?
    assert @pirate.save
  end&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-08-20T15:02:39+01:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>fields_for mark_for_destruction patch test update_attributes validates_uniqueness_of</tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-08-20T15:02:43+01:00</updated-at>
      <user-id type="integer">89989</user-id>
      <version type="integer">7</version>
      <user-name>Javier Fernandez-Ivern</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">2</attachments-count>
      <body>Automatic cleanup of spam.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Automatic cleanup of spam.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-11-08T08:28:51+00:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: fields_for mark_for_destruction patch test update_attributes validates_uniqueness_of
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag nil="true"></tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2010-11-08T08:28:54+00:00</updated-at>
      <user-id type="integer">94458</user-id>
      <version type="integer">9</version>
      <user-name>Jeff Kreeftmeijer</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">2</attachments-count>
      <body>This issue has been automatically marked as stale because it has not been commented on for at least three months.

The resources of the Rails core team are limited, and so we are asking for your help. If you can still reproduce this error on the 3-0-stable branch or on master, please reply with all of the information you have about it and add &quot;[state:open]&quot; to your comment. This will reopen the ticket for review. Likewise, if you feel that this is a very important feature for Rails to include, please reply with your explanation so we can consider it.

Thank you for all your contributions, and we hope you will understand this step to focus our efforts where they are most helpful.</body>
      <body-html>&lt;div&gt;&lt;p&gt;This issue has been automatically marked as stale because it has
not been commented on for at least three months.&lt;/p&gt;
&lt;p&gt;The resources of the Rails core team are limited, and so we are
asking for your help. If you can still reproduce this error on the
3-0-stable branch or on master, please reply with all of the
information you have about it and add &quot;[state:open]&quot; to your
comment. This will reopen the ticket for review. Likewise, if you
feel that this is a very important feature for Rails to include,
please reply with your explanation so we can consider it.&lt;/p&gt;
&lt;p&gt;Thank you for all your contributions, and we hope you will
understand this step to focus our efforts where they are most
helpful.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-09T00:31:56+00:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag nil="true"></tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2011-02-09T00:44:48+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">10</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">2</attachments-count>
      <body nil="true"></body>
      <body-html nil="true"></body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2011-02-09T00:31:57+00:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:state: open
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>stale</state>
      <tag nil="true"></tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2011-02-09T00:38:12+00:00</updated-at>
      <user-id type="integer">40272</user-id>
      <version type="integer">11</version>
      <user-name>Santiago Pastorino</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">2</attachments-count>
      <body>[state:open]

The problem with this ticket and Javier Fernandez-Ivern's test is not in mark_for_destruction itself. In edge validations do not run for associations which are marked for destruction but the problem in the whole illustrated situation:

He marks for deletion the *roger* object. So validation for it doesn't run. But then it validates the *wilco* object which is not marked for destruction and has the same name with the *rojer* object which is marked for destruction but still exists in database, so when we try to validate for *wilco* for uniqueness it fails.</body>
      <body-html>&lt;div&gt;&lt;p&gt;[state:open]&lt;/p&gt;
&lt;p&gt;The problem with this ticket and Javier Fernandez-Ivern's test
is not in mark_for_destruction itself. In edge validations do not
run for associations which are marked for destruction but the
problem in the whole illustrated situation:&lt;/p&gt;
&lt;p&gt;He marks for deletion the &lt;em&gt;roger&lt;/em&gt; object. So validation
for it doesn't run. But then it validates the &lt;em&gt;wilco&lt;/em&gt; object
which is not marked for destruction and has the same name with the
&lt;em&gt;rojer&lt;/em&gt; object which is marked for destruction but still
exists in database, so when we try to validate for &lt;em&gt;wilco&lt;/em&gt;
for uniqueness it fails.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2011-02-09T03:00:54+00:00</created-at>
      <creator-id type="integer">89989</creator-id>
      <diffable-attributes type="yaml">--- 
:state: stale
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">5417</number>
      <permalink>validates_uniqueness_of-should-not-trigger-against-a-record-marked-for-destruction</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>open</state>
      <tag nil="true"></tag>
      <title>validates_uniqueness_of should not trigger against a record marked for destruction</title>
      <updated-at type="datetime">2011-02-09T03:01:05+00:00</updated-at>
      <user-id type="integer">65953</user-id>
      <version type="integer">12</version>
      <user-name>2kan</user-name>
      <creator-name>Javier Fernandez-Ivern</creator-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/5417</url>
      <priority-name>Low</priority-name>
    </version>
  </versions>
  <attachments type="array">
    <attachment type="Attachment">
      <code>bbd5aef01013645c2d5a75dfc25002d81e2b7ca2</code>
      <content-type>text/plain</content-type>
      <created-at type="datetime">2010-08-20T00:56:23+01:00</created-at>
      <filename>test_issue_5417.diff</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">637456</id>
      <size type="integer">1928</size>
      <uploader-id type="integer">89989</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/637456/test_issue_5417.diff</url>
    </attachment>
    <attachment type="Attachment">
      <code>7187ed54a1de6f886f7b5ce23ac009853e7f3499</code>
      <content-type>text/plain</content-type>
      <created-at type="datetime">2010-08-20T15:02:39+01:00</created-at>
      <filename>better_test_5417.diff</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">638249</id>
      <size type="integer">2017</size>
      <uploader-id type="integer">89989</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/638249/better_test_5417.diff</url>
    </attachment>
  </attachments>
</ticket>
