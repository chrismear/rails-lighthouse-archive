From aa21b6b90c0f01040ab838d83ca2942955236802 Mon Sep 17 00:00:00 2001
From: Prem Sichanugrist <s@sikachu.com>
Date: Thu, 21 Jan 2010 14:17:54 +0700
Subject: [PATCH] Update vendored i18n gem to 0.3.3

---
 activesupport/lib/active_support/vendor.rb         |    4 +-
 .../active_support/vendor/i18n-0.1.3/MIT-LICENSE   |   20 -
 .../vendor/i18n-0.1.3/README.textile               |   20 -
 .../lib/active_support/vendor/i18n-0.1.3/Rakefile  |    5 -
 .../active_support/vendor/i18n-0.1.3/i18n.gemspec  |   27 -
 .../active_support/vendor/i18n-0.1.3/lib/i18n.rb   |  199 -------
 .../vendor/i18n-0.1.3/lib/i18n/backend/simple.rb   |  214 --------
 .../vendor/i18n-0.1.3/lib/i18n/exceptions.rb       |   53 --
 .../active_support/vendor/i18n-0.1.3/test/all.rb   |    5 -
 .../vendor/i18n-0.1.3/test/i18n_exceptions_test.rb |   99 ----
 .../vendor/i18n-0.1.3/test/i18n_test.rb            |  124 -----
 .../vendor/i18n-0.1.3/test/locale/en.rb            |    1 -
 .../vendor/i18n-0.1.3/test/locale/en.yml           |    3 -
 .../vendor/i18n-0.1.3/test/simple_backend_test.rb  |  567 --------------------
 .../active_support/vendor/i18n-0.3.3/.gitignore    |    3 +
 .../vendor/i18n-0.3.3/CHANGELOG.textile            |   76 +++
 .../active_support/vendor/i18n-0.3.3/MIT-LICENSE   |   20 +
 .../vendor/i18n-0.3.3/README.textile               |   81 +++
 .../lib/active_support/vendor/i18n-0.3.3/Rakefile  |   24 +
 .../vendor/i18n-0.3.3/benchmark/example.yml        |  144 +++++
 .../vendor/i18n-0.3.3/benchmark/run.rb             |   71 +++
 .../vendor/i18n-0.3.3/contributors.txt             |   17 +
 .../active_support/vendor/i18n-0.3.3/i18n.gemspec  |  165 ++++++
 .../lib/active_support/vendor/i18n-0.3.3/init.rb   |    1 +
 .../active_support/vendor/i18n-0.3.3/lib/i18n.rb   |  277 ++++++++++
 .../vendor/i18n-0.3.3/lib/i18n/backend.rb          |   17 +
 .../i18n-0.3.3/lib/i18n/backend/active_record.rb   |   70 +++
 .../lib/i18n/backend/active_record/missing.rb      |   67 +++
 .../lib/i18n/backend/active_record/store_procs.rb  |   38 ++
 .../lib/i18n/backend/active_record/translation.rb  |   83 +++
 .../vendor/i18n-0.3.3/lib/i18n/backend/base.rb     |  259 +++++++++
 .../vendor/i18n-0.3.3/lib/i18n/backend/cache.rb    |   75 +++
 .../vendor/i18n-0.3.3/lib/i18n/backend/cascade.rb  |   44 ++
 .../vendor/i18n-0.3.3/lib/i18n/backend/chain.rb    |   74 +++
 .../i18n-0.3.3/lib/i18n/backend/fallbacks.rb       |   52 ++
 .../vendor/i18n-0.3.3/lib/i18n/backend/fast.rb     |   68 +++
 .../vendor/i18n-0.3.3/lib/i18n/backend/gettext.rb  |   75 +++
 .../vendor/i18n-0.3.3/lib/i18n/backend/helpers.rb  |   80 +++
 .../lib/i18n/backend/interpolation_compiler.rb     |  119 ++++
 .../vendor/i18n-0.3.3/lib/i18n/backend/metadata.rb |   73 +++
 .../i18n-0.3.3/lib/i18n/backend/pluralization.rb   |   57 ++
 .../vendor/i18n-0.3.3/lib/i18n/backend/simple.rb   |   22 +
 .../lib/i18n/core_ext/object/meta_class.rb         |    5 +
 .../lib/i18n/core_ext/string/interpolate.rb        |   95 ++++
 .../vendor/i18n-0.3.3/lib/i18n/exceptions.rb       |   61 +++
 .../vendor/i18n-0.3.3/lib/i18n/gettext.rb          |   25 +
 .../vendor/i18n-0.3.3/lib/i18n/helpers.rb          |    5 +
 .../vendor/i18n-0.3.3/lib/i18n/helpers/gettext.rb  |   64 +++
 .../vendor/i18n-0.3.3/lib/i18n/locale.rb           |    6 +
 .../vendor/i18n-0.3.3/lib/i18n/locale/fallbacks.rb |   98 ++++
 .../vendor/i18n-0.3.3/lib/i18n/locale/tag.rb       |   28 +
 .../i18n-0.3.3/lib/i18n/locale/tag/parents.rb      |   24 +
 .../i18n-0.3.3/lib/i18n/locale/tag/rfc4646.rb      |   76 +++
 .../i18n-0.3.3/lib/i18n/locale/tag/simple.rb       |   41 ++
 .../vendor/i18n-0.3.3/lib/i18n/version.rb          |    3 +
 .../active_support/vendor/i18n-0.3.3/test/all.rb   |    8 +
 .../vendor/i18n-0.3.3/test/api/basics.rb           |   15 +
 .../vendor/i18n-0.3.3/test/api/defaults.rb         |   40 ++
 .../vendor/i18n-0.3.3/test/api/interpolation.rb    |   92 ++++
 .../vendor/i18n-0.3.3/test/api/link.rb             |   55 ++
 .../i18n-0.3.3/test/api/localization/date.rb       |   91 ++++
 .../i18n-0.3.3/test/api/localization/date_time.rb  |   90 +++
 .../i18n-0.3.3/test/api/localization/procs.rb      |   54 ++
 .../i18n-0.3.3/test/api/localization/time.rb       |   84 +++
 .../vendor/i18n-0.3.3/test/api/lookup.rb           |   45 ++
 .../vendor/i18n-0.3.3/test/api/pluralization.rb    |   35 ++
 .../vendor/i18n-0.3.3/test/api/procs.rb            |   40 ++
 .../test/cases/api/active_record_test.rb           |   29 +
 .../i18n-0.3.3/test/cases/api/all_features_test.rb |   40 ++
 .../i18n-0.3.3/test/cases/api/cascade_test.rb      |   31 ++
 .../vendor/i18n-0.3.3/test/cases/api/chain_test.rb |   26 +
 .../i18n-0.3.3/test/cases/api/fallbacks_test.rb    |   33 ++
 .../vendor/i18n-0.3.3/test/cases/api/fast_test.rb  |   31 ++
 .../test/cases/api/pluralization_test.rb           |   33 ++
 .../i18n-0.3.3/test/cases/api/simple_test.rb       |   21 +
 .../cases/backend/active_record/missing_test.rb    |   60 ++
 .../test/cases/backend/active_record_test.rb       |   52 ++
 .../i18n-0.3.3/test/cases/backend/cache_test.rb    |   72 +++
 .../i18n-0.3.3/test/cases/backend/cascade_test.rb  |   66 +++
 .../i18n-0.3.3/test/cases/backend/chain_test.rb    |   64 +++
 .../test/cases/backend/fallbacks_test.rb           |   57 ++
 .../i18n-0.3.3/test/cases/backend/fast_test.rb     |   50 ++
 .../i18n-0.3.3/test/cases/backend/helpers_test.rb  |   26 +
 .../cases/backend/interpolation_compiler_test.rb   |  107 ++++
 .../i18n-0.3.3/test/cases/backend/metadata_test.rb |   67 +++
 .../test/cases/backend/pluralization_test.rb       |   43 ++
 .../i18n-0.3.3/test/cases/backend/simple_test.rb   |   77 +++
 .../test/cases/core_ext/string/interpolate_test.rb |   94 ++++
 .../i18n-0.3.3/test/cases/gettext/api_test.rb      |  201 +++++++
 .../i18n-0.3.3/test/cases/gettext/backend_test.rb  |   91 ++++
 .../i18n-0.3.3/test/cases/i18n_exceptions_test.rb  |   97 ++++
 .../i18n-0.3.3/test/cases/i18n_load_path_test.rb   |   23 +
 .../vendor/i18n-0.3.3/test/cases/i18n_test.rb      |  172 ++++++
 .../i18n-0.3.3/test/cases/locale/fallbacks_test.rb |  126 +++++
 .../test/cases/locale/tag/rfc4646_test.rb          |  143 +++++
 .../test/cases/locale/tag/simple_test.rb           |   33 ++
 .../vendor/i18n-0.3.3/test/fixtures/locales/de.po  |   72 +++
 .../vendor/i18n-0.3.3/test/fixtures/locales/en.rb  |    3 +
 .../vendor/i18n-0.3.3/test/fixtures/locales/en.yml |    3 +
 .../i18n-0.3.3/test/fixtures/locales/plurals.rb    |  113 ++++
 .../vendor/i18n-0.3.3/test/test_helper.rb          |  100 ++++
 .../vendor/i18n-0.3.3/vendor/po_parser.rb          |  329 ++++++++++++
 102 files changed, 5919 insertions(+), 1339 deletions(-)
 delete mode 100755 activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec
 delete mode 100755 activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml
 delete mode 100644 activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/.gitignore
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/CHANGELOG.textile
 create mode 100755 activesupport/lib/active_support/vendor/i18n-0.3.3/MIT-LICENSE
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/README.textile
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/Rakefile
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/example.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/run.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/contributors.txt
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/i18n.gemspec
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/init.rb
 create mode 100755 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/missing.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/store_procs.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/translation.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/base.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cache.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cascade.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/chain.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fallbacks.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fast.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/gettext.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/helpers.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/interpolation_compiler.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/metadata.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/pluralization.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/simple.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/object/meta_class.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/string/interpolate.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/exceptions.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/gettext.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers/gettext.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/fallbacks.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/parents.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/rfc4646.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/simple.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/version.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/all.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/basics.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/defaults.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/interpolation.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/link.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date_time.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/procs.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/time.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/lookup.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/pluralization.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/procs.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/active_record_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/all_features_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/cascade_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/chain_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fallbacks_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fast_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/pluralization_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/simple_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record/missing_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cache_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cascade_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/chain_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fallbacks_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fast_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/helpers_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/interpolation_compiler_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/metadata_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/pluralization_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/simple_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/core_ext/string/interpolate_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/api_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/backend_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_exceptions_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_load_path_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/fallbacks_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/rfc4646_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/simple_test.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/de.po
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.yml
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/plurals.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/test/test_helper.rb
 create mode 100644 activesupport/lib/active_support/vendor/i18n-0.3.3/vendor/po_parser.rb

diff --git a/activesupport/lib/active_support/vendor.rb b/activesupport/lib/active_support/vendor.rb
index cf2af4a..75316a8 100644
--- a/activesupport/lib/active_support/vendor.rb
+++ b/activesupport/lib/active_support/vendor.rb
@@ -21,8 +21,8 @@ rescue Gem::LoadError
 end
 
 begin
-  gem 'i18n', '>= 0.1.3'
+  gem 'i18n', '>= 0.3.3'
 rescue Gem::LoadError
-  $:.unshift "#{File.dirname(__FILE__)}/vendor/i18n-0.1.3/lib"
+  $:.unshift "#{File.dirname(__FILE__)}/vendor/i18n-0.3.3/lib"
 end
 require 'i18n'
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE b/activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE
deleted file mode 100755
index ed8e9ee..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE
+++ /dev/null
@@ -1,20 +0,0 @@
-Copyright (c) 2008 The Ruby I18n team
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile b/activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile
deleted file mode 100644
index a07fc84..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/README.textile
+++ /dev/null
@@ -1,20 +0,0 @@
-h1. Ruby I18n gem
-
-I18n and localization solution for Ruby.
-
-For information please refer to http://rails-i18n.org
-
-h2. Authors
-
-* "Matt Aimonetti":http://railsontherun.com
-* "Sven Fuchs":http://www.artweb-design.de
-* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
-* "Saimon Moore":http://saimonmoore.net
-* "Stephan Soller":http://www.arkanis-development.de
-
-h2. License
-
-MIT License. See the included MIT-LICENCE file.
-
-
-
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile b/activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile
deleted file mode 100644
index 2164e13..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/Rakefile
+++ /dev/null
@@ -1,5 +0,0 @@
-task :default => [:test]
-
-task :test do
-  ruby "test/all.rb"
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec b/activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec
deleted file mode 100644
index f102689..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/i18n.gemspec
+++ /dev/null
@@ -1,27 +0,0 @@
-Gem::Specification.new do |s|
-  s.name = "i18n"
-  s.version = "0.1.3"
-  s.date = "2009-01-09"
-  s.summary = "Internationalization support for Ruby"
-  s.email = "rails-i18n@googlegroups.com"
-  s.homepage = "http://rails-i18n.org"
-  s.description = "Add Internationalization support to your Ruby application."
-  s.has_rdoc = false
-  s.authors = ['Sven Fuchs', 'Joshua Harvey', 'Matt Aimonetti', 'Stephan Soller', 'Saimon Moore']
-  s.files = [
-    'i18n.gemspec',
-    'lib/i18n/backend/simple.rb',
-    'lib/i18n/exceptions.rb',
-    'lib/i18n.rb',
-    'MIT-LICENSE',
-    'README.textile'
-  ]
-  s.test_files = [
-    'test/all.rb',
-    'test/i18n_exceptions_test.rb',
-    'test/i18n_test.rb',
-    'test/locale/en.rb',
-    'test/locale/en.yml',
-    'test/simple_backend_test.rb'
-  ]
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb
deleted file mode 100755
index 76361be..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb
+++ /dev/null
@@ -1,199 +0,0 @@
-# Authors::   Matt Aimonetti (http://railsontherun.com/),
-#             Sven Fuchs (http://www.artweb-design.de),
-#             Joshua Harvey (http://www.workingwithrails.com/person/759-joshua-harvey),
-#             Saimon Moore (http://saimonmoore.net),
-#             Stephan Soller (http://www.arkanis-development.de/)
-# Copyright:: Copyright (c) 2008 The Ruby i18n Team
-# License::   MIT
-require 'i18n/backend/simple'
-require 'i18n/exceptions'
-
-module I18n
-  @@backend = nil
-  @@load_path = nil
-  @@default_locale = :'en'
-  @@exception_handler = :default_exception_handler
-
-  class << self
-    # Returns the current backend. Defaults to +Backend::Simple+.
-    def backend
-      @@backend ||= Backend::Simple.new
-    end
-
-    # Sets the current backend. Used to set a custom backend.
-    def backend=(backend)
-      @@backend = backend
-    end
-
-    # Returns the current default locale. Defaults to :'en'
-    def default_locale
-      @@default_locale
-    end
-
-    # Sets the current default locale. Used to set a custom default locale.
-    def default_locale=(locale)
-      @@default_locale = locale
-    end
-
-    # Returns the current locale. Defaults to I18n.default_locale.
-    def locale
-      Thread.current[:locale] ||= default_locale
-    end
-
-    # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
-    def locale=(locale)
-      Thread.current[:locale] = locale
-    end
-
-    # Returns an array of locales for which translations are available
-    def available_locales
-      backend.available_locales
-    end
-
-    # Sets the exception handler.
-    def exception_handler=(exception_handler)
-      @@exception_handler = exception_handler
-    end
-
-    # Allow clients to register paths providing translation data sources. The
-    # backend defines acceptable sources.
-    #
-    # E.g. the provided SimpleBackend accepts a list of paths to translation
-    # files which are either named *.rb and contain plain Ruby Hashes or are
-    # named *.yml and contain YAML data. So for the SimpleBackend clients may
-    # register translation files like this:
-    #   I18n.load_path << 'path/to/locale/en.yml'
-    def load_path
-      @@load_path ||= []
-    end
-
-    # Sets the load path instance. Custom implementations are expected to
-    # behave like a Ruby Array.
-    def load_path=(load_path)
-      @@load_path = load_path
-    end
-
-    # Tells the backend to reload translations. Used in situations like the
-    # Rails development environment. Backends can implement whatever strategy
-    # is useful.
-    def reload!
-      backend.reload!
-    end
-
-    # Translates, pluralizes and interpolates a given key using a given locale,
-    # scope, and default, as well as interpolation values.
-    #
-    # *LOOKUP*
-    #
-    # Translation data is organized as a nested hash using the upper-level keys
-    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
-    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
-    #
-    # Translations can be looked up at any level of this hash using the key argument
-    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
-    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
-    #
-    # Key can be either a single key or a dot-separated key (both Strings and Symbols
-    # work). <em>E.g.</em>, the short format can be looked up using both:
-    #   I18n.t 'date.formats.short'
-    #   I18n.t :'date.formats.short'
-    #
-    # Scope can be either a single key, a dot-separated key or an array of keys
-    # or dot-separated keys. Keys and scopes can be combined freely. So these
-    # examples will all look up the same short date format:
-    #   I18n.t 'date.formats.short'
-    #   I18n.t 'formats.short', :scope => 'date'
-    #   I18n.t 'short', :scope => 'date.formats'
-    #   I18n.t 'short', :scope => %w(date formats)
-    #
-    # *INTERPOLATION*
-    #
-    # Translations can contain interpolation variables which will be replaced by
-    # values passed to #translate as part of the options hash, with the keys matching
-    # the interpolation variable names.
-    #
-    # <em>E.g.</em>, with a translation <tt>:foo => "foo {{bar}}"</tt> the option
-    # value for the key +bar+ will be interpolated into the translation:
-    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
-    #
-    # *PLURALIZATION*
-    #
-    # Translation data can contain pluralized translations. Pluralized translations
-    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
-    #
-    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
-    # pluralization rules. Other algorithms can be supported by custom backends.
-    #
-    # This returns the singular version of a pluralized translation:
-    #   I18n.t :foo, :count => 1 # => 'Foo'
-    #
-    # These both return the plural version of a pluralized translation:
-    #   I18n.t :foo, :count => 0 # => 'Foos'
-    #   I18n.t :foo, :count => 2 # => 'Foos'
-    #
-    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
-    # <em>E.g.</em>, with the translation
-    # <tt>:foo => ['{{count}} foo', '{{count}} foos']</tt>, count will
-    # be interpolated to the pluralized translation:
-    #   I18n.t :foo, :count => 1 # => '1 foo'
-    #
-    # *DEFAULTS*
-    #
-    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
-    #   I18n.t :foo, :default => 'default'
-    #
-    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
-    # translation for <tt>:foo</tt> was found:
-    #   I18n.t :foo, :default => :bar
-    #
-    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
-    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
-    #   I18n.t :foo, :default => [:bar, 'default']
-    #
-    # <b>BULK LOOKUP</b>
-    #
-    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
-    #   I18n.t [:foo, :bar]
-    #
-    # Can be used with dot-separated nested keys:
-    #   I18n.t [:'baz.foo', :'baz.bar']
-    #
-    # Which is the same as using a scope option:
-    #   I18n.t [:foo, :bar], :scope => :baz
-    def translate(key, options = {})
-      locale = options.delete(:locale) || I18n.locale
-      backend.translate(locale, key, options)
-    rescue I18n::ArgumentError => e
-      raise e if options[:raise]
-      send(@@exception_handler, e, locale, key, options)
-    end
-    alias :t :translate
-
-    # Localizes certain objects, such as dates and numbers to local formatting.
-    def localize(object, options = {})
-      locale = options[:locale] || I18n.locale
-      format = options[:format] || :default
-      backend.localize(locale, object, format)
-    end
-    alias :l :localize
-
-  protected
-    # Handles exceptions raised in the backend. All exceptions except for
-    # MissingTranslationData exceptions are re-raised. When a MissingTranslationData
-    # was caught and the option :raise is not set the handler returns an error
-    # message string containing the key/scope.
-    def default_exception_handler(exception, locale, key, options)
-      return exception.message if MissingTranslationData === exception
-      raise exception
-    end
-
-    # Merges the given locale, key and scope into a single array of keys.
-    # Splits keys that contain dots into multiple keys. Makes sure all
-    # keys are Symbols.
-    def normalize_translation_keys(locale, key, scope)
-      keys = [locale] + Array(scope) + [key]
-      keys = keys.map { |k| k.to_s.split(/\./) }
-      keys.flatten.map { |k| k.to_sym }
-    end
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb
deleted file mode 100644
index c09acd7..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb
+++ /dev/null
@@ -1,214 +0,0 @@
-require 'yaml'
-
-module I18n
-  module Backend
-    class Simple
-      INTERPOLATION_RESERVED_KEYS = %w(scope default)
-      MATCH = /(\\\\)?\{\{([^\}]+)\}\}/
-
-      # Accepts a list of paths to translation files. Loads translations from
-      # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
-      # for details.
-      def load_translations(*filenames)
-        filenames.each { |filename| load_file(filename) }
-      end
-
-      # Stores translations for the given locale in memory.
-      # This uses a deep merge for the translations hash, so existing
-      # translations will be overwritten by new ones only at the deepest
-      # level of the hash.
-      def store_translations(locale, data)
-        merge_translations(locale, data)
-      end
-
-      def translate(locale, key, options = {})
-        raise InvalidLocale.new(locale) if locale.nil?
-        return key.map { |k| translate(locale, k, options) } if key.is_a? Array
-
-        reserved = :scope, :default
-        count, scope, default = options.values_at(:count, *reserved)
-        options.delete(:default)
-        values = options.reject { |name, value| reserved.include?(name) }
-
-        entry = lookup(locale, key, scope)
-        if entry.nil?
-          entry = default(locale, default, options)
-          if entry.nil?
-            raise(I18n::MissingTranslationData.new(locale, key, options))
-          end
-        end
-        entry = pluralize(locale, entry, count)
-        entry = interpolate(locale, entry, values)
-        entry
-      end
-
-      # Acts the same as +strftime+, but returns a localized version of the
-      # formatted date string. Takes a key from the date/time formats
-      # translations as a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
-      def localize(locale, object, format = :default)
-        raise ArgumentError, "Object must be a Date, DateTime or Time object. #{object.inspect} given." unless object.respond_to?(:strftime)
-
-        type = object.respond_to?(:sec) ? 'time' : 'date'
-        # TODO only translate these if format is a String?
-        formats = translate(locale, :"#{type}.formats")
-        format = formats[format.to_sym] if formats && formats[format.to_sym]
-        # TODO raise exception unless format found?
-        format = format.to_s.dup
-
-        # TODO only translate these if the format string is actually present
-        # TODO check which format strings are present, then bulk translate then, then replace them
-        format.gsub!(/%a/, translate(locale, :"date.abbr_day_names")[object.wday])
-        format.gsub!(/%A/, translate(locale, :"date.day_names")[object.wday])
-        format.gsub!(/%b/, translate(locale, :"date.abbr_month_names")[object.mon])
-        format.gsub!(/%B/, translate(locale, :"date.month_names")[object.mon])
-        format.gsub!(/%p/, translate(locale, :"time.#{object.hour < 12 ? :am : :pm}")) if object.respond_to? :hour
-        object.strftime(format)
-      end
-
-      def initialized?
-        @initialized ||= false
-      end
-
-      # Returns an array of locales for which translations are available
-      def available_locales
-        init_translations unless initialized?
-        translations.keys
-      end
-
-      def reload!
-        @initialized = false
-        @translations = nil
-      end
-
-      protected
-        def init_translations
-          load_translations(*I18n.load_path.flatten)
-          @initialized = true
-        end
-
-        def translations
-          @translations ||= {}
-        end
-
-        # Looks up a translation from the translations hash. Returns nil if
-        # eiher key is nil, or locale, scope or key do not exist as a key in the
-        # nested translations hash. Splits keys or scopes containing dots
-        # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
-        # <tt>%w(currency format)</tt>.
-        def lookup(locale, key, scope = [])
-          return unless key
-          init_translations unless initialized?
-          keys = I18n.send(:normalize_translation_keys, locale, key, scope)
-          keys.inject(translations) do |result, k|
-            if (x = result[k.to_sym]).nil?
-              return nil
-            else
-              x
-            end
-          end
-        end
-
-        # Evaluates a default translation.
-        # If the given default is a String it is used literally. If it is a Symbol
-        # it will be translated with the given options. If it is an Array the first
-        # translation yielded will be returned.
-        #
-        # <em>I.e.</em>, <tt>default(locale, [:foo, 'default'])</tt> will return +default+ if
-        # <tt>translate(locale, :foo)</tt> does not yield a result.
-        def default(locale, default, options = {})
-          case default
-            when String then default
-            when Symbol then translate locale, default, options
-            when Array  then default.each do |obj|
-              result = default(locale, obj, options.dup) and return result
-            end and nil
-          end
-        rescue MissingTranslationData
-          nil
-        end
-
-        # Picks a translation from an array according to English pluralization
-        # rules. It will pick the first translation if count is not equal to 1
-        # and the second translation if it is equal to 1. Other backends can
-        # implement more flexible or complex pluralization rules.
-        def pluralize(locale, entry, count)
-          return entry unless entry.is_a?(Hash) and count
-          # raise InvalidPluralizationData.new(entry, count) unless entry.is_a?(Hash)
-          key = :zero if count == 0 && entry.has_key?(:zero)
-          key ||= count == 1 ? :one : :other
-          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
-          entry[key]
-        end
-
-        # Interpolates values into a given string.
-        #
-        #   interpolate "file {{file}} opened by \\{{user}}", :file => 'test.txt', :user => 'Mr. X'
-        #   # => "file test.txt opened by {{user}}"
-        #
-        # Note that you have to double escape the <tt>\\</tt> when you want to escape
-        # the <tt>{{...}}</tt> key in a string (once for the string and once for the
-        # interpolation).
-        def interpolate(locale, string, values = {})
-          return string unless string.is_a?(String)
-
-          string.gsub(MATCH) do
-            escaped, pattern, key = $1, $2, $2.to_sym
-
-            if escaped
-              pattern
-            elsif INTERPOLATION_RESERVED_KEYS.include?(pattern)
-              raise ReservedInterpolationKey.new(pattern, string)
-            elsif !values.include?(key)
-              raise MissingInterpolationArgument.new(pattern, string)
-            else
-              values[key].to_s
-            end
-          end
-        end
-
-        # Loads a single translations file by delegating to #load_rb or
-        # #load_yml depending on the file extension and directly merges the
-        # data to the existing translations. Raises I18n::UnknownFileType
-        # for all other file extensions.
-        def load_file(filename)
-          type = File.extname(filename).tr('.', '').downcase
-          raise UnknownFileType.new(type, filename) unless respond_to?(:"load_#{type}")
-          data = send :"load_#{type}", filename # TODO raise a meaningful exception if this does not yield a Hash
-          data.each { |locale, d| merge_translations(locale, d) }
-        end
-
-        # Loads a plain Ruby translations file. eval'ing the file must yield
-        # a Hash containing translation data with locales as toplevel keys.
-        def load_rb(filename)
-          eval(IO.read(filename), binding, filename)
-        end
-
-        # Loads a YAML translations file. The data must have locales as
-        # toplevel keys.
-        def load_yml(filename)
-          YAML::load(IO.read(filename))
-        end
-
-        # Deep merges the given translations hash with the existing translations
-        # for the given locale
-        def merge_translations(locale, data)
-          locale = locale.to_sym
-          translations[locale] ||= {}
-          data = deep_symbolize_keys(data)
-
-          # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
-          merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
-          translations[locale].merge!(data, &merger)
-        end
-
-        # Return a new hash with all keys and nested keys converted to symbols.
-        def deep_symbolize_keys(hash)
-          hash.inject({}) { |result, (key, value)|
-            value = deep_symbolize_keys(value) if value.is_a? Hash
-            result[(key.to_sym rescue key) || key] = value
-            result
-          }
-        end
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb
deleted file mode 100644
index b5cea7a..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb
+++ /dev/null
@@ -1,53 +0,0 @@
-module I18n
-  class ArgumentError < ::ArgumentError; end
-
-  class InvalidLocale < ArgumentError
-    attr_reader :locale
-    def initialize(locale)
-      @locale = locale
-      super "#{locale.inspect} is not a valid locale"
-    end
-  end
-
-  class MissingTranslationData < ArgumentError
-    attr_reader :locale, :key, :options
-    def initialize(locale, key, options)
-      @key, @locale, @options = key, locale, options
-      keys = I18n.send(:normalize_translation_keys, locale, key, options[:scope])
-      keys << 'no key' if keys.size < 2
-      super "translation missing: #{keys.join(', ')}"
-    end
-  end
-
-  class InvalidPluralizationData < ArgumentError
-    attr_reader :entry, :count
-    def initialize(entry, count)
-      @entry, @count = entry, count
-      super "translation data #{entry.inspect} can not be used with :count => #{count}"
-    end
-  end
-
-  class MissingInterpolationArgument < ArgumentError
-    attr_reader :key, :string
-    def initialize(key, string)
-      @key, @string = key, string
-      super "interpolation argument #{key} missing in #{string.inspect}"
-    end
-  end
-
-  class ReservedInterpolationKey < ArgumentError
-    attr_reader :key, :string
-    def initialize(key, string)
-      @key, @string = key, string
-      super "reserved key #{key.inspect} used in #{string.inspect}"
-    end
-  end
-
-  class UnknownFileType < ArgumentError
-    attr_reader :type, :filename
-    def initialize(type, filename)
-      @type, @filename = type, filename
-      super "can not load translations from #{filename}, the file type #{type} is not known"
-    end
-  end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb
deleted file mode 100644
index 353712d..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/all.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-dir = File.dirname(__FILE__)
-require dir + '/i18n_test.rb'
-require dir + '/simple_backend_test.rb'
-require dir + '/i18n_exceptions_test.rb'
-# *require* dir + '/custom_backend_test.rb'
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb
deleted file mode 100644
index 4e78e71..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb
+++ /dev/null
@@ -1,99 +0,0 @@
-$:.unshift "lib"
-
-require 'rubygems'
-require 'test/unit'
-require 'i18n'
-require 'active_support'
-
-class I18nExceptionsTest < Test::Unit::TestCase
-  def test_invalid_locale_stores_locale
-    force_invalid_locale
-  rescue I18n::ArgumentError => e
-    assert_nil e.locale
-  end
-
-  def test_invalid_locale_message
-    force_invalid_locale
-  rescue I18n::ArgumentError => e
-    assert_equal 'nil is not a valid locale', e.message
-  end
-
-  def test_missing_translation_data_stores_locale_key_and_options
-    force_missing_translation_data
-  rescue I18n::ArgumentError => e
-    options = {:scope => :bar}
-    assert_equal 'de', e.locale
-    assert_equal :foo, e.key
-    assert_equal options, e.options
-  end
-
-  def test_missing_translation_data_message
-    force_missing_translation_data
-  rescue I18n::ArgumentError => e
-    assert_equal 'translation missing: de, bar, foo', e.message
-  end
-
-  def test_invalid_pluralization_data_stores_entry_and_count
-    force_invalid_pluralization_data
-  rescue I18n::ArgumentError => e
-    assert_equal [:bar], e.entry
-    assert_equal 1, e.count
-  end
-
-  def test_invalid_pluralization_data_message
-    force_invalid_pluralization_data
-  rescue I18n::ArgumentError => e
-    assert_equal 'translation data [:bar] can not be used with :count => 1', e.message
-  end
-
-  def test_missing_interpolation_argument_stores_key_and_string
-    force_missing_interpolation_argument
-  rescue I18n::ArgumentError => e
-    assert_equal 'bar', e.key
-    assert_equal "{{bar}}", e.string
-  end
-
-  def test_missing_interpolation_argument_message
-    force_missing_interpolation_argument
-  rescue I18n::ArgumentError => e
-    assert_equal 'interpolation argument bar missing in "{{bar}}"', e.message
-  end
-
-  def test_reserved_interpolation_key_stores_key_and_string
-    force_reserved_interpolation_key
-  rescue I18n::ArgumentError => e
-    assert_equal 'scope', e.key
-    assert_equal "{{scope}}", e.string
-  end
-
-  def test_reserved_interpolation_key_message
-    force_reserved_interpolation_key
-  rescue I18n::ArgumentError => e
-    assert_equal 'reserved key "scope" used in "{{scope}}"', e.message
-  end
-
-  private
-    def force_invalid_locale
-      I18n.backend.translate nil, :foo
-    end
-
-    def force_missing_translation_data
-      I18n.backend.store_translations 'de', :bar => nil
-      I18n.backend.translate 'de', :foo, :scope => :bar
-    end
-
-    def force_invalid_pluralization_data
-      I18n.backend.store_translations 'de', :foo => [:bar]
-      I18n.backend.translate 'de', :foo, :count => 1
-    end
-
-    def force_missing_interpolation_argument
-      I18n.backend.store_translations 'de', :foo => "{{bar}}"
-      I18n.backend.translate 'de', :foo, :baz => 'baz'
-    end
-
-    def force_reserved_interpolation_key
-      I18n.backend.store_translations 'de', :foo => "{{scope}}"
-      I18n.backend.translate 'de', :foo, :baz => 'baz'
-    end
-end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb
deleted file mode 100644
index 2835ec4..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb
+++ /dev/null
@@ -1,124 +0,0 @@
-$:.unshift "lib"
-
-require 'rubygems'
-require 'test/unit'
-require 'i18n'
-require 'active_support'
-
-class I18nTest < Test::Unit::TestCase
-  def setup
-    I18n.backend.store_translations :'en', {
-      :currency => {
-        :format => {
-          :separator => '.',
-          :delimiter => ',',
-        }
-      }
-    }
-  end
-
-  def test_uses_simple_backend_set_by_default
-    assert I18n.backend.is_a?(I18n::Backend::Simple)
-  end
-
-  def test_can_set_backend
-    assert_nothing_raised{ I18n.backend = self }
-    assert_equal self, I18n.backend
-    I18n.backend = I18n::Backend::Simple.new
-  end
-
-  def test_uses_en_us_as_default_locale_by_default
-    assert_equal 'en', I18n.default_locale
-  end
-
-  def test_can_set_default_locale
-    assert_nothing_raised{ I18n.default_locale = 'de' }
-    assert_equal 'de', I18n.default_locale
-    I18n.default_locale = 'en'
-  end
-
-  def test_uses_default_locale_as_locale_by_default
-    assert_equal I18n.default_locale, I18n.locale
-  end
-
-  def test_can_set_locale_to_thread_current
-    assert_nothing_raised{ I18n.locale = 'de' }
-    assert_equal 'de', I18n.locale
-    assert_equal 'de', Thread.current[:locale]
-    I18n.locale = 'en'
-  end
-
-  def test_can_set_exception_handler
-    assert_nothing_raised{ I18n.exception_handler = :custom_exception_handler }
-    I18n.exception_handler = :default_exception_handler # revert it
-  end
-
-  def test_uses_custom_exception_handler
-    I18n.exception_handler = :custom_exception_handler
-    I18n.expects(:custom_exception_handler)
-    I18n.translate :bogus
-    I18n.exception_handler = :default_exception_handler # revert it
-  end
-
-  def test_delegates_translate_to_backend
-    I18n.backend.expects(:translate).with 'de', :foo, {}
-    I18n.translate :foo, :locale => 'de'
-  end
-
-  def test_delegates_localize_to_backend
-    I18n.backend.expects(:localize).with 'de', :whatever, :default
-    I18n.localize :whatever, :locale => 'de'
-  end
-
-  def test_translate_given_no_locale_uses_i18n_locale
-    I18n.backend.expects(:translate).with 'en', :foo, {}
-    I18n.translate :foo
-  end
-
-  def test_translate_on_nested_symbol_keys_works
-    assert_equal ".", I18n.t(:'currency.format.separator')
-  end
-
-  def test_translate_with_nested_string_keys_works
-    assert_equal ".", I18n.t('currency.format.separator')
-  end
-
-  def test_translate_with_array_as_scope_works
-    assert_equal ".", I18n.t(:separator, :scope => ['currency.format'])
-  end
-
-  def test_translate_with_array_containing_dot_separated_strings_as_scope_works
-    assert_equal ".", I18n.t(:separator, :scope => ['currency.format'])
-  end
-
-  def test_translate_with_key_array_and_dot_separated_scope_works
-    assert_equal [".", ","], I18n.t(%w(separator delimiter), :scope => 'currency.format')
-  end
-
-  def test_translate_with_dot_separated_key_array_and_scope_works
-    assert_equal [".", ","], I18n.t(%w(format.separator format.delimiter), :scope => 'currency')
-  end
-
-  def test_translate_with_options_using_scope_works
-    I18n.backend.expects(:translate).with('de', :precision, :scope => :"currency.format")
-    I18n.with_options :locale => 'de', :scope => :'currency.format' do |locale|
-      locale.t :precision
-    end
-  end
-
-  # def test_translate_given_no_args_raises_missing_translation_data
-  #   assert_equal "translation missing: en, no key", I18n.t
-  # end
-
-  def test_translate_given_a_bogus_key_raises_missing_translation_data
-    assert_equal "translation missing: en, bogus", I18n.t(:bogus)
-  end
-
-  def test_localize_nil_raises_argument_error
-    assert_raise(I18n::ArgumentError) { I18n.l nil }
-  end
-
-  def test_localize_object_raises_argument_error
-    assert_raise(I18n::ArgumentError) { I18n.l Object.new }
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb
deleted file mode 100644
index 6044ce1..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb
+++ /dev/null
@@ -1 +0,0 @@
-{:'en-Ruby' => {:foo => {:bar => "baz"}}}
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml
deleted file mode 100644
index 0b298c9..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml
+++ /dev/null
@@ -1,3 +0,0 @@
-en-Yaml:
-  foo:
-    bar: baz
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb b/activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb
deleted file mode 100644
index a1696c7..0000000
--- a/activesupport/lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb
+++ /dev/null
@@ -1,567 +0,0 @@
-# encoding: utf-8
-$:.unshift "lib"
-
-require 'rubygems'
-require 'test/unit'
-require 'i18n'
-require 'time'
-require 'yaml'
-
-module I18nSimpleBackendTestSetup
-  def setup_backend
-    # backend_reset_translations!
-    @backend = I18n::Backend::Simple.new
-    @backend.store_translations 'en', :foo => {:bar => 'bar', :baz => 'baz'}
-    @locale_dir = File.dirname(__FILE__) + '/locale'
-  end
-  alias :setup :setup_backend
-
-  # def backend_reset_translations!
-  #   I18n::Backend::Simple::ClassMethods.send :class_variable_set, :@@translations, {}
-  # end
-
-  def backend_get_translations
-    # I18n::Backend::Simple::ClassMethods.send :class_variable_get, :@@translations
-    @backend.instance_variable_get :@translations
-  end
-
-  def add_datetime_translations
-    @backend.store_translations :'de', {
-      :date => {
-        :formats => {
-          :default => "%d.%m.%Y",
-          :short => "%d. %b",
-          :long => "%d. %B %Y",
-        },
-        :day_names => %w(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag),
-        :abbr_day_names => %w(So Mo Di Mi Do Fr  Sa),
-        :month_names => %w(Januar Februar Mrz April Mai Juni Juli August September Oktober November Dezember).unshift(nil),
-        :abbr_month_names => %w(Jan Feb Mar Apr Mai Jun Jul Aug Sep Okt Nov Dez).unshift(nil),
-        :order => [:day, :month, :year]
-      },
-      :time => {
-        :formats => {
-          :default => "%a, %d. %b %Y %H:%M:%S %z",
-          :short => "%d. %b %H:%M",
-          :long => "%d. %B %Y %H:%M",
-        },
-        :am => 'am',
-        :pm => 'pm'
-      },
-      :datetime => {
-        :distance_in_words => {
-          :half_a_minute => 'half a minute',
-          :less_than_x_seconds => {
-            :one => 'less than 1 second',
-            :other => 'less than {{count}} seconds'
-          },
-          :x_seconds => {
-            :one => '1 second',
-            :other => '{{count}} seconds'
-          },
-          :less_than_x_minutes => {
-            :one => 'less than a minute',
-            :other => 'less than {{count}} minutes'
-          },
-          :x_minutes => {
-            :one => '1 minute',
-            :other => '{{count}} minutes'
-          },
-          :about_x_hours => {
-            :one => 'about 1 hour',
-            :other => 'about {{count}} hours'
-          },
-          :x_days => {
-            :one => '1 day',
-            :other => '{{count}} days'
-          },
-          :about_x_months => {
-            :one => 'about 1 month',
-            :other => 'about {{count}} months'
-          },
-          :x_months => {
-            :one => '1 month',
-            :other => '{{count}} months'
-          },
-          :about_x_years => {
-            :one => 'about 1 year',
-            :other => 'about {{count}} year'
-          },
-          :over_x_years => {
-            :one => 'over 1 year',
-            :other => 'over {{count}} years'
-          }
-        }
-      }
-    }
-  end
-end
-
-class I18nSimpleBackendTranslationsTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_store_translations_adds_translations # no, really :-)
-    @backend.store_translations :'en', :foo => 'bar'
-    assert_equal Hash[:'en', {:foo => 'bar'}], backend_get_translations
-  end
-
-  def test_store_translations_deep_merges_translations
-    @backend.store_translations :'en', :foo => {:bar => 'bar'}
-    @backend.store_translations :'en', :foo => {:baz => 'baz'}
-    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], backend_get_translations
-  end
-
-  def test_store_translations_forces_locale_to_sym
-    @backend.store_translations 'en', :foo => 'bar'
-    assert_equal Hash[:'en', {:foo => 'bar'}], backend_get_translations
-  end
-
-  def test_store_translations_converts_keys_to_symbols
-    # backend_reset_translations!
-    @backend.store_translations 'en', 'foo' => {'bar' => 'bar', 'baz' => 'baz'}
-    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], backend_get_translations
-  end
-end
-
-class I18nSimpleBackendAvailableLocalesTest < Test::Unit::TestCase
-  def test_available_locales
-    @backend = I18n::Backend::Simple.new
-    @backend.store_translations 'de', :foo => 'bar'
-    @backend.store_translations 'en', :foo => 'foo'
-
-    assert_equal ['de', 'en'], @backend.available_locales.map{|locale| locale.to_s }.sort
-  end
-end
-
-class I18nSimpleBackendTranslateTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_translate_calls_lookup_with_locale_given
-    @backend.expects(:lookup).with('de', :bar, [:foo]).returns 'bar'
-    @backend.translate 'de', :bar, :scope => [:foo]
-  end
-
-  def test_given_no_keys_it_returns_the_default
-    assert_equal 'default', @backend.translate('en', nil, :default => 'default')
-  end
-
-  def test_translate_given_a_symbol_as_a_default_translates_the_symbol
-    assert_equal 'bar', @backend.translate('en', nil, :scope => [:foo], :default => :bar)
-  end
-
-  def test_translate_given_an_array_as_default_uses_the_first_match
-    assert_equal 'bar', @backend.translate('en', :does_not_exist, :scope => [:foo], :default => [:does_not_exist_2, :bar])
-  end
-
-  def test_translate_given_an_array_of_inexistent_keys_it_raises_missing_translation_data
-    assert_raise I18n::MissingTranslationData do
-      @backend.translate('en', :does_not_exist, :scope => [:foo], :default => [:does_not_exist_2, :does_not_exist_3])
-    end
-  end
-
-  def test_translate_an_array_of_keys_translates_all_of_them
-    assert_equal %w(bar baz), @backend.translate('en', [:bar, :baz], :scope => [:foo])
-  end
-
-  def test_translate_calls_pluralize
-    @backend.expects(:pluralize).with 'en', 'bar', 1
-    @backend.translate 'en', :bar, :scope => [:foo], :count => 1
-  end
-
-  def test_translate_calls_interpolate
-    @backend.expects(:interpolate).with 'en', 'bar', {}
-    @backend.translate 'en', :bar, :scope => [:foo]
-  end
-
-  def test_translate_calls_interpolate_including_count_as_a_value
-    @backend.expects(:interpolate).with 'en', 'bar', {:count => 1}
-    @backend.translate 'en', :bar, :scope => [:foo], :count => 1
-  end
-
-  def test_translate_given_nil_as_a_locale_raises_an_argument_error
-    assert_raise(I18n::InvalidLocale){ @backend.translate nil, :bar }
-  end
-
-  def test_translate_with_a_bogus_key_and_no_default_raises_missing_translation_data
-    assert_raise(I18n::MissingTranslationData){ @backend.translate 'de', :bogus }
-  end
-end
-
-class I18nSimpleBackendLookupTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  # useful because this way we can use the backend with no key for interpolation/pluralization
-  def test_lookup_given_nil_as_a_key_returns_nil
-    assert_nil @backend.send(:lookup, 'en', nil)
-  end
-
-  def test_lookup_given_nested_keys_looks_up_a_nested_hash_value
-    assert_equal 'bar', @backend.send(:lookup, 'en', :bar, [:foo])
-  end
-end
-
-class I18nSimpleBackendPluralizeTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_pluralize_given_nil_returns_the_given_entry
-    entry = {:one => 'bar', :other => 'bars'}
-    assert_equal entry, @backend.send(:pluralize, nil, entry, nil)
-  end
-
-  def test_pluralize_given_0_returns_zero_string_if_zero_key_given
-    assert_equal 'zero', @backend.send(:pluralize, nil, {:zero => 'zero', :one => 'bar', :other => 'bars'}, 0)
-  end
-
-  def test_pluralize_given_0_returns_plural_string_if_no_zero_key_given
-    assert_equal 'bars', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 0)
-  end
-
-  def test_pluralize_given_1_returns_singular_string
-    assert_equal 'bar', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 1)
-  end
-
-  def test_pluralize_given_2_returns_plural_string
-    assert_equal 'bars', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 2)
-  end
-
-  def test_pluralize_given_3_returns_plural_string
-    assert_equal 'bars', @backend.send(:pluralize, nil, {:one => 'bar', :other => 'bars'}, 3)
-  end
-
-  def test_interpolate_given_incomplete_pluralization_data_raises_invalid_pluralization_data
-    assert_raise(I18n::InvalidPluralizationData){ @backend.send(:pluralize, nil, {:one => 'bar'}, 2) }
-  end
-
-  # def test_interpolate_given_a_string_raises_invalid_pluralization_data
-  #   assert_raise(I18n::InvalidPluralizationData){ @backend.send(:pluralize, nil, 'bar', 2) }
-  # end
-  #
-  # def test_interpolate_given_an_array_raises_invalid_pluralization_data
-  #   assert_raise(I18n::InvalidPluralizationData){ @backend.send(:pluralize, nil, ['bar'], 2) }
-  # end
-end
-
-class I18nSimpleBackendInterpolateTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_interpolate_given_a_value_hash_interpolates_the_values_to_the_string
-    assert_equal 'Hi David!', @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => 'David')
-  end
-
-  def test_interpolate_given_a_value_hash_interpolates_into_unicode_string
-    assert_equal 'Hi David!', @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => 'David')
-  end
-
-  def test_interpolate_given_an_unicode_value_hash_interpolates_to_the_string
-    assert_equal 'Hi !', @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => '')
-  end
-
-  def test_interpolate_given_an_unicode_value_hash_interpolates_into_unicode_string
-    assert_equal '!', @backend.send(:interpolate, nil, '{{name}}!', :name => '')
-  end
-
-  if Kernel.const_defined?(:Encoding)
-    def test_interpolate_given_a_non_unicode_multibyte_value_hash_interpolates_into_a_string_with_the_same_encoding
-      assert_equal euc_jp('Hi !'), @backend.send(:interpolate, nil, 'Hi {{name}}!', :name => euc_jp(''))
-    end
-
-    def test_interpolate_given_an_unicode_value_hash_into_a_non_unicode_multibyte_string_raises_encoding_compatibility_error
-      assert_raise(Encoding::CompatibilityError) do
-        @backend.send(:interpolate, nil, euc_jp('{{name}}!'), :name => '')
-      end
-    end
-
-    def test_interpolate_given_a_non_unicode_multibyte_value_hash_into_an_unicode_string_raises_encoding_compatibility_error
-      assert_raise(Encoding::CompatibilityError) do
-        @backend.send(:interpolate, nil, '{{name}}!', :name => euc_jp(''))
-      end
-    end
-  end
-
-  def test_interpolate_given_nil_as_a_string_returns_nil
-    assert_nil @backend.send(:interpolate, nil, nil, :name => 'David')
-  end
-
-  def test_interpolate_given_an_non_string_as_a_string_returns_nil
-    assert_equal [], @backend.send(:interpolate, nil, [], :name => 'David')
-  end
-
-  def test_interpolate_given_a_values_hash_with_nil_values_interpolates_the_string
-    assert_equal 'Hi !', @backend.send(:interpolate, nil, 'Hi {{name}}!', {:name => nil})
-  end
-
-  def test_interpolate_given_an_empty_values_hash_raises_missing_interpolation_argument
-    assert_raise(I18n::MissingInterpolationArgument) { @backend.send(:interpolate, nil, 'Hi {{name}}!', {}) }
-  end
-
-  def test_interpolate_given_a_string_containing_a_reserved_key_raises_reserved_interpolation_key
-    assert_raise(I18n::ReservedInterpolationKey) { @backend.send(:interpolate, nil, '{{default}}', {:default => nil}) }
-  end
-  
-  private
-  
-  def euc_jp(string)
-    string.encode!(Encoding::EUC_JP)
-  end
-end
-
-class I18nSimpleBackendLocalizeDateTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def setup
-    @backend = I18n::Backend::Simple.new
-    add_datetime_translations
-    @date = Date.new 2008, 1, 1
-  end
-
-  def test_translate_given_the_short_format_it_uses_it
-    assert_equal '01. Jan', @backend.localize('de', @date, :short)
-  end
-
-  def test_translate_given_the_long_format_it_uses_it
-    assert_equal '01. Januar 2008', @backend.localize('de', @date, :long)
-  end
-
-  def test_translate_given_the_default_format_it_uses_it
-    assert_equal '01.01.2008', @backend.localize('de', @date, :default)
-  end
-
-  def test_translate_given_a_day_name_format_it_returns_a_day_name
-    assert_equal 'Dienstag', @backend.localize('de', @date, '%A')
-  end
-
-  def test_translate_given_an_abbr_day_name_format_it_returns_an_abbrevated_day_name
-    assert_equal 'Di', @backend.localize('de', @date, '%a')
-  end
-
-  def test_translate_given_a_month_name_format_it_returns_a_month_name
-    assert_equal 'Januar', @backend.localize('de', @date, '%B')
-  end
-
-  def test_translate_given_an_abbr_month_name_format_it_returns_an_abbrevated_month_name
-    assert_equal 'Jan', @backend.localize('de', @date, '%b')
-  end
-
-  def test_translate_given_no_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @date }
-  end
-
-  def test_translate_given_an_unknown_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @date, '%x' }
-  end
-
-  def test_localize_nil_raises_argument_error
-    assert_raise(I18n::ArgumentError) { @backend.localize 'de', nil }
-  end
-
-  def test_localize_object_raises_argument_error
-    assert_raise(I18n::ArgumentError) { @backend.localize 'de', Object.new }
-  end
-end
-
-class I18nSimpleBackendLocalizeDateTimeTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def setup
-    @backend = I18n::Backend::Simple.new
-    add_datetime_translations
-    @morning = DateTime.new 2008, 1, 1, 6
-    @evening = DateTime.new 2008, 1, 1, 18
-  end
-
-  def test_translate_given_the_short_format_it_uses_it
-    assert_equal '01. Jan 06:00', @backend.localize('de', @morning, :short)
-  end
-
-  def test_translate_given_the_long_format_it_uses_it
-    assert_equal '01. Januar 2008 06:00', @backend.localize('de', @morning, :long)
-  end
-
-  def test_translate_given_the_default_format_it_uses_it
-    assert_equal 'Di, 01. Jan 2008 06:00:00 +0000', @backend.localize('de', @morning, :default)
-  end
-
-  def test_translate_given_a_day_name_format_it_returns_the_correct_day_name
-    assert_equal 'Dienstag', @backend.localize('de', @morning, '%A')
-  end
-
-  def test_translate_given_an_abbr_day_name_format_it_returns_the_correct_abbrevated_day_name
-    assert_equal 'Di', @backend.localize('de', @morning, '%a')
-  end
-
-  def test_translate_given_a_month_name_format_it_returns_the_correct_month_name
-    assert_equal 'Januar', @backend.localize('de', @morning, '%B')
-  end
-
-  def test_translate_given_an_abbr_month_name_format_it_returns_the_correct_abbrevated_month_name
-    assert_equal 'Jan', @backend.localize('de', @morning, '%b')
-  end
-
-  def test_translate_given_a_meridian_indicator_format_it_returns_the_correct_meridian_indicator
-    assert_equal 'am', @backend.localize('de', @morning, '%p')
-    assert_equal 'pm', @backend.localize('de', @evening, '%p')
-  end
-
-  def test_translate_given_no_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning }
-  end
-
-  def test_translate_given_an_unknown_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning, '%x' }
-  end
-end
-
-class I18nSimpleBackendLocalizeTimeTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def setup
-    @old_timezone, ENV['TZ'] = ENV['TZ'], 'UTC'
-    @backend = I18n::Backend::Simple.new
-    add_datetime_translations
-    @morning = Time.parse '2008-01-01 6:00 UTC'
-    @evening = Time.parse '2008-01-01 18:00 UTC'
-  end
-
-  def teardown
-    @old_timezone ? ENV['TZ'] = @old_timezone : ENV.delete('TZ')
-  end
-
-  def test_translate_given_the_short_format_it_uses_it
-    assert_equal '01. Jan 06:00', @backend.localize('de', @morning, :short)
-  end
-
-  def test_translate_given_the_long_format_it_uses_it
-    assert_equal '01. Januar 2008 06:00', @backend.localize('de', @morning, :long)
-  end
-
-  # TODO Seems to break on Windows because ENV['TZ'] is ignored. What's a better way to do this?
-  # def test_translate_given_the_default_format_it_uses_it
-  #   assert_equal 'Di, 01. Jan 2008 06:00:00 +0000', @backend.localize('de', @morning, :default)
-  # end
-
-  def test_translate_given_a_day_name_format_it_returns_the_correct_day_name
-    assert_equal 'Dienstag', @backend.localize('de', @morning, '%A')
-  end
-
-  def test_translate_given_an_abbr_day_name_format_it_returns_the_correct_abbrevated_day_name
-    assert_equal 'Di', @backend.localize('de', @morning, '%a')
-  end
-
-  def test_translate_given_a_month_name_format_it_returns_the_correct_month_name
-    assert_equal 'Januar', @backend.localize('de', @morning, '%B')
-  end
-
-  def test_translate_given_an_abbr_month_name_format_it_returns_the_correct_abbrevated_month_name
-    assert_equal 'Jan', @backend.localize('de', @morning, '%b')
-  end
-
-  def test_translate_given_a_meridian_indicator_format_it_returns_the_correct_meridian_indicator
-    assert_equal 'am', @backend.localize('de', @morning, '%p')
-    assert_equal 'pm', @backend.localize('de', @evening, '%p')
-  end
-
-  def test_translate_given_no_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning }
-  end
-
-  def test_translate_given_an_unknown_format_it_does_not_fail
-    assert_nothing_raised{ @backend.localize 'de', @morning, '%x' }
-  end
-end
-
-class I18nSimpleBackendHelperMethodsTest < Test::Unit::TestCase
-  def setup
-    @backend = I18n::Backend::Simple.new
-  end
-
-  def test_deep_symbolize_keys_works
-    result = @backend.send :deep_symbolize_keys, 'foo' => {'bar' => {'baz' => 'bar'}}
-    expected = {:foo => {:bar => {:baz => 'bar'}}}
-    assert_equal expected, result
-  end
-end
-
-class I18nSimpleBackendLoadTranslationsTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def test_load_translations_with_unknown_file_type_raises_exception
-    assert_raise(I18n::UnknownFileType) { @backend.load_translations "#{@locale_dir}/en.xml" }
-  end
-
-  def test_load_translations_with_ruby_file_type_does_not_raise_exception
-    assert_nothing_raised { @backend.load_translations "#{@locale_dir}/en.rb" }
-  end
-
-  def test_load_rb_loads_data_from_ruby_file
-    data = @backend.send :load_rb, "#{@locale_dir}/en.rb"
-    assert_equal({:'en-Ruby' => {:foo => {:bar => "baz"}}}, data)
-  end
-
-  def test_load_rb_loads_data_from_yaml_file
-    data = @backend.send :load_yml, "#{@locale_dir}/en.yml"
-    assert_equal({'en-Yaml' => {'foo' => {'bar' => 'baz'}}}, data)
-  end
-
-  def test_load_translations_loads_from_different_file_formats
-    @backend = I18n::Backend::Simple.new
-    @backend.load_translations "#{@locale_dir}/en.rb", "#{@locale_dir}/en.yml"
-    expected = {
-      :'en-Ruby' => {:foo => {:bar => "baz"}},
-      :'en-Yaml' => {:foo => {:bar => "baz"}}
-    }
-    assert_equal expected, backend_get_translations
-  end
-end
-
-class I18nSimpleBackendLoadPathTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-
-  def teardown
-    I18n.load_path = []
-  end
-
-  def test_nested_load_paths_do_not_break_locale_loading
-    @backend = I18n::Backend::Simple.new
-    I18n.load_path = [[File.dirname(__FILE__) + '/locale/en.yml']]
-    assert_nil backend_get_translations
-    assert_nothing_raised { @backend.send :init_translations }
-    assert_not_nil backend_get_translations
-  end
-
-  def test_adding_arrays_of_filenames_to_load_path_do_not_break_locale_loading
-    @backend = I18n::Backend::Simple.new
-    I18n.load_path << Dir[File.dirname(__FILE__) + '/locale/*.{rb,yml}']
-    assert_nil backend_get_translations
-    assert_nothing_raised { @backend.send :init_translations }
-    assert_not_nil backend_get_translations
-  end
-end
-
-class I18nSimpleBackendReloadTranslationsTest < Test::Unit::TestCase
-  include I18nSimpleBackendTestSetup
-  
-  def setup
-    @backend = I18n::Backend::Simple.new
-    I18n.load_path = [File.dirname(__FILE__) + '/locale/en.yml']
-    assert_nil backend_get_translations
-    @backend.send :init_translations
-  end
-  
-  def teardown
-    I18n.load_path = []
-  end
-  
-  def test_setup
-    assert_not_nil backend_get_translations
-  end
-  
-  def test_reload_translations_unloads_translations
-    @backend.reload!
-    assert_nil backend_get_translations
-  end
-  
-  def test_reload_translations_uninitializes_translations
-    @backend.reload!
-    assert_equal @backend.initialized?, false
-  end
-end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/.gitignore b/activesupport/lib/active_support/vendor/i18n-0.3.3/.gitignore
new file mode 100644
index 0000000..0f41a39
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/.gitignore
@@ -0,0 +1,3 @@
+.DS_Store
+test/rails/fixtures
+doc
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/CHANGELOG.textile b/activesupport/lib/active_support/vendor/i18n-0.3.3/CHANGELOG.textile
new file mode 100644
index 0000000..462ff27
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/CHANGELOG.textile
@@ -0,0 +1,76 @@
+h1. Changelog
+
+h2. master
+
+* (no changes)
+
+h2. 0.3.1 (2009-12-11)
+
+* "Add PoParser to gemspec":http://github.com/svenfuchs/i18n/commit/d6b2763f39c932f66adb039b96882a472f883c51
+* "Enable custom separators for ActiveRecord backend":http://github.com/svenfuchs/i18n/commit/9341d3fcfc951cc31807ba672d2b5d90909ef3e5
+* "Pass interpolation values to interpolation procs":http://github.com/svenfuchs/i18n/commit/39c2ed8fbad645671cd5520ce7ad0aeefe2b0cca
+* "Fix that ngettext supports keys with dots":http://github.com/svenfuchs/i18n/commit/7362a43c34364d500de8899cfcca6bf1a5e6d1c8
+
+h2. 0.3.0 (2009-11-30)
+
+* "Gettext backend and helpers":http://github.com/svenfuchs/i18n/commit/35a1740d2f10b808548af352006950da4017e374
+* "Metadata module":http://github.com/svenfuchs/i18n/commit/2677208555179b36fcbe958c0e8bc642cf5bc020
+* "Basic ActiveRecord backend":http://github.com/svenfuchs/i18n/commit/786632d0b42de423ecf0969622efc87f1691e2a2
+* "Set encoding to UTF8 for all files":http://github.com/svenfuchs/i18n/commit/9be3d4a311b5bf583eec5d39986176cc40c112f2
+* "Chain backend":http://github.com/svenfuchs/i18n/commit/08259ffb88b3005403648d77bc1cbca0b92f3cf5
+* "Backend/cache implementation":http://github.com/svenfuchs/i18n/commit/e7bf15351cd2e27f5972eb40e65a5dd6f4a0feed
+* "Pluralization module":http://github.com/svenfuchs/i18n/commit/9ca4c9ed52d4706566a6abeb2d78722dcc5d4764
+* "add and adapt Globalize2 fallback implementation":http://github.com/svenfuchs/i18n/commit/1b37a303b27d6222b17162804b06323e5628768f
+* "move Simple backend implementation to a Base backend class and extend Simple from Base.":http://github.com/svenfuchs/i18n/commit/32ddc80a04e6aa247f6d6613bde7f78c73396cb4
+
+h2. 0.2.0 (2009-07-12)
+
+* "Allow using Ruby 1.9 syntax for string interpolation (API addition)":http://github.com/svenfuchs/i18n/commit/c6e0b06d512f2af57199a843a1d8a40241b32861
+* "Allow configuring the default scope separator, allow to pass a custom scope separator(API addition)":http://github.com/svenfuchs/i18n/commit/5b75bfbc348061adc11e3790187a187275bfd471 (e.g. I18n.t(:'foo|bar', :separator => '|') 
+* "Pass :format option to #translate for #localize more useful lambda support":http://github.com/svenfuchs/i18n/commit/e277711b3c844fe7589b8d3f9af0f7d1b969a273
+* "Refactor Simple backend #resolve to #default and #resolve for more consistency. Now allows to pass lambdas as defaults and re-resolve Symbols":http://github.com/svenfuchs/i18n/commit/8c4ce3d923ce5fa73e973fe28217e18165549aba
+* "Add lambda support to #translate (API addition)":http://github.com/svenfuchs/i18n/commit/c90e62d8f7d3d5b78f34cfe328d871b58884f115
+* "Add lambda support to #localize (API addition)":http://github.com/svenfuchs/i18n/commit/9d390afcf33f3f469bb95e6888147152f6cc7442
+
+h2. 0.1.3 (2009-02-27)
+
+* "Remove unnecessary string encoding handling in the i18n simple backend which made the backend break on Ruby 1.9":http://github.com/svenfuchs/i18n/commit/4c3a970783861a94f2e89f46714fb3434e4f4f8d
+
+h2. 0.1.2 (2009-01-09)
+
+* "added #available_locales (returns an array of locales for which translations are available)":http://github.com/svenfuchs/i18n/commit/411f8fe7c8f3f89e9b6b921fa62ed66cb92f3af4
+* "flatten load_path before using it so that a nested array of paths won't throw up":http://github.com/svenfuchs/i18n/commit/d473a068a2b90aba98135deb225d6eb6d8104d70
+
+h2. 0.1.1 (2008-11-20)
+
+* "Use :'en' as a default locale (in favor of :'en-US')":http://github.com/svenfuchs/i18n/commit/c4b10b246aecf7da78cb2568dd0d2ab7e6b8a230
+* "Add #reload! to Simple backend":http://github.com/svenfuchs/i18n/commit/36dd2bd9973b9e1559728749a9daafa44693e964
+
+h2. 0.1.0 (2008-10-25)
+
+* "Fix Simple backend to distinguish false from nil values":http://github.com/svenfuchs/i18n/commit/39d9a47da14b5f3ba126af48923af8c30e135166
+* "Add #load_path to public api, add initialize to simple backend and remove #load_translations from public api":http://github.com/svenfuchs/i18n/commit/c4c5649e6bc8f020f1aaf5a5470bde048e22c82d
+* "Speed up Backend::Simple#interpolate":http://github.com/svenfuchs/i18n/commit/9e1ac6bf8833304e036323ec9932b9f33c468a35
+* "Remove #populate and #store_translations from public API":http://github.com/svenfuchs/i18n/commit/f4e514a80be7feb509f66824ee311905e2940900
+* "Use :other instead of :many as a plural key":http://github.com/svenfuchs/i18n/commit/0f8f20a2552bf6a2aa758d8fdd62a7154e4a1bf6
+* "Use a class instead of a module for Simple backend":http://github.com/svenfuchs/i18n/commit/08f051aa61320c17debde24a83268bc74e33b995
+* "Make Simple backend #interpolate deal with non-ASCII string encodings":http://github.com/svenfuchs/i18n/commit/d84a3f3f55543c084d5dc5d1fed613b8df148789
+* "Fix default arrays of non-existant keys returning the default array":http://github.com/svenfuchs/i18n/commit/6c04ca86c87f97dc78f07c2a4023644e5ba8b839
+
+h2. Initial implementation (June/July 2008)
+
+Initial implementation by "Sven Fuchs":http://www.workingwithrails.com/person/9963-sven-fuchs based on previous discussion/consensus of the rails-i18n team (alphabetical order) and many others:
+
+* "Matt Aimonetti":http://railsontherun.com
+* "Sven Fuchs":http://www.workingwithrails.com/person/9963-sven-fuchs
+* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
+* "Saimon Moore":http://saimonmoore.net
+* "Stephan Soller":http://www.arkanis-development.de
+
+h2. More information
+
+* "Homepage":http://rails-i18n.org
+* "Wiki":http://rails-i18n.org/wiki
+* "Mailinglist":http://groups.google.com/group/rails-i18n
+* "About the project/history":http://www.artweb-design.de/2008/7/18/finally-ruby-on-rails-gets-internationalized
+* "Initial API Intro":http://www.artweb-design.de/2008/7/18/the-ruby-on-rails-i18n-core-api
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/MIT-LICENSE b/activesupport/lib/active_support/vendor/i18n-0.3.3/MIT-LICENSE
new file mode 100755
index 0000000..ed8e9ee
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/MIT-LICENSE
@@ -0,0 +1,20 @@
+Copyright (c) 2008 The Ruby I18n team
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/README.textile b/activesupport/lib/active_support/vendor/i18n-0.3.3/README.textile
new file mode 100644
index 0000000..faa9492
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/README.textile
@@ -0,0 +1,81 @@
+h1. Ruby I18n
+
+Ruby Internationalization and localization solution.
+
+Features:
+
+* translation and localization
+* interpolation of values to translations (Ruby 1.9 compatible syntax)
+* pluralization (CLDR compatible)
+* flexible defaults
+* bulk lookup
+* lambdas as translation data
+* custom key/scope separator
+* custom exception handlers
+* extensible architecture with a swappable backend
+
+Pluggable features:
+
+* Cache
+* Pluralization: lambda pluralizers stored as translation data
+* Locale fallbacks, RFC4647 compliant (optionally: RFC4646 locale validation)
+* Gettext support
+* Translation metadata
+
+Alternative backends:
+
+* Chain
+* ActiveRecord (optionally: ActiveRecordMissing)
+
+For more information and lots of resources see: "http://rails-i18n.org/wiki":http://rails-i18n.org/wiki
+
+h2. Installation
+
+gem install i18n
+
+h3. Installation on Rails < 2.3.5 (deprecated)
+
+Up to version 2.3.4 Rails will not accept i18n gems > 0.1.3. There is an unpacked 
+gem inside of active_support/lib/vendor which gets loaded unless gem 'i18n', '~> 0.1.3'. 
+This requirement is relaxed in "6da03653":http://github.com/rails/rails/commit/6da03653
+
+The new i18n gem can be loaded from vendor/plugins like this:
+
+  def reload_i18n!
+    raise "Move to i18n version 0.2.0 or greater" if Rails.version > "2.3.4"
+  
+    $:.grep(/i18n/).each { |path| $:.delete(path) }
+    I18n::Backend.send :remove_const, "Simple"
+    $: << Rails.root.join('vendor', 'plugins', 'i18n', 'lib').to_s
+  end
+
+Then you can `reload_i18n!` inside an i18n initializer. 
+
+h2. Authors
+
+* "Sven Fuchs":http://www.artweb-design.de
+* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
+* "Stephan Soller":http://www.arkanis-development.de
+* "Saimon Moore":http://saimonmoore.net
+* "Matt Aimonetti":http://railsontherun.com
+
+h2. Contributors
+
+* Akira Matsuda
+* Andrew Briening
+* Clemens Kofler
+* Frederick Cheung
+* Jeremy Kemper
+* Jos Valim
+* Lawrence Pit
+* Luca Guidi
+* M4SSIVE
+* Marko Seppae
+* Mathias Meyer
+* Michael Lang
+* Theo Cushion
+* Yaroslav Markin
+
+h2. License
+
+MIT License. See the included MIT-LICENCE file.
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/Rakefile b/activesupport/lib/active_support/vendor/i18n-0.3.3/Rakefile
new file mode 100644
index 0000000..8159271
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/Rakefile
@@ -0,0 +1,24 @@
+task :default => [:test]
+
+task :test do
+  ruby "test/all.rb"
+end
+
+require File.expand_path("lib/i18n/version", File.dirname(__FILE__))
+
+begin
+  require 'jeweler'
+  Jeweler::Tasks.new do |s|
+    s.name = "i18n"
+    s.version = I18n::VERSION
+    s.rubyforge_project = "i18n"
+    s.summary = "New wave Internationalization support for Ruby"
+    s.email = "rails-i18n@googlegroups.com"
+    s.homepage = "http://rails-i18n.org"
+    s.description = "Add Internationalization support to your Ruby application."
+    s.authors = ['Sven Fuchs', 'Joshua Harvey', 'Matt Aimonetti', 'Stephan Soller', 'Saimon Moore']
+    s.files =  FileList["[A-Z]*", "{lib,test,vendor}/**/*"]
+  end
+rescue LoadError
+  puts "Jeweler, or one of its dependencies, is not available. Install it with: sudo gem install technicalpickles-jeweler -s http://gems.github.com"
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/example.yml b/activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/example.yml
new file mode 100644
index 0000000..2f5b349
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/example.yml
@@ -0,0 +1,144 @@
+en:
+  first: "First"
+  activerecord:
+    errors:
+      messages:
+        inclusion: "is not included in the list"
+        exclusion: "is reserved"
+        invalid: "is invalid"
+        confirmation: "doesn't match confirmation"
+        accepted: "must be accepted"
+        empty: "can't be empty"
+        blank: "can't be blank"
+        too_long: "is too long (maximum is {{count}} characters)"
+        too_short: "is too short (minimum is {{count}} characters)"
+        wrong_length: "is the wrong length (should be {{count}} characters)"
+        taken: "has already been taken"
+        not_a_number: "is not a number"
+        greater_than: "must be greater than {{count}}"
+        greater_than_or_equal_to: "must be greater than or equal to {{count}}"
+        equal_to: "must be equal to {{count}}"
+        less_than: "must be less than {{count}}"
+        less_than_or_equal_to: "must be less than or equal to {{count}}"
+        odd: "must be odd"
+        even: "must be even"
+        record_invalid: "Validation failed: {{errors}}"
+
+      models:
+        user:
+          blank: "This is a custom blank message for {{model}}: {{attribute}}"
+          attributes:
+            login:
+              blank: "This is a custom blank message for User login"
+        
+
+    models:
+      user: "Dude"
+    
+    attributes:
+      admins:
+        user:
+          login: "Handle"
+
+  date:
+    formats:
+      # Use the strftime parameters for formats.
+      # When no format has been given, it uses default.
+      # You can provide other formats here if you like!
+      default: "%Y-%m-%d"
+      short: "%b %d"
+      long: "%B %d, %Y"
+
+    day_names: [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]
+    abbr_day_names: [Sun, Mon, Tue, Wed, Thu, Fri, Sat]
+
+    # Don't forget the nil at the beginning; there's no such thing as a 0th month
+    month_names: [~, January, February, March, April, May, June, July, August, September, October, November, December]
+    abbr_month_names: [~, Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]
+    # Used in date_select and datime_select.
+    order: [ :year, :month, :day ]
+
+  time:
+    formats:
+      default: "%a, %d %b %Y %H:%M:%S %z"
+      short: "%d %b %H:%M"
+      long: "%B %d, %Y %H:%M"
+    am: "am"
+    pm: "pm"
+
+  support:
+    array:
+      words_connector: ", "
+      two_words_connector: " and "
+      last_word_connector: ", and "
+
+  activemodel:
+    errors:
+      messages:
+        inclusion: "is not included in the list"
+        exclusion: "is reserved"
+        invalid: "is invalid"
+        confirmation: "doesn't match confirmation"
+        accepted: "must be accepted"
+        empty: "can't be empty"
+        blank: "can't be blank"
+        too_long: "is too long (maximum is {{count}} characters)"
+        too_short: "is too short (minimum is {{count}} characters)"
+        wrong_length: "is the wrong length (should be {{count}} characters)"
+        taken: "has already been taken"
+        not_a_number: "is not a number"
+        greater_than: "must be greater than {{count}}"
+        greater_than_or_equal_to: "must be greater than or equal to {{count}}"
+        equal_to: "must be equal to {{count}}"
+        less_than: "must be less than {{count}}"
+        less_than_or_equal_to: "must be less than or equal to {{count}}"
+        odd: "must be odd"
+        even: "must be even"
+        record_invalid: "Validation failed: {{errors}}"
+
+      models:
+        user:
+          blank: "This is a custom blank message for {{model}}: {{attribute}}"
+          attributes:
+            login:
+              blank: "This is a custom blank message for User login"
+
+    models:
+      user: "Dude"
+
+    attributes:
+      user:
+        login: "Handle"
+
+  model_data:
+    date:
+      formats:
+        # Use the strftime parameters for formats.
+        # When no format has been given, it uses default.
+        # You can provide other formats here if you like!
+        default: "%Y-%m-%d"
+        short: "%b %d"
+        long: "%B %d, %Y"
+
+      day_names: [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]
+      abbr_day_names: [Sun, Mon, Tue, Wed, Thu, Fri, Sat]
+
+      # Don't forget the nil at the beginning; there's no such thing as a 0th month
+      month_names: [~, January, February, March, April, May, June, July, August, September, October, November, December]
+      abbr_month_names: [~, Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]
+      # Used in date_select and datime_select.
+      order: [ :year, :month, :day ]
+
+    time:
+      formats:
+        default: "%a, %d %b %Y %H:%M:%S %z"
+        short: "%d %b %H:%M"
+        long: "%B %d, %Y %H:%M"
+      am: "am"
+      pm: "pm"
+
+    support:
+      array:
+        words_connector: ", "
+        two_words_connector: " and "
+        last_word_connector: ", and "
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/run.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/run.rb
new file mode 100644
index 0000000..8a66708
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/benchmark/run.rb
@@ -0,0 +1,71 @@
+#! /usr/bin/ruby
+$:.unshift File.expand_path("../lib", File.dirname(__FILE__))
+
+require 'i18n'
+require 'i18n/core_ext/object/meta_class'
+require 'benchmark'
+require 'yaml'
+
+# Load YAML example file
+YAML_HASH = YAML.load_file(File.expand_path("example.yml", File.dirname(__FILE__)))
+
+# Create benchmark backends
+def create_backend(*modules)
+  Class.new do
+    modules.unshift(:Base)
+    modules.each { |m| include I18n::Backend.const_get(m) }
+  end
+end
+
+BACKENDS = []
+BACKENDS << (SimpleBackend        = create_backend)
+BACKENDS << (FastBackend          = create_backend(:Fast))
+BACKENDS << (InterpolationBackend = create_backend(:InterpolationCompiler))
+BACKENDS << (FastInterpolBackend  = create_backend(:Fast, :InterpolationCompiler))
+
+# Hack Report to print ms
+module Benchmark
+  def self.ms(label = "", width=20, &blk) # :yield:
+    print label.ljust(width)
+    res = Benchmark::measure(&blk)
+    print format("%10.6f ms\n", res.real * 1000)
+    res
+  end
+end
+
+# Run!
+BACKENDS.each do |backend|
+  I18n.backend = backend.new
+  puts "===> #{backend.name}\n\n"
+
+  Benchmark.ms "store" do
+    I18n.backend.store_translations *(YAML_HASH.to_a.first)
+    I18n.backend.translate :en, :first
+  end
+
+  Benchmark.ms "t (depth=3)" do
+    I18n.backend.translate :en, :"activerecord.models.user"
+  end
+
+  Benchmark.ms "t (depth=5)" do
+    I18n.backend.translate :en, :"activerecord.attributes.admins.user.login"
+  end
+
+  Benchmark.ms "t (depth=7)" do
+    I18n.backend.translate :en, :"activerecord.errors.models.user.attributes.login.blank"
+  end
+
+  Benchmark.ms "t w/ default" do
+    I18n.backend.translate :en, :"activerecord.models.another", :default => "Another"
+  end
+
+  Benchmark.ms "t w/ interpolation" do
+    I18n.backend.translate :en, :"activerecord.errors.models.user.blank", :model => "User", :attribute => "name"
+  end
+
+  Benchmark.ms "t subtree" do
+    I18n.backend.translate :en, :"activerecord.errors.messages"
+  end
+
+  puts
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/contributors.txt b/activesupport/lib/active_support/vendor/i18n-0.3.3/contributors.txt
new file mode 100644
index 0000000..3f24c57
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/contributors.txt
@@ -0,0 +1,17 @@
+Akira Matsuda
+Andrew Briening
+Clemens Kofler
+Frederick Cheung
+Jeremy Kemper
+Josh Harvey
+Jos Valim
+Lawrence Pit
+Luca Guidi
+M4SSIVE
+Marko Seppae
+Mathias Meyer
+Matt Aimonetti
+Michael Lang
+Sven Fuchs
+Theo Cushion
+Yaroslav Markin
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/i18n.gemspec b/activesupport/lib/active_support/vendor/i18n-0.3.3/i18n.gemspec
new file mode 100644
index 0000000..46b4290
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/i18n.gemspec
@@ -0,0 +1,165 @@
+# Generated by jeweler
+# DO NOT EDIT THIS FILE DIRECTLY
+# Instead, edit Jeweler::Tasks in Rakefile, and run the gemspec command
+# -*- encoding: utf-8 -*-
+
+Gem::Specification.new do |s|
+  s.name = %q{i18n}
+  s.version = "0.3.3"
+
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.authors = ["Sven Fuchs", "Joshua Harvey", "Matt Aimonetti", "Stephan Soller", "Saimon Moore"]
+  s.date = %q{2009-12-29}
+  s.description = %q{Add Internationalization support to your Ruby application.}
+  s.email = %q{rails-i18n@googlegroups.com}
+  s.extra_rdoc_files = [
+    "README.textile"
+  ]
+  s.files = [
+    "CHANGELOG.textile",
+     "MIT-LICENSE",
+     "README.textile",
+     "Rakefile",
+     "lib/i18n.rb",
+     "lib/i18n/backend.rb",
+     "lib/i18n/backend/active_record.rb",
+     "lib/i18n/backend/active_record/missing.rb",
+     "lib/i18n/backend/active_record/store_procs.rb",
+     "lib/i18n/backend/active_record/translation.rb",
+     "lib/i18n/backend/base.rb",
+     "lib/i18n/backend/cache.rb",
+     "lib/i18n/backend/cascade.rb",
+     "lib/i18n/backend/chain.rb",
+     "lib/i18n/backend/fallbacks.rb",
+     "lib/i18n/backend/fast.rb",
+     "lib/i18n/backend/gettext.rb",
+     "lib/i18n/backend/helpers.rb",
+     "lib/i18n/backend/interpolation_compiler.rb",
+     "lib/i18n/backend/metadata.rb",
+     "lib/i18n/backend/pluralization.rb",
+     "lib/i18n/backend/simple.rb",
+     "lib/i18n/core_ext/object/meta_class.rb",
+     "lib/i18n/core_ext/string/interpolate.rb",
+     "lib/i18n/exceptions.rb",
+     "lib/i18n/gettext.rb",
+     "lib/i18n/helpers.rb",
+     "lib/i18n/helpers/gettext.rb",
+     "lib/i18n/locale.rb",
+     "lib/i18n/locale/fallbacks.rb",
+     "lib/i18n/locale/tag.rb",
+     "lib/i18n/locale/tag/parents.rb",
+     "lib/i18n/locale/tag/rfc4646.rb",
+     "lib/i18n/locale/tag/simple.rb",
+     "lib/i18n/version.rb",
+     "test/all.rb",
+     "test/api/basics.rb",
+     "test/api/defaults.rb",
+     "test/api/interpolation.rb",
+     "test/api/link.rb",
+     "test/api/localization/date.rb",
+     "test/api/localization/date_time.rb",
+     "test/api/localization/procs.rb",
+     "test/api/localization/time.rb",
+     "test/api/lookup.rb",
+     "test/api/pluralization.rb",
+     "test/api/procs.rb",
+     "test/cases/api/active_record_test.rb",
+     "test/cases/api/all_features_test.rb",
+     "test/cases/api/cascade_test.rb",
+     "test/cases/api/chain_test.rb",
+     "test/cases/api/fallbacks_test.rb",
+     "test/cases/api/fast_test.rb",
+     "test/cases/api/pluralization_test.rb",
+     "test/cases/api/simple_test.rb",
+     "test/cases/backend/active_record/missing_test.rb",
+     "test/cases/backend/active_record_test.rb",
+     "test/cases/backend/cache_test.rb",
+     "test/cases/backend/cascade_test.rb",
+     "test/cases/backend/chain_test.rb",
+     "test/cases/backend/fallbacks_test.rb",
+     "test/cases/backend/fast_test.rb",
+     "test/cases/backend/helpers_test.rb",
+     "test/cases/backend/interpolation_compiler_test.rb",
+     "test/cases/backend/metadata_test.rb",
+     "test/cases/backend/pluralization_test.rb",
+     "test/cases/backend/simple_test.rb",
+     "test/cases/core_ext/string/interpolate_test.rb",
+     "test/cases/gettext/api_test.rb",
+     "test/cases/gettext/backend_test.rb",
+     "test/cases/i18n_exceptions_test.rb",
+     "test/cases/i18n_load_path_test.rb",
+     "test/cases/i18n_test.rb",
+     "test/cases/locale/fallbacks_test.rb",
+     "test/cases/locale/tag/rfc4646_test.rb",
+     "test/cases/locale/tag/simple_test.rb",
+     "test/fixtures/locales/de.po",
+     "test/fixtures/locales/en.rb",
+     "test/fixtures/locales/en.yml",
+     "test/fixtures/locales/plurals.rb",
+     "test/test_helper.rb",
+     "vendor/po_parser.rb"
+  ]
+  s.homepage = %q{http://rails-i18n.org}
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.require_paths = ["lib"]
+  s.rubyforge_project = %q{i18n}
+  s.rubygems_version = %q{1.3.5}
+  s.summary = %q{New wave Internationalization support for Ruby}
+  s.test_files = [
+    "test/all.rb",
+     "test/api/basics.rb",
+     "test/api/defaults.rb",
+     "test/api/interpolation.rb",
+     "test/api/link.rb",
+     "test/api/localization/date.rb",
+     "test/api/localization/date_time.rb",
+     "test/api/localization/procs.rb",
+     "test/api/localization/time.rb",
+     "test/api/lookup.rb",
+     "test/api/pluralization.rb",
+     "test/api/procs.rb",
+     "test/cases/api/active_record_test.rb",
+     "test/cases/api/all_features_test.rb",
+     "test/cases/api/cascade_test.rb",
+     "test/cases/api/chain_test.rb",
+     "test/cases/api/fallbacks_test.rb",
+     "test/cases/api/fast_test.rb",
+     "test/cases/api/pluralization_test.rb",
+     "test/cases/api/simple_test.rb",
+     "test/cases/backend/active_record/missing_test.rb",
+     "test/cases/backend/active_record_test.rb",
+     "test/cases/backend/cache_test.rb",
+     "test/cases/backend/cascade_test.rb",
+     "test/cases/backend/chain_test.rb",
+     "test/cases/backend/fallbacks_test.rb",
+     "test/cases/backend/fast_test.rb",
+     "test/cases/backend/helpers_test.rb",
+     "test/cases/backend/interpolation_compiler_test.rb",
+     "test/cases/backend/metadata_test.rb",
+     "test/cases/backend/pluralization_test.rb",
+     "test/cases/backend/simple_test.rb",
+     "test/cases/core_ext/string/interpolate_test.rb",
+     "test/cases/gettext/api_test.rb",
+     "test/cases/gettext/backend_test.rb",
+     "test/cases/i18n_exceptions_test.rb",
+     "test/cases/i18n_load_path_test.rb",
+     "test/cases/i18n_test.rb",
+     "test/cases/locale/fallbacks_test.rb",
+     "test/cases/locale/tag/rfc4646_test.rb",
+     "test/cases/locale/tag/simple_test.rb",
+     "test/fixtures/locales/en.rb",
+     "test/fixtures/locales/plurals.rb",
+     "test/test_helper.rb"
+  ]
+
+  if s.respond_to? :specification_version then
+    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION
+    s.specification_version = 3
+
+    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then
+    else
+    end
+  else
+  end
+end
+
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/init.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/init.rb
new file mode 100644
index 0000000..b32b79b
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/init.rb
@@ -0,0 +1 @@
+require File.dirname(__FILE__) + '/lib/i18n'
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n.rb
new file mode 100755
index 0000000..e2a7bc0
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n.rb
@@ -0,0 +1,277 @@
+# encoding: utf-8
+
+# Authors::   Sven Fuchs (http://www.artweb-design.de),
+#             Joshua Harvey (http://www.workingwithrails.com/person/759-joshua-harvey),
+#             Stephan Soller (http://www.arkanis-development.de/),
+#             Saimon Moore (http://saimonmoore.net),
+#             Matt Aimonetti (http://railsontherun.com/)
+# Copyright:: Copyright (c) 2008 The Ruby i18n Team
+# License::   MIT
+require 'i18n/exceptions'
+require 'i18n/core_ext/string/interpolate'
+
+module I18n
+  autoload :Backend, 'i18n/backend'
+  autoload :Helpers, 'i18n/helpers'
+  autoload :Locale,  'i18n/locale'
+
+  @@backend = nil
+  @@load_path = nil
+  @@default_locale = :en
+  @@default_separator = '.'
+  @@exception_handler = :default_exception_handler
+
+  class << self
+    # Returns the current backend. Defaults to +Backend::Simple+.
+    def backend
+      @@backend ||= Backend::Simple.new
+    end
+
+    # Sets the current backend. Used to set a custom backend.
+    def backend=(backend)
+      @@backend = backend
+    end
+
+    # Returns the current default locale. Defaults to :'en'
+    def default_locale
+      @@default_locale
+    end
+
+    # Sets the current default locale. Used to set a custom default locale.
+    def default_locale=(locale)
+      @@default_locale = locale.to_sym rescue nil
+    end
+
+    # Returns the current locale. Defaults to I18n.default_locale.
+    def locale
+      Thread.current[:locale] ||= default_locale
+    end
+
+    # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
+    def locale=(locale)
+      Thread.current[:locale] = locale.to_sym rescue nil
+    end
+
+    # Returns an array of locales for which translations are available.
+    # Unless you explicitely set the these through I18n.available_locales=
+    # the call will be delegated to the backend and memoized on the I18n module.
+    def available_locales
+      @@available_locales ||= backend.available_locales
+    end
+
+    # Sets the available locales.
+    def available_locales=(locales)
+      @@available_locales = locales
+    end
+
+    # Returns the current default scope separator. Defaults to '.'
+    def default_separator
+      @@default_separator
+    end
+
+    # Sets the current default scope separator.
+    def default_separator=(separator)
+      @@default_separator = separator
+    end
+
+    # Sets the exception handler.
+    def exception_handler=(exception_handler)
+      @@exception_handler = exception_handler
+    end
+
+    # Allow clients to register paths providing translation data sources. The
+    # backend defines acceptable sources.
+    #
+    # E.g. the provided SimpleBackend accepts a list of paths to translation
+    # files which are either named *.rb and contain plain Ruby Hashes or are
+    # named *.yml and contain YAML data. So for the SimpleBackend clients may
+    # register translation files like this:
+    #   I18n.load_path << 'path/to/locale/en.yml'
+    def load_path
+      @@load_path ||= []
+    end
+
+    # Sets the load path instance. Custom implementations are expected to
+    # behave like a Ruby Array.
+    def load_path=(load_path)
+      @@load_path = load_path
+    end
+
+    # Tells the backend to reload translations. Used in situations like the
+    # Rails development environment. Backends can implement whatever strategy
+    # is useful.
+    def reload!
+      backend.reload!
+    end
+
+    # Translates, pluralizes and interpolates a given key using a given locale,
+    # scope, and default, as well as interpolation values.
+    #
+    # *LOOKUP*
+    #
+    # Translation data is organized as a nested hash using the upper-level keys
+    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
+    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
+    #
+    # Translations can be looked up at any level of this hash using the key argument
+    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
+    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
+    #
+    # Key can be either a single key or a dot-separated key (both Strings and Symbols
+    # work). <em>E.g.</em>, the short format can be looked up using both:
+    #   I18n.t 'date.formats.short'
+    #   I18n.t :'date.formats.short'
+    #
+    # Scope can be either a single key, a dot-separated key or an array of keys
+    # or dot-separated keys. Keys and scopes can be combined freely. So these
+    # examples will all look up the same short date format:
+    #   I18n.t 'date.formats.short'
+    #   I18n.t 'formats.short', :scope => 'date'
+    #   I18n.t 'short', :scope => 'date.formats'
+    #   I18n.t 'short', :scope => %w(date formats)
+    #
+    # *INTERPOLATION*
+    #
+    # Translations can contain interpolation variables which will be replaced by
+    # values passed to #translate as part of the options hash, with the keys matching
+    # the interpolation variable names.
+    #
+    # <em>E.g.</em>, with a translation <tt>:foo => "foo {{bar}}"</tt> the option
+    # value for the key +bar+ will be interpolated into the translation:
+    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
+    #
+    # *PLURALIZATION*
+    #
+    # Translation data can contain pluralized translations. Pluralized translations
+    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
+    #
+    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
+    # pluralization rules. Other algorithms can be supported by custom backends.
+    #
+    # This returns the singular version of a pluralized translation:
+    #   I18n.t :foo, :count => 1 # => 'Foo'
+    #
+    # These both return the plural version of a pluralized translation:
+    #   I18n.t :foo, :count => 0 # => 'Foos'
+    #   I18n.t :foo, :count => 2 # => 'Foos'
+    #
+    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
+    # <em>E.g.</em>, with the translation
+    # <tt>:foo => ['{{count}} foo', '{{count}} foos']</tt>, count will
+    # be interpolated to the pluralized translation:
+    #   I18n.t :foo, :count => 1 # => '1 foo'
+    #
+    # *DEFAULTS*
+    #
+    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
+    #   I18n.t :foo, :default => 'default'
+    #
+    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
+    # translation for <tt>:foo</tt> was found:
+    #   I18n.t :foo, :default => :bar
+    #
+    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
+    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
+    #   I18n.t :foo, :default => [:bar, 'default']
+    #
+    # *BULK LOOKUP*
+    #
+    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
+    #   I18n.t [:foo, :bar]
+    #
+    # Can be used with dot-separated nested keys:
+    #   I18n.t [:'baz.foo', :'baz.bar']
+    #
+    # Which is the same as using a scope option:
+    #   I18n.t [:foo, :bar], :scope => :baz
+    #
+    # *LAMBDAS*
+    #
+    # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
+    # called and passed the key and options.
+    #
+    # E.g. assuming the key <tt>:salutation</tt> resolves to:
+    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. {{options[:name]}}" : "Mrs. {{options[:name]}}"}
+    #
+    # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
+    #
+    # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
+    # a cache layer is put in front of I18n.translate it will generate a cache key
+    # from the argument values passed to #translate. Therefor your lambdas should
+    # always return the same translations/values per unique combination of argument
+    # values.
+    def translate(*args)
+      options = args.pop if args.last.is_a?(Hash)
+      key     = args.shift
+      locale  = options && options.delete(:locale) || I18n.locale
+      raises  = options && options.delete(:raise)
+      backend.translate(locale, key, options || {})
+    rescue I18n::ArgumentError => exception
+      raise exception if raises
+      handle_exception(exception, locale, key, options)
+    end
+    alias :t :translate
+
+    def translate!(key, options = {})
+      translate(key, options.merge( :raise => true ))
+    end
+    alias :t! :translate!
+
+    # Localizes certain objects, such as dates and numbers to local formatting.
+    def localize(object, options = {})
+      locale = options[:locale] || I18n.locale
+      format = options[:format] || :default
+      backend.localize(locale, object, format)
+    end
+    alias :l :localize
+
+  # making these private until Ruby 1.9.2 can send to protected methods again
+  # see http://redmine.ruby-lang.org/repositories/revision/ruby-19?rev=24280
+  private
+
+    # Handles exceptions raised in the backend. All exceptions except for
+    # MissingTranslationData exceptions are re-raised. When a MissingTranslationData
+    # was caught and the option :raise is not set the handler returns an error
+    # message string containing the key/scope.
+    def default_exception_handler(exception, locale, key, options)
+      return exception.message if MissingTranslationData === exception
+      raise exception
+    end
+
+    # Any exceptions thrown in translate will be sent to the @@exception_handler
+    # which can be a Symbol, a Proc or any other Object.
+    #
+    # If exception_handler is a Symbol then it will simply be sent to I18n as
+    # a method call. A Proc will simply be called. In any other case the
+    # method #call will be called on the exception_handler object.
+    #
+    # Examples:
+    #
+    #   I18n.exception_handler = :default_exception_handler             # this is the default
+    #   I18n.default_exception_handler(exception, locale, key, options) # will be called like this
+    #
+    #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
+    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
+    #
+    #  I18n.exception_handler = I18nExceptionHandler.new                # an object
+    #  I18n.exception_handler.call(exception, locale, key, options)     # will be called like this
+    def handle_exception(exception, locale, key, options)
+      case @@exception_handler
+      when Symbol
+        send(@@exception_handler, exception, locale, key, options)
+      else
+        @@exception_handler.call(exception, locale, key, options)
+      end
+    end
+
+    # Merges the given locale, key and scope into a single array of keys.
+    # Splits keys that contain dots into multiple keys. Makes sure all
+    # keys are Symbols.
+    def normalize_translation_keys(locale, key, scope, separator = nil)
+      keys = [locale] + Array(scope) + Array(key)
+      keys = keys.map { |k| k.to_s.split(separator || I18n.default_separator) }
+      keys = keys.flatten - ['']
+      keys.map { |k| k.to_sym }
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend.rb
new file mode 100644
index 0000000..08f2d14
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend.rb
@@ -0,0 +1,17 @@
+module I18n
+  module Backend
+    autoload :ActiveRecord,          'i18n/backend/active_record'
+    autoload :Base,                  'i18n/backend/base'
+    autoload :Cache,                 'i18n/backend/cache'
+    autoload :Cascade,               'i18n/backend/cascade'
+    autoload :Chain,                 'i18n/backend/chain'
+    autoload :Fallbacks,             'i18n/backend/fallbacks'
+    autoload :Fast,                  'i18n/backend/fast'
+    autoload :Gettext,               'i18n/backend/gettext'
+    autoload :Helpers,               'i18n/backend/helpers'
+    autoload :InterpolationCompiler, 'i18n/backend/interpolation_compiler'
+    autoload :Metadata,              'i18n/backend/metadata'
+    autoload :Pluralization,         'i18n/backend/pluralization'
+    autoload :Simple,                'i18n/backend/simple'
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record.rb
new file mode 100644
index 0000000..0e40b0b
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record.rb
@@ -0,0 +1,70 @@
+require 'i18n/backend/base'
+require 'i18n/backend/active_record/translation'
+
+#
+#  This backend reads translations from a Translations table in environment database. Note that the database
+#  will not automatically be prepopulated with missing keys. You can achieve this effect with the ActiveRecordMissing backend, 
+#  as the following example shows:
+#
+#     I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18.backend, I18n::Backend::ActiveRecordMissing.new)
+#
+module I18n
+  module Backend
+    class ActiveRecord
+      autoload :Missing,     'i18n/backend/active_record/missing'
+      autoload :StoreProcs,  'i18n/backend/active_record/store_procs'
+      autoload :Translation, 'i18n/backend/active_record/translation'
+
+      include Base
+
+      def reload!
+      end
+
+      def store_translations(locale, data, options = {})
+        separator = options[:separator] || I18n.default_separator
+        wind_keys(data, separator).each do |key, v|
+          Translation.locale(locale).lookup(expand_keys(key, separator), separator).delete_all
+          Translation.create(:locale => locale.to_s, :key => key.to_s, :value => v)
+        end
+      end
+
+      def available_locales
+        begin
+          Translation.available_locales
+        rescue ::ActiveRecord::StatementInvalid
+          []
+        end
+      end
+
+      protected
+
+        def lookup(locale, key, scope = [], separator = nil)
+          return unless key
+
+          separator ||= I18n.default_separator
+          key = (Array(scope) + Array(key)).join(separator)
+
+          result = Translation.locale(locale).lookup(key, separator).all
+          if result.empty?
+            return nil
+          elsif result.first.key == key
+            return result.first.value
+          else
+            chop_range = (key.size + separator.size)..-1
+            result = result.inject({}) do |hash, r|
+              hash[r.key.slice(chop_range)] = r.value
+              hash
+            end
+            deep_symbolize_keys(unwind_keys(result, separator))
+          end
+        end
+
+        # For a key :'foo.bar.baz' return ['foo', 'foo.bar', 'foo.bar.baz']
+        def expand_keys(key, separator = I18n.default_separator)
+          key.to_s.split(separator).inject([]) do |keys, key|
+            keys << [keys.last, key].compact.join(separator)
+          end
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/missing.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/missing.rb
new file mode 100644
index 0000000..481cd76
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/missing.rb
@@ -0,0 +1,67 @@
+#  This extension stores translation stub records for missing translations to
+#  the database.
+#
+#  This is useful if you have a web based translation tool. It will populate
+#  the database with untranslated keys as the application is being used. A
+#  translator can then go through these and add missing translations.
+#
+#  Example usage:
+#
+#     I18n::Backend::Chain.send(:include, I18n::Backend::ActiveRecord::Missing)
+#     I18n.backend = I18nChainBackend.new(I18n::Backend::ActiveRecord.new, I18n::Backend::Simple.new)
+#
+#  Stub records for pluralizations will also be created for each key defined
+#  in i18n.plural.keys.
+#
+#  For example:
+#
+#    # en.yml
+#    en:
+#      i18n:
+#        plural:
+#          keys: [:zero, :one, :other]
+#
+#    # pl.yml
+#    pl:
+#      i18n:
+#        plural:
+#          keys: [:zero, :one, :few, :other]
+#
+#  It will also persist interpolation keys in Translation#interpolations so
+#  translators will be able to review and use them.
+module I18n
+  module Backend
+    class ActiveRecord
+      module Missing
+        def store_default_translations(locale, key, options = {})
+          count, scope, default, separator = options.values_at(:count, *Base::RESERVED_KEYS)
+          separator ||= I18n.default_separator
+
+          keys = I18n.send(:normalize_translation_keys, locale, key, scope, separator)[1..-1]
+          key = keys.join(separator || I18n.default_separator)
+
+          unless ActiveRecord::Translation.locale(locale).lookup(key, separator).exists?
+            interpolations = options.reject { |name, value| Base::RESERVED_KEYS.include?(name) }.keys
+            keys = count ? I18n.t('i18n.plural.keys', :locale => locale).map { |k| [key, k].join(separator) } : [key]
+            keys.each { |key| store_default_translation(locale, key, interpolations) }
+          end
+        end
+
+        def store_default_translation(locale, key, interpolations)
+          translation = ActiveRecord::Translation.new :locale => locale.to_s, :key => key
+          translation.interpolations = interpolations
+          translation.save
+        end
+
+        def translate(locale, key, options = {})
+          super
+
+          rescue I18n::MissingTranslationData => e
+            self.store_default_translations(locale, key, options)
+
+            raise e
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/store_procs.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/store_procs.rb
new file mode 100644
index 0000000..6e221bf
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/store_procs.rb
@@ -0,0 +1,38 @@
+# This module is intended to be mixed into the ActiveRecord backend to allow
+# storing Ruby Procs as translation values in the database.
+#
+#   I18n.backend = I18n::Backend::ActiveRecord.new
+#   I18n::Backend::ActiveRecord::Translation.send(:include, I18n::Backend::ActiveRecord::StoreProcs)
+#
+# The StoreProcs module requires the ParseTree and ruby2ruby gems and therefor
+# was extracted from the original backend.
+#
+# ParseTree is not compatible with Ruby 1.9.
+
+begin
+  require 'ruby2ruby'
+  require 'parse_tree'
+  require 'parse_tree_extensions'
+rescue LoadError => e
+  puts "can't use StoreProcs because: #{e.message}"
+end
+
+module I18n
+  module Backend
+    class ActiveRecord
+      module StoreProcs
+        def value=(v)
+          case v
+            when Proc
+              write_attribute(:value, v.to_ruby)
+              write_attribute(:is_proc, true)
+            else
+              write_attribute(:value, v)
+          end
+        end
+
+        Translation.send(:include, self) unless RUBY_VERSION >= '1.9'
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/translation.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/translation.rb
new file mode 100644
index 0000000..ffd1083
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/active_record/translation.rb
@@ -0,0 +1,83 @@
+require 'active_record'
+
+module I18n
+  module Backend
+    # ActiveRecord model used to store actual translations to the database.
+    #
+    # This model expects a table like the following to be already set up in
+    # your the database:
+    #
+    #   create_table :translations do |t|
+    #     t.string :locale
+    #     t.string :key
+    #     t.string :value
+    #     t.boolean :is_proc, :default => false
+    #   end
+    #
+    # This model supports to named scopes :locale and :lookup. The :locale
+    # scope simply adds a condition for a given locale:
+    #
+    #   I18n::Backend::ActiveRecord::Translation.locale(:en).all
+    #   # => all translation records that belong to the :en locale
+    #
+    # The :lookup scope adds a condition for looking up all translations
+    # that either start with the given keys (joined by an optionally given
+    # separator or I18n.default_separator) or that exactly have this key.
+    #
+    #   # with translations present for :"foo.bar" and :"foo.baz"
+    #   I18n::Backend::ActiveRecord::Translation.lookup(:foo)
+    #   # => an array with both translation records :"foo.bar" and :"foo.baz"
+    #
+    #   I18n::Backend::ActiveRecord::Translation.lookup([:foo, :bar])
+    #   I18n::Backend::ActiveRecord::Translation.lookup(:"foo.bar")
+    #   # => an array with the translation record :"foo.bar"
+    #
+    # When the StoreProcs module was mixed into this model then Procs will
+    # be stored to the database as Ruby code and evaluated when :value is
+    # called.
+    #
+    #   Translation = I18n::Backend::ActiveRecord::Translation
+    #   Translation.create \
+    #     :locale => 'en'
+    #     :key    => 'foo'
+    #     :value  => lambda { |key, options| 'FOO' }
+    #   Translation.find_by_locale_and_key('en', 'foo').value
+    #   # => 'FOO'
+    class ActiveRecord
+      class Translation < ::ActiveRecord::Base
+        set_table_name 'translations'
+        attr_protected :is_proc, :interpolations
+        
+        serialize :value
+        serialize :interpolations, Array
+
+        named_scope :locale, lambda { |locale|
+          { :conditions => { :locale => locale.to_s } }
+        }
+
+        named_scope :lookup, lambda { |keys, *separator|
+          keys = Array(keys).map! { |key| key.to_s }
+          separator = separator.first || I18n.default_separator
+          { :conditions => ["`key` IN (?) OR `key` LIKE '#{keys.last}#{separator}%'", keys] }
+        }
+
+        def self.available_locales
+          Translation.find(:all, :select => 'DISTINCT locale').map { |t| t.locale.to_sym }
+        end
+        
+        def interpolates?(key)
+          self.interpolations.include?(key) if self.interpolations
+        end
+
+        def value
+          if is_proc
+            Kernel.eval read_attribute(:value)
+          else
+            value = read_attribute(:value)
+            value == 'f' ? false : value
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/base.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/base.rb
new file mode 100644
index 0000000..2de78ae
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/base.rb
@@ -0,0 +1,259 @@
+# encoding: utf-8
+
+require 'yaml'
+
+module I18n
+  module Backend
+    module Base
+      include I18n::Backend::Helpers
+
+      RESERVED_KEYS = [:scope, :default, :separator]
+      INTERPOLATION_SYNTAX_PATTERN = /(\\)?\{\{([^\}]+)\}\}/
+
+      # Accepts a list of paths to translation files. Loads translations from
+      # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
+      # for details.
+      def load_translations(*filenames)
+        filenames.each { |filename| load_file(filename) }
+      end
+
+      # Stores translations for the given locale in memory.
+      # This uses a deep merge for the translations hash, so existing
+      # translations will be overwritten by new ones only at the deepest
+      # level of the hash.
+      def store_translations(locale, data, options = {})
+        merge_translations(locale, data)
+      end
+
+      def translate(locale, key, options = {})
+        raise InvalidLocale.new(locale) unless locale
+        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
+
+        if options.empty?
+          entry = resolve(locale, key, lookup(locale, key), options)
+          raise(I18n::MissingTranslationData.new(locale, key, options)) if entry.nil?
+        else
+          count, scope, default, separator = options.values_at(:count, :scope, :default, :separator)
+          values = options.reject { |name, value| RESERVED_KEYS.include?(name) }
+
+          entry = lookup(locale, key, scope, separator)
+          entry = entry.nil? && default ? default(locale, key, default, options) : resolve(locale, key, entry, options)
+          raise(I18n::MissingTranslationData.new(locale, key, options)) if entry.nil?
+
+          entry = pluralize(locale, entry, count)    if count
+          entry = interpolate(locale, entry, values) if values
+        end
+
+        entry
+      end
+
+      # Acts the same as +strftime+, but uses a localized version of the
+      # format string. Takes a key from the date/time formats translations as
+      # a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
+      def localize(locale, object, format = :default, options = {})
+        raise ArgumentError, "Object must be a Date, DateTime or Time object. #{object.inspect} given." unless object.respond_to?(:strftime)
+
+        if Symbol === format
+          key = format
+          type = object.respond_to?(:sec) ? 'time' : 'date'
+          format = lookup(locale, :"#{type}.formats.#{key}")
+          raise(MissingTranslationData.new(locale, key, options)) if format.nil?
+        end
+
+        format = resolve(locale, object, format, options)
+        format = format.to_s.gsub(/%[aAbBp]/) do |match|
+          case match
+          when '%a' then I18n.t(:"date.abbr_day_names",                  :locale => locale, :format => format)[object.wday]
+          when '%A' then I18n.t(:"date.day_names",                       :locale => locale, :format => format)[object.wday]
+          when '%b' then I18n.t(:"date.abbr_month_names",                :locale => locale, :format => format)[object.mon]
+          when '%B' then I18n.t(:"date.month_names",                     :locale => locale, :format => format)[object.mon]
+          when '%p' then I18n.t(:"time.#{object.hour < 12 ? :am : :pm}", :locale => locale, :format => format) if object.respond_to? :hour
+          end
+        end
+
+        object.strftime(format)
+      end
+
+      def initialized?
+        @initialized ||= false
+      end
+
+      # Returns an array of locales for which translations are available
+      # ignoring the reserved translation meta data key :i18n.
+      def available_locales
+        init_translations unless initialized?
+        translations.inject([]) do |locales, (locale, data)|
+          locales << locale unless (data.keys - [:i18n]).empty?
+          locales
+        end
+      end
+
+      def reload!
+        @initialized = false
+        @translations = nil
+      end
+
+      protected
+        def init_translations
+          load_translations(*I18n.load_path.flatten)
+          @initialized = true
+        end
+
+        def translations
+          @translations ||= {}
+        end
+
+        # Looks up a translation from the translations hash. Returns nil if
+        # eiher key is nil, or locale, scope or key do not exist as a key in the
+        # nested translations hash. Splits keys or scopes containing dots
+        # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
+        # <tt>%w(currency format)</tt>.
+        def lookup(locale, key, scope = [], separator = nil)
+          return unless key
+          init_translations unless initialized?
+          keys = I18n.send(:normalize_translation_keys, locale, key, scope, separator)
+          keys.inject(translations) do |result, key|
+            key = key.to_sym
+            return nil unless result.is_a?(Hash) && result.has_key?(key)
+            result = result[key]
+            result = resolve(locale, key, result, :separator => separator) if result.is_a?(Symbol)
+            result
+          end
+        end
+
+        # Evaluates defaults.
+        # If given subject is an Array, it walks the array and returns the
+        # first translation that can be resolved. Otherwise it tries to resolve
+        # the translation directly.
+        def default(locale, object, subject, options = {})
+          options = options.dup.reject { |key, value| key == :default }
+          case subject
+          when Array
+            subject.each do |item|
+              result = resolve(locale, object, item, options) and return result
+            end and nil
+          else
+            resolve(locale, object, subject, options)
+          end
+        end
+
+        # Resolves a translation.
+        # If the given subject is a Symbol, it will be translated with the
+        # given options. If it is a Proc then it will be evaluated. All other
+        # subjects will be returned directly.
+        def resolve(locale, object, subject, options = nil)
+          case subject
+          when Symbol
+            I18n.translate(subject, (options || {}).merge(:locale => locale, :raise => true))
+          when Proc
+            resolve(locale, object, subject.call(object, options), options = {})
+          else
+            subject
+          end
+        rescue MissingTranslationData
+          nil
+        end
+
+        # Picks a translation from an array according to English pluralization
+        # rules. It will pick the first translation if count is not equal to 1
+        # and the second translation if it is equal to 1. Other backends can
+        # implement more flexible or complex pluralization rules.
+        def pluralize(locale, entry, count)
+          return entry unless entry.is_a?(Hash) and count
+
+          key = :zero if count == 0 && entry.has_key?(:zero)
+          key ||= count == 1 ? :one : :other
+          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
+          entry[key]
+        end
+
+        # Interpolates values into a given string.
+        #
+        #   interpolate "file {{file}} opened by \\{{user}}", :file => 'test.txt', :user => 'Mr. X'
+        #   # => "file test.txt opened by {{user}}"
+        #
+        # Note that you have to double escape the <tt>\\</tt> when you want to escape
+        # the <tt>{{...}}</tt> key in a string (once for the string and once for the
+        # interpolation).
+        def interpolate(locale, string, values = {})
+          return string unless string.is_a?(String) && !values.empty?
+
+          preserve_encoding(string) do
+            s = string.gsub(INTERPOLATION_SYNTAX_PATTERN) do
+              escaped, key = $1, $2.to_sym
+              if escaped
+                "{{#{key}}}"
+              elsif RESERVED_KEYS.include?(key)
+                raise ReservedInterpolationKey.new(key, string)
+              else
+                "%{#{key}}"
+              end
+            end
+
+            values.each do |key, value|
+              value = value.call(values) if interpolate_lambda?(value, s, key)
+              value = value.to_s unless value.is_a?(String)
+              values[key] = value
+            end
+
+            s % values
+          end
+
+        rescue KeyError => e
+          raise MissingInterpolationArgument.new(values, string)
+        end
+
+        def preserve_encoding(string)
+          if string.respond_to?(:encoding)
+            encoding = string.encoding
+            result = yield
+            result.force_encoding(encoding) if result.respond_to?(:force_encoding)
+            result
+          else
+            yield
+          end
+        end
+
+        # returns true when the given value responds to :call and the key is
+        # an interpolation placeholder in the given string
+        def interpolate_lambda?(object, string, key)
+          object.respond_to?(:call) && string =~ /%\{#{key}\}|%\<#{key}>.*?\d*\.?\d*[bBdiouxXeEfgGcps]\}/
+        end
+
+        # Loads a single translations file by delegating to #load_rb or
+        # #load_yml depending on the file extension and directly merges the
+        # data to the existing translations. Raises I18n::UnknownFileType
+        # for all other file extensions.
+        def load_file(filename)
+          type = File.extname(filename).tr('.', '').downcase
+          raise UnknownFileType.new(type, filename) unless respond_to?(:"load_#{type}")
+          data = send :"load_#{type}", filename # TODO raise a meaningful exception if this does not yield a Hash
+          data.each { |locale, d| merge_translations(locale, d) }
+        end
+
+        # Loads a plain Ruby translations file. eval'ing the file must yield
+        # a Hash containing translation data with locales as toplevel keys.
+        def load_rb(filename)
+          eval(IO.read(filename), binding, filename)
+        end
+
+        # Loads a YAML translations file. The data must have locales as
+        # toplevel keys.
+        def load_yml(filename)
+          YAML::load(IO.read(filename))
+        end
+
+        # Deep merges the given translations hash with the existing translations
+        # for the given locale
+        def merge_translations(locale, data)
+          locale = locale.to_sym
+          translations[locale] ||= {}
+          data = deep_symbolize_keys(data)
+
+          # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
+          merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
+          translations[locale].merge!(data, &merger)
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cache.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cache.rb
new file mode 100644
index 0000000..65ecebe
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cache.rb
@@ -0,0 +1,75 @@
+# encoding: utf-8
+
+# This module allows you to easily cache all responses from the backend - thus
+# speeding up the I18n aspects of your application quite a bit.
+#
+# To enable caching you can simply include the Cache module to the Simple
+# backend - or whatever other backend you are using:
+#
+#  I18n::Backend::Simple.send(:include, I18n::Backend::Cache)
+#
+# You will also need to set a cache store implementation that you want to use:
+#
+#  I18n.cache_store = ActiveSupport::Cache.lookup_store(:memory_store)
+#
+# You can use any cache implementation you want that provides the same API as
+# ActiveSupport::Cache (only the methods #fetch and #write are being used).
+#
+# The cache_key implementation assumes that you only pass values to
+# I18n.translate that return a valid key from #hash (see
+# http://www.ruby-doc.org/core/classes/Object.html#M000337).
+module I18n
+  class << self
+    @@cache_store = nil
+    @@cache_namespace = nil
+
+    def cache_store
+      @@cache_store
+    end
+
+    def cache_store=(store)
+      @@cache_store = store
+    end
+
+    def cache_namespace
+      @@cache_namespace
+    end
+
+    def cache_namespace=(namespace)
+      @@cache_namespace = namespace
+    end
+
+    def perform_caching?
+      !cache_store.nil?
+    end
+  end
+
+  module Backend
+    module Cache
+      def translate(*args)
+        I18n.perform_caching? ? fetch(*args) { super } : super
+      end
+
+      protected
+
+        def fetch(*args, &block)
+          result = I18n.cache_store.fetch(cache_key(*args), &block)
+          raise result if result.is_a?(Exception)
+          result
+        rescue MissingTranslationData => exception
+          I18n.cache_store.write(cache_key(*args), exception)
+          raise exception
+        end
+
+        def cache_key(*args)
+          # This assumes that only simple, native Ruby values are passed to I18n.translate.
+          # Also, in Ruby < 1.8.7 {}.hash != {}.hash
+          # (see http://paulbarry.com/articles/2009/09/14/why-rails-3-will-require-ruby-1-8-7)
+          # If args.inspect does not work for you for some reason, patches are very welcome :)
+          hash = RUBY_VERSION >= "1.8.7" ? args.hash : args.inspect
+          keys = ['i18n', I18n.cache_namespace, hash]
+          keys.compact.join('-')
+        end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cascade.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cascade.rb
new file mode 100644
index 0000000..edca8fc
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/cascade.rb
@@ -0,0 +1,44 @@
+# encoding: utf-8
+
+# EXPERIMENTAL
+#
+# The cascade module adds the ability to do cascading lookups to backends that
+# are compatible to the Simple backend.
+#
+# By cascading lookups we mean that for any key that can not be found the
+# Cascade module strips one segment off the scope part of the key and then
+# tries to look up the key in that scope.
+#
+# E.g. when a lookup for the key :"foo.bar.baz" does not yield a result then
+# the segment :bar will be stripped off the scope part :"foo.bar" and the new
+# scope :foo will be used to look up the key :baz. If that does not succeed
+# then the remaining scope segment :foo will be omitted, too, and again the
+# key :baz will be looked up (now with no scope).
+#
+# Defaults will only kick in after the cascading lookups haven't succeeded.
+#
+# This behavior is useful for libraries like ActiveRecord validations where
+# the library wants to give users a bunch of more or less fine-grained options
+# of scopes for a particular key.
+#
+# Thanks to Clemens Kofler for the initial idea and implementation! See
+# http://github.com/clemens/i18n-cascading-backend
+
+module I18n
+  @@fallbacks = nil
+
+  module Backend
+    module Cascade
+      def lookup(locale, key, scope = [], separator = nil)
+        return unless key
+        locale, *scope = I18n.send(:normalize_translation_keys, locale, key, scope, separator)
+        key = scope.pop
+
+        begin
+          result = super
+          return result unless result.nil?
+        end while scope.pop
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/chain.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/chain.rb
new file mode 100644
index 0000000..aef5d86
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/chain.rb
@@ -0,0 +1,74 @@
+# encoding: utf-8
+
+module I18n
+  module Backend
+    # Backend that chains multiple other backends and checks each of them when
+    # a translation needs to be looked up. This is useful when you want to use
+    # standard translations with a Simple backend but store custom application
+    # translations in a database or other backends.
+    #
+    # To use the Chain backend instantiate it and set it to the I18n module.
+    # You can add chained backends through the initializer or backends
+    # accessor:
+    #
+    #   # preserves the existing Simple backend set to I18n.backend
+    #   I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
+    #
+    # The implementation assumes that all backends added to the Chain implement
+    # a lookup method with the same API as Simple backend does.
+    class Chain < Simple
+      attr_accessor :backends
+
+      def initialize(*backends)
+        self.backends = backends
+      end
+
+      def reload!
+        backends.each { |backend| backend.reload! }
+      end
+
+      def store_translations(locale, data, options = {})
+        backends.first.store_translations(locale, data, options = {})
+      end
+
+      def available_locales
+        backends.map { |backend| backend.available_locales }.flatten.uniq
+      end
+
+      def translate(locale, key, options = {})
+        return key.map { |k| translate(locale, k, options) } if key.is_a?(Array)
+
+        default = options.delete(:default)
+        namespace = {}
+        backends.each do |backend|
+          begin
+            options.update(:default => default) if default and backend == backends.last
+            translation = backend.translate(locale, key, options)
+            if namespace_lookup?(translation, options)
+              namespace.update(translation)
+            elsif !translation.nil?
+              return translation
+            end
+          rescue MissingTranslationData
+          end
+        end
+        return namespace unless namespace.empty?
+        raise(I18n::MissingTranslationData.new(locale, key, options))
+      end
+
+      def localize(locale, object, format = :default, options = {})
+        backends.each do |backend|
+          begin
+            result = backend.localize(locale, object, format, options) and return result
+          rescue MissingTranslationData
+          end
+        end and nil
+      end
+
+      protected
+        def namespace_lookup?(result, options)
+          result.is_a?(Hash) and not options.has_key?(:count)
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fallbacks.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fallbacks.rb
new file mode 100644
index 0000000..774ecfa
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fallbacks.rb
@@ -0,0 +1,52 @@
+# encoding: utf-8
+
+# I18n locale fallbacks are useful when you want your application to use
+# translations from other locales when translations for the current locale are
+# missing. E.g. you might want to use :en translations when translations in
+# your applications main locale :de are missing.
+#
+# To enable locale fallbacks you can simply include the Fallbacks module to
+# the Simple backend - or whatever other backend you are using:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Fallbacks)
+module I18n
+  @@fallbacks = nil
+
+  class << self
+    # Returns the current fallbacks implementation. Defaults to +I18n::Locale::Fallbacks+.
+    def fallbacks
+      @@fallbacks ||= I18n::Locale::Fallbacks.new
+    end
+
+    # Sets the current fallbacks implementation. Use this to set a different fallbacks implementation.
+    def fallbacks=(fallbacks)
+      @@fallbacks = fallbacks
+    end
+  end
+
+  module Backend
+    module Fallbacks
+      # Overwrites the Base backend translate method so that it will try each
+      # locale given by I18n.fallbacks for the given locale. E.g. for the
+      # locale :"de-DE" it might try the locales :"de-DE", :de and :en
+      # (depends on the fallbacks implementation) until it finds a result with
+      # the given options. If it does not find any result for any of the
+      # locales it will then raise a MissingTranslationData exception as
+      # usual.
+      #
+      # The default option takes precedence over fallback locales, i.e. it
+      # will first evaluate a given default option before falling back to
+      # another locale.
+      def translate(locale, key, options = {})
+        I18n.fallbacks[locale].each do |fallback|
+          begin
+            result = super(fallback, key, options)
+            return result unless result.nil?
+          rescue I18n::MissingTranslationData
+          end
+        end
+        raise(I18n::MissingTranslationData.new(locale, key, options))
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fast.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fast.rb
new file mode 100644
index 0000000..4a33a6e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/fast.rb
@@ -0,0 +1,68 @@
+# encoding: utf-8
+
+# The Fast module contains optimizations that can tremendously speed up the
+# lookup process on the Simple backend. It works by flattening the nested
+# translation hash to a flat hash (e.g. { :a => { :b => 'c' } } becomes
+# { :'a.b' => 'c' }).
+#
+# To enable these optimizations you can simply include the Fast module to
+# the Simple backend:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Fast)
+module I18n
+  module Backend
+    module Fast
+      SEPARATOR_ESCAPE_CHAR = "\001"
+
+      def reset_flattened_translations!
+        @flattened_translations = nil
+      end
+
+      def flattened_translations
+        @flattened_translations ||= flatten_translations(translations)
+      end
+
+      def merge_translations(locale, data)
+        super
+        reset_flattened_translations!
+      end
+
+      def init_translations
+        super
+        reset_flattened_translations!
+      end
+
+      protected
+        # flatten_hash({:a=>'a', :b=>{:c=>'c', :d=>'d', :f=>{:x=>'x'}}})
+        # # => {:a=>'a', :b=>{:c=>'c', :d=>'d', :f=>{:x=>'x'}}, :"b.f" => {:x=>"x"}, :"b.c"=>"c", :"b.f.x"=>"x", :"b.d"=>"d"}
+        def flatten_hash(h, nested_stack = [], flattened_h = {}, orig_h=h)
+          wind_keys(h, nil, true)
+        end
+
+        def flatten_translations(translations)
+          # don't flatten locale roots
+          translations.inject({}) do |flattened_h, (locale_name, locale_translations)|
+            flattened_h[locale_name] = flatten_hash(locale_translations)
+            flattened_h
+          end
+        end
+
+        def lookup(locale, key, scope = nil, separator = nil)
+          return unless key
+          init_translations unless initialized?
+
+          if separator && I18n.default_separator != separator
+            key   = cleanup_non_standard_separator(key, separator)
+            scope = Array(scope).map{|k| cleanup_non_standard_separator(k, separator)} if scope
+          end
+
+          key = (Array(scope) + [key]).join(I18n.default_separator) if scope
+          flattened_translations[locale.to_sym][key.to_sym]
+        end
+
+        def cleanup_non_standard_separator(key, user_separator)
+          escape_default_separator(key).tr(user_separator, I18n.default_separator)
+        end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/gettext.rb
new file mode 100644
index 0000000..c2b81b2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/gettext.rb
@@ -0,0 +1,75 @@
+# encoding: utf-8
+
+require 'i18n/gettext'
+require File.expand_path(File.dirname(__FILE__) + '/../../../vendor/po_parser.rb')
+
+# Experimental support for using Gettext po files to store translations.
+#
+# To use this you can simply include the module to the Simple backend - or
+# whatever other backend you are using.
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Gettext)
+#
+# Now you should be able to include your Gettext translation (*.po) files to
+# the I18n.load_path so they're loaded to the backend and you can use them as
+# usual:
+#
+#  I18n.load_path += Dir["path/to/locales/*.po"]
+#
+# Following the Gettext convention this implementation expects that your
+# translation files are named by their locales. E.g. the file en.po would
+# contain the translations for the English locale.
+module I18n
+  module Backend
+    module Gettext
+      class PoData < Hash
+        def set_comment(msgid_or_sym, comment)
+          # ignore
+        end
+      end
+
+      protected
+        def load_po(filename)
+          locale = ::File.basename(filename, '.po').to_sym
+          data = normalize(locale, parse(filename))
+          { locale => data }
+        end
+
+        def parse(filename)
+          GetText::PoParser.new.parse(::File.read(filename), PoData.new)
+        end
+
+        def normalize(locale, data)
+          data.inject({}) do |result, (key, value)|
+            unless key.nil? || key.empty?
+              key, value = normalize_pluralization(locale, key, value) if key.index("\000")
+
+              parts = key.split('|').reverse
+              normalized = parts.inject({}) do |normalized, part|
+                normalized = { part => normalized.empty? ? value : normalized }
+              end
+
+              # deep_merge by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
+              merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
+              result.merge!(normalized, &merger)
+            end
+            result
+          end
+        end
+
+        def normalize_pluralization(locale, key, value)
+          # FIXME po_parser includes \000 chars that can not be turned into Symbols
+          key = key.gsub("\000", I18n::Gettext::PLURAL_SEPARATOR).split(I18n::Gettext::PLURAL_SEPARATOR).first
+
+          keys = I18n::Gettext.plural_keys(locale)
+          values = value.split("\000")
+          raise "invalid number of plurals: #{values.size}, keys: #{keys.inspect}" if values.size != keys.size
+
+          result = {}
+          values.each_with_index { |value, ix| result[keys[ix]] = value }
+          [key, result]
+        end
+
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/helpers.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/helpers.rb
new file mode 100644
index 0000000..eee2b73
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/helpers.rb
@@ -0,0 +1,80 @@
+module I18n
+  module Backend
+    module Helpers
+      SEPARATOR_ESCAPE_CHAR = "\001"
+
+      # Return a new hash with all keys and nested keys converted to symbols.
+      def deep_symbolize_keys(hash)
+        hash.inject({}) { |result, (key, value)|
+          value = deep_symbolize_keys(value) if value.is_a?(Hash)
+          result[(key.to_sym rescue key) || key] = value
+          result
+        }
+      end
+
+      # Flatten keys for nested Hashes by chaining up keys using the separator
+      #   >> { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}.wind
+      #   => { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }
+      def wind_keys(hash, separator = nil, subtree = false, prev_key = nil, result = {}, orig_hash=hash)
+        separator ||= I18n.default_separator
+
+        hash.each_pair do |key, value|
+          key = escape_default_separator(key, separator)
+          curr_key = [prev_key, key].compact.join(separator).to_sym
+
+          if value.is_a?(Symbol)
+            value = hash_lookup(orig_hash, value, separator) ||
+                    hash_lookup(hash, value, separator) || value
+          end
+
+          if value.is_a?(Hash)
+            result[curr_key] = value if subtree
+            wind_keys(value, separator, subtree, curr_key, result, orig_hash)
+          else
+            result[curr_key] = value
+          end
+        end
+
+        result
+      end
+
+      def escape_default_separator(key, separator=nil)
+        key.to_s.tr(separator || I18n.default_separator, SEPARATOR_ESCAPE_CHAR)
+      end
+
+      def hash_lookup(hash, keys, separator = ".")
+        keys.to_s.split(separator).inject(hash) do |result, key|
+          key = key.to_sym
+          if result.respond_to?(:has_key?) and result.has_key?(key)
+            result[key]
+          else
+            return nil
+          end
+        end
+      end
+
+      # Expand keys chained by the the given separator through nested Hashes
+      #   >> { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }.unwind
+      #   => { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}
+      def unwind_keys(hash, separator = ".")
+        result = {}
+        hash.each do |key, value|
+          keys = key.to_s.split(separator)
+          curr = result
+          curr = curr[keys.shift] ||= {} while keys.size > 1
+          curr[keys.shift] = value
+        end
+        result
+      end
+
+      # # Flatten the given array once
+      # def flatten_once(array)
+      #   result = []
+      #   for element in array # a little faster than each
+      #     result.push(*element)
+      #   end
+      #   result
+      # end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/interpolation_compiler.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/interpolation_compiler.rb
new file mode 100644
index 0000000..6a14150
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/interpolation_compiler.rb
@@ -0,0 +1,119 @@
+# encoding: utf-8
+
+# The InterpolationCompiler module contains optimizations that can tremendously
+# speed up the interpolation process on the Simple backend.
+#
+# It works by defining a pre-compiled method on stored translation Strings that
+# already bring all the knowledge about contained interpolation variables etc.
+# so that the actual recurring interpolation will be very fast.
+#
+# To enable pre-compiled interpolations you can simply include the
+# InterpolationCompiler module to the Simple backend:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::InterpolationCompiler)
+module I18n
+  module Backend
+    module InterpolationCompiler
+      module Compiler
+        extend self
+
+        TOKENIZER                    = /(\\\{\{[^\}]+\}\}|\{\{[^\}]+\}\})/
+        INTERPOLATION_SYNTAX_PATTERN = /(\\)?(\{\{([^\}]+)\}\})/
+
+        def compile_if_an_interpolation(string)
+          if interpolated_str?(string)
+            string.instance_eval <<-RUBY_EVAL, __FILE__, __LINE__
+              def i18n_interpolate(v = {})
+                "#{compiled_interpolation_body(string)}"
+              end
+            RUBY_EVAL
+          end
+
+          string
+        end
+
+        def interpolated_str?(str)
+          str.kind_of?(String) && str =~ INTERPOLATION_SYNTAX_PATTERN
+        end
+
+        protected
+        # tokenize("foo {{bar}} baz \\{{buz}}") # => ["foo ", "{{bar}}", " baz ", "\\{{buz}}"]
+        def tokenize(str)
+          str.split(TOKENIZER)
+        end
+
+        def compiled_interpolation_body(str)
+          tokenize(str).map do |token|
+            (matchdata = token.match(INTERPOLATION_SYNTAX_PATTERN)) ? handle_interpolation_token(token, matchdata) : escape_plain_str(token)
+          end.join
+        end
+
+        def handle_interpolation_token(interpolation, matchdata)
+          escaped, pattern, key = matchdata.values_at(1, 2, 3)
+          escaped ? pattern : compile_interpolation_token(key.to_sym)
+        end
+
+        def compile_interpolation_token(key)
+          "\#{#{interpolate_or_raise_missing(key)}}"
+        end
+
+        def interpolate_or_raise_missing(key)
+          escaped_key = escape_key_sym(key)
+          Base::RESERVED_KEYS.include?(key) ? reserved_key(escaped_key) : interpolate_key(escaped_key)
+        end
+
+        def interpolate_key(key)
+          [direct_key(key), nil_key(key), missing_key(key)].join('||')
+        end
+
+        def direct_key(key)
+          "((t = v[#{key}]) && t.respond_to?(:call) ? t.call : t)"
+        end
+
+        def nil_key(key)
+          "(v.has_key?(#{key}) && '')"
+        end
+
+        def missing_key(key)
+          "raise(MissingInterpolationArgument.new(#{key}, self))"
+        end
+
+        def reserved_key(key)
+          "raise(ReservedInterpolationKey.new(#{key}, self))"
+        end
+
+        def escape_plain_str(str)
+          str.gsub(/"|\\|#/) {|x| "\\#{x}"}
+        end
+
+        def escape_key_sym(key)
+          # rely on Ruby to do all the hard work :)
+          key.to_sym.inspect
+        end
+      end
+
+      def interpolate(locale, string, values)
+        if string.respond_to?(:i18n_interpolate)
+          string.i18n_interpolate(values)
+        elsif values
+          super
+        else
+          string
+        end
+      end
+
+      def merge_translations(locale, data)
+        compile_all_strings_in(data)
+        super
+      end
+
+      protected
+      def compile_all_strings_in(data)
+        data.each_value do |value|
+          Compiler.compile_if_an_interpolation(value)
+          compile_all_strings_in(value) if value.kind_of?(Hash)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/metadata.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/metadata.rb
new file mode 100644
index 0000000..3ebb8af
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/metadata.rb
@@ -0,0 +1,73 @@
+# I18n translation metadata is useful when you want to access information
+# about how a translation was looked up, pluralized or interpolated in
+# your application.
+#
+#   msg = I18n.t(:message, :default => 'Hi!', :scope => :foo)
+#   msg.translation_metadata
+#   # => { :key => :message, :scope => :foo, :default => 'Hi!' }
+#
+# If a :count option was passed to #translate it will be set to the metadata.
+# Likewise, if any interpolation variables were passed they will also be set.
+#
+# To enable translation metadata you can simply include the Metadata module
+# into the Simple backend class - or whatever other backend you are using:
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Metadata)
+
+require 'i18n/core_ext/object/meta_class'
+
+module I18n
+  module Backend
+    module Metadata
+      class << self
+        def included(base)
+          Object.class_eval do
+            def translation_metadata
+              @translation_metadata ||= {}
+            end
+
+            def translation_metadata=(translation_metadata)
+              @translation_metadata = translation_metadata
+            end
+          end
+        end
+      end
+
+      def translate(locale, key, options = {})
+        metadata = {
+          :locale    => locale,
+          :key       => key,
+          :scope     => options[:scope],
+          :default   => options[:default],
+          :separator => options[:separator],
+          :values    => options.reject { |name, value| Base::RESERVED_KEYS.include?(name) }
+        }
+        with_metadata(metadata) { super }
+      end
+
+      def interpolate(locale, string, values = {})
+        with_metadata(:original => string) do
+          preserve_translation_metadata(string) { super }
+        end if string
+      end
+
+      def pluralize(locale, entry, count)
+        with_metadata(:count => count) { super }
+      end
+
+      protected
+
+        def with_metadata(metadata, &block)
+          result = yield
+          result.translation_metadata = result.translation_metadata.merge(metadata) if result
+          result
+        end
+
+        def preserve_translation_metadata(object, &block)
+          result = yield
+          result.translation_metadata = object.translation_metadata if result
+          result
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/pluralization.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/pluralization.rb
new file mode 100644
index 0000000..f9ad94e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/pluralization.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+
+# I18n locale fallbacks are useful when you want your application to use
+# translations from other locales when translations for the current locale are
+# missing. E.g. you might want to use :en translations when translations in
+# your applications main locale :de are missing.
+#
+# To enable locale specific pluralizations you can simply include the
+# Pluralization module to the Simple backend - or whatever other backend you
+# are using.
+#
+#   I18n::Backend::Simple.send(:include, I18n::Backend::Pluralization)
+#
+# You also need to make sure to provide pluralization algorithms to the
+# backend, i.e. include them to your I18n.load_path accordingly.
+module I18n
+  module Backend
+    module Pluralization
+      # Overwrites the Base backend translate method so that it will check the
+      # translation meta data space (:i18n) for a locale specific pluralization
+      # rule and use it to pluralize the given entry. I.e. the library expects
+      # pluralization rules to be stored at I18n.t(:'i18n.plural.rule')
+      #
+      # Pluralization rules are expected to respond to #call(entry, count) and
+      # return a pluralization key. Valid keys depend on the translation data
+      # hash (entry) but it is generally recommended to follow CLDR's style,
+      # i.e., return one of the keys :zero, :one, :few, :many, :other.
+      #
+      # The :zero key is always picked directly when count equals 0 AND the
+      # translation data has the key :zero. This way translators are free to
+      # either pick a special :zero translation even for languages where the
+      # pluralizer does not return a :zero key.
+      def pluralize(locale, entry, count)
+        return entry unless entry.is_a?(Hash) and count
+
+        pluralizer = pluralizer(locale)
+        if pluralizer.respond_to?(:call)
+          key = count == 0 && entry.has_key?(:zero) ? :zero : pluralizer.call(count)
+          raise InvalidPluralizationData.new(entry, count) unless entry.has_key?(key)
+          entry[key]
+        else
+          super
+        end
+      end
+
+      protected
+
+        def pluralizers
+          @pluralizers ||= {}
+        end
+
+        def pluralizer(locale)
+          pluralizers[locale] ||= lookup(locale, :'i18n.plural.rule')
+        end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/simple.rb
new file mode 100644
index 0000000..1454a10
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/backend/simple.rb
@@ -0,0 +1,22 @@
+# encoding: utf-8
+
+# Stub class for the Simple backend. The actual implementation is provided by
+# the backend Base class. This makes it easier to extend the Simple backend's
+# behaviour by including modules. E.g.:
+#
+# module I18n::Backend::Pluralization
+#   def pluralize(*args)
+#     # extended pluralization logic
+#     super
+#   end
+# end
+#
+# I18n::Backend::Simple.send(:include, I18n::Backend::Pluralization)
+
+module I18n
+  module Backend
+    class Simple
+      include Base
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/object/meta_class.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/object/meta_class.rb
new file mode 100644
index 0000000..e6d51f7
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/object/meta_class.rb
@@ -0,0 +1,5 @@
+Object.class_eval do
+  def meta_class
+    class << self; self; end
+  end
+end unless Object.method_defined?(:meta_class)
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/string/interpolate.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/string/interpolate.rb
new file mode 100644
index 0000000..dbcd619
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/core_ext/string/interpolate.rb
@@ -0,0 +1,95 @@
+# encoding: utf-8
+
+=begin
+  heavily based on Masao Mutoh's gettext String interpolation extension
+  http://github.com/mutoh/gettext/blob/f6566738b981fe0952548c421042ad1e0cdfb31e/lib/gettext/core_ext/string.rb
+  Copyright (C) 2005-2009 Masao Mutoh
+  You may redistribute it and/or modify it under the same license terms as Ruby.
+=end
+
+if RUBY_VERSION < '1.9'
+
+  # KeyError is raised by String#% when the string contains a named placeholder
+  # that is not contained in the given arguments hash. Ruby 1.9 includes and
+  # raises this exception natively. We define it to mimic Ruby 1.9's behaviour
+  # in Ruby 1.8.x
+
+  class KeyError < IndexError
+    def initialize(message = nil)
+      super(message || "key not found")
+    end
+  end unless defined?(KeyError)
+
+  # Extension for String class. This feature is included in Ruby 1.9 or later but not occur TypeError.
+  #
+  # String#% method which accept "named argument". The translator can know
+  # the meaning of the msgids using "named argument" instead of %s/%d style.
+
+  class String
+    # For older ruby versions, such as ruby-1.8.5
+    alias :bytesize :size unless instance_methods.find {|m| m.to_s == 'bytesize'}
+    alias :interpolate_without_ruby_19_syntax :% # :nodoc:
+
+    INTERPOLATION_PATTERN = Regexp.union(
+      /%%/,
+      /%\{(\w+)\}/,                               # matches placeholders like "%{foo}"
+      /%<(\w+)>(.*?\d*\.?\d*[bBdiouxXeEfgGcps])/  # matches placeholders like "%<foo>.d"
+    )
+
+    # % uses self (i.e. the String) as a format specification and returns the
+    # result of applying it to the given arguments. In other words it interpolates
+    # the given arguments to the string according to the formats the string
+    # defines.
+    #
+    # There are three ways to use it:
+    #
+    # * Using a single argument or Array of arguments.
+    #
+    #   This is the default behaviour of the String class. See Kernel#sprintf for
+    #   more details about the format string.
+    #
+    #   Example:
+    #
+    #     "%d %s" % [1, "message"]
+    #     # => "1 message"
+    #
+    # * Using a Hash as an argument and unformatted, named placeholders.
+    #
+    #   When you pass a Hash as an argument and specify placeholders with %{foo}
+    #   it will interpret the hash values as named arguments.
+    #
+    #   Example:
+    #
+    #     "%{firstname}, %{lastname}" % {:firstname => "Masao", :lastname => "Mutoh"}
+    #     # => "Masao Mutoh"
+    #
+    # * Using a Hash as an argument and formatted, named placeholders.
+    #
+    #   When you pass a Hash as an argument and specify placeholders with %<foo>d
+    #   it will interpret the hash values as named arguments and format the value
+    #   according to the formatting instruction appended to the closing >.
+    #
+    #   Example:
+    #
+    #     "%<integer>d, %<float>.1f" % { :integer => 10, :float => 43.4 }
+    #     # => "10, 43.3"
+    def %(args)
+      if args.kind_of?(Hash)
+        dup.gsub(INTERPOLATION_PATTERN) do |match|
+          if match == '%%'
+            '%'
+          else
+            key = ($1 || $2).to_sym
+            raise KeyError unless args.has_key?(key)
+            $3 ? sprintf("%#{$3}", args[key]) : args[key]
+          end
+        end
+      elsif self =~ INTERPOLATION_PATTERN
+        raise ArgumentError.new('one hash required')
+      else
+        result = gsub(/%([{<])/, '%%\1')
+        result.send :'interpolate_without_ruby_19_syntax', args
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/exceptions.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/exceptions.rb
new file mode 100644
index 0000000..79996a1
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/exceptions.rb
@@ -0,0 +1,61 @@
+# encoding: utf-8
+
+class KeyError < IndexError
+  def initialize(message = nil)
+    super(message || "key not found")
+  end
+end unless defined?(KeyError)
+
+module I18n
+  class ArgumentError < ::ArgumentError; end
+
+  class InvalidLocale < ArgumentError
+    attr_reader :locale
+    def initialize(locale)
+      @locale = locale
+      super "#{locale.inspect} is not a valid locale"
+    end
+  end
+
+  class MissingTranslationData < ArgumentError
+    attr_reader :locale, :key, :options
+    def initialize(locale, key, opts = nil)
+      @key, @locale, @options = key, locale, opts || {}
+      keys = I18n.send(:normalize_translation_keys, locale, key, options[:scope])
+      keys << 'no key' if keys.size < 2
+      super "translation missing: #{keys.join(', ')}"
+    end
+  end
+
+  class InvalidPluralizationData < ArgumentError
+    attr_reader :entry, :count
+    def initialize(entry, count)
+      @entry, @count = entry, count
+      super "translation data #{entry.inspect} can not be used with :count => #{count}"
+    end
+  end
+
+  class MissingInterpolationArgument < ArgumentError
+    attr_reader :values, :string
+    def initialize(values, string)
+      @values, @string = values, string
+      super "missing interpolation argument in #{string.inspect} (#{values.inspect} given)"
+    end
+  end
+
+  class ReservedInterpolationKey < ArgumentError
+    attr_reader :key, :string
+    def initialize(key, string)
+      @key, @string = key, string
+      super "reserved key #{key.inspect} used in #{string.inspect}"
+    end
+  end
+
+  class UnknownFileType < ArgumentError
+    attr_reader :type, :filename
+    def initialize(type, filename)
+      @type, @filename = type, filename
+      super "can not load translations from #{filename}, the file type #{type} is not known"
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/gettext.rb
new file mode 100644
index 0000000..b8dec6e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/gettext.rb
@@ -0,0 +1,25 @@
+# encoding: utf-8
+
+module I18n
+  module Gettext
+    PLURAL_SEPARATOR  = "\001"
+    CONTEXT_SEPARATOR = "\004"
+
+    @@plural_keys = { :en => [:one, :other] }
+
+    class << self
+      # returns an array of plural keys for the given locale so that we can
+      # convert from gettext's integer-index based style
+      # TODO move this information to the pluralization module
+      def plural_keys(locale)
+        @@plural_keys[locale] || @@plural_keys[:en]
+      end
+
+      def extract_scope(msgid, separator)
+        scope = msgid.to_s.split(separator)
+        msgid = scope.pop
+        [scope, msgid]
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers.rb
new file mode 100644
index 0000000..8bbe02e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers.rb
@@ -0,0 +1,5 @@
+module I18n
+  module Helpers
+    autoload :Gettext, 'i18n/helpers/gettext'
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers/gettext.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers/gettext.rb
new file mode 100644
index 0000000..f44bbe6
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/helpers/gettext.rb
@@ -0,0 +1,64 @@
+# encoding: utf-8
+
+module I18n
+  module Helpers
+    # Implements classical Gettext style accessors. To use this include the
+    # module to the global namespace or wherever you want to use it.
+    #
+    #   include I18n::Helpers::Gettext
+    module Gettext
+      def gettext(msgid, options = {})
+        I18n.t(msgid, { :default => msgid, :separator => '|' }.merge(options))
+      end
+      alias _ gettext
+
+      def sgettext(msgid, separator = '|')
+        scope, msgid = I18n::Gettext.extract_scope(msgid, separator)
+        I18n.t(msgid, :scope => scope, :default => msgid)
+      end
+      alias s_ sgettext
+
+      def pgettext(msgctxt, msgid)
+        separator = I18n::Gettext::CONTEXT_SEPARATOR
+        sgettext([msgctxt, msgid].join(separator), separator)
+      end
+      alias p_ pgettext
+
+      def ngettext(msgid, msgid_plural, n = 1)
+        nsgettext(msgid, msgid_plural, n)
+      end
+      alias n_ ngettext
+
+      # Method signatures:
+      #   nsgettext('Fruits|apple', 'apples', 2)
+      #   nsgettext(['Fruits|apple', 'apples'], 2)
+      def nsgettext(msgid, msgid_plural, n = 1, separator = '|')
+        if msgid.is_a?(Array)
+          msgid, msgid_plural, n, separator = msgid[0], msgid[1], msgid_plural, n
+          separator = '|' unless separator.is_a?(String)
+        end
+
+        scope, msgid = I18n::Gettext.extract_scope(msgid, separator)
+        default = { :one => msgid, :other => msgid_plural }
+        I18n.t(msgid, :default => default, :count => n, :scope => scope, :separator => separator)
+      end
+      alias ns_ nsgettext
+
+      # Method signatures:
+      #   npgettext('Fruits', 'apple', 'apples', 2)
+      #   npgettext('Fruits', ['apple', 'apples'], 2)
+      def npgettext(msgctxt, msgid, msgid_plural, n = 1)
+        separator = I18n::Gettext::CONTEXT_SEPARATOR
+
+        if msgid.is_a?(Array)
+          msgid_plural, msgid, n = msgid[1], [msgctxt, msgid[0]].join(separator), msgid_plural
+        else
+          msgid = [msgctxt, msgid].join(separator)
+        end
+
+        nsgettext(msgid, msgid_plural, n, separator)
+      end
+      alias np_ npgettext
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale.rb
new file mode 100644
index 0000000..4f9d026
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale.rb
@@ -0,0 +1,6 @@
+module I18n
+  module Locale
+  autoload :Fallbacks, 'i18n/locale/fallbacks'
+  autoload :Tag,       'i18n/locale/tag'
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/fallbacks.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/fallbacks.rb
new file mode 100644
index 0000000..11dcf8c
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/fallbacks.rb
@@ -0,0 +1,98 @@
+# encoding: utf-8
+
+# Locale Fallbacks
+#
+# Extends the I18n module to hold a fallbacks instance which is set to an
+# instance of I18n::Locale::Fallbacks by default but can be swapped with a
+# different implementation.
+#
+# Locale fallbacks will compute a number of fallback locales for a given locale.
+# For example:
+#
+# <pre><code>
+# I18n.fallbacks[:"es-MX"] # => [:"es-MX", :es, :en] </code></pre>
+#
+# Locale fallbacks always fall back to
+#
+#   * all parent locales of a given locale (e.g. :es for :"es-MX") first,
+#   * the current default locales and all of their parents second
+#
+# The default locales are set to [I18n.default_locale] by default but can be
+# set to something else.
+#
+# One can additionally add any number of additional fallback locales manually.
+# These will be added before the default locales to the fallback chain. For
+# example:
+#
+#   # using the default locale as default fallback locale
+#
+#   I18n.default_locale = :"en-US"
+#   I18n.fallbacks = I18n::Fallbacks.new(:"de-AT" => :"de-DE")
+#   I18n.fallbacks[:"de-AT"] # => [:"de-AT", :"de-DE", :de, :"en-US", :en]
+#
+#   # using a custom locale as default fallback locale
+#
+#   I18n.fallbacks = I18n::Fallbacks.new(:"en-GB", :"de-AT" => :de, :"de-CH" => :de)
+#   I18n.fallbacks[:"de-AT"] # => [:"de-AT", :de, :"en-GB", :en]
+#   I18n.fallbacks[:"de-CH"] # => [:"de-CH", :de, :"en-GB", :en]
+#
+#   # mapping fallbacks to an existing instance
+#
+#   # people speaking Catalan also speak Spanish as spoken in Spain
+#   fallbacks = I18n.fallbacks
+#   fallbacks.map(:ca => :"es-ES")
+#   fallbacks[:ca] # => [:ca, :"es-ES", :es, :"en-US", :en]
+#
+#   # people speaking Arabian as spoken in Palestine also speak Hebrew as spoken in Israel
+#   fallbacks.map(:"ar-PS" => :"he-IL")
+#   fallbacks[:"ar-PS"] # => [:"ar-PS", :ar, :"he-IL", :he, :"en-US", :en]
+#   fallbacks[:"ar-EG"] # => [:"ar-EG", :ar, :"en-US", :en]
+#
+#   # people speaking Sami as spoken in Finnland also speak Swedish and Finnish as spoken in Finnland
+#   fallbacks.map(:sms => [:"se-FI", :"fi-FI"])
+#   fallbacks[:sms] # => [:sms, :"se-FI", :se, :"fi-FI", :fi, :"en-US", :en]
+
+module I18n
+  module Locale
+    class Fallbacks < Hash
+      def initialize(*mappings)
+        @map = {}
+        map(mappings.pop) if mappings.last.is_a?(Hash)
+        self.defaults = mappings.empty? ? [I18n.default_locale.to_sym] : mappings
+      end
+
+      def defaults=(defaults)
+        @defaults = defaults.map { |default| compute(default, false) }.flatten
+      end
+      attr_reader :defaults
+
+      def [](locale)
+        raise InvalidLocale.new(locale) if locale.nil?
+        locale = locale.to_sym
+        super || store(locale, compute(locale))
+      end
+
+      def map(mappings)
+        mappings.each do |from, to|
+          from, to = from.to_sym, Array(to)
+          to.each do |to|
+            @map[from] ||= []
+            @map[from] << to.to_sym
+          end
+        end
+      end
+
+      protected
+
+      def compute(tags, include_defaults = true)
+        result = Array(tags).collect do |tag|
+          tags = I18n::Locale::Tag.tag(tag).self_and_parents.map! { |t| t.to_sym }
+          tags.each { |tag| tags += compute(@map[tag]) if @map[tag] }
+          tags
+        end.flatten
+        result.push(*defaults) if include_defaults
+        result.uniq
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag.rb
new file mode 100644
index 0000000..a640b44
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+
+module I18n
+  module Locale
+    module Tag
+      autoload :Parents, 'i18n/locale/tag/parents'
+      autoload :Rfc4646, 'i18n/locale/tag/rfc4646'
+      autoload :Simple,  'i18n/locale/tag/simple'
+
+      class << self
+        # Returns the current locale tag implementation. Defaults to +I18n::Locale::Tag::Simple+.
+        def implementation
+          @@implementation ||= Simple
+        end
+
+        # Sets the current locale tag implementation. Use this to set a different locale tag implementation.
+        def implementation=(implementation)
+          @@implementation = implementation
+        end
+
+        # Factory method for locale tags. Delegates to the current locale tag implementation.
+        def tag(tag)
+          implementation.tag(tag)
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/parents.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/parents.rb
new file mode 100644
index 0000000..a094468
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/parents.rb
@@ -0,0 +1,24 @@
+# encoding: utf-8
+
+module I18n
+  module Locale
+    module Tag
+      module Parents
+        def parent
+          @parent ||= begin
+            segs = to_a.compact
+            segs.length > 1 ? self.class.tag(*segs[0..(segs.length-2)].join('-')) : nil
+          end
+        end
+
+        def self_and_parents
+          @self_and_parents ||= [self] + parents
+        end
+
+        def parents
+          @parents ||= ([parent] + (parent ? parent.parents : [])).compact
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/rfc4646.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/rfc4646.rb
new file mode 100644
index 0000000..c20d35a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/rfc4646.rb
@@ -0,0 +1,76 @@
+# encoding: utf-8
+
+# RFC 4646/47 compliant Locale tag implementation that parses locale tags to
+# subtags such as language, script, region, variant etc.
+#
+# For more information see by http://en.wikipedia.org/wiki/IETF_language_tag
+#
+# Rfc4646::Parser does not implement grandfathered tags.
+
+module I18n
+  module Locale
+    module Tag
+      RFC4646_SUBTAGS = [ :language, :script, :region, :variant, :extension, :privateuse, :grandfathered ]
+      RFC4646_FORMATS = { :language => :downcase, :script => :capitalize, :region => :upcase, :variant => :downcase }
+
+      class Rfc4646 < Struct.new(*RFC4646_SUBTAGS)
+        class << self
+          # Parses the given tag and returns a Tag instance if it is valid.
+          # Returns false if the given tag is not valid according to RFC 4646.
+          def tag(tag)
+            matches = parser.match(tag)
+            new(*matches) if matches
+          end
+
+          def parser
+            @@parser ||= Rfc4646::Parser
+          end
+
+          def parser=(parser)
+            @@parser = parser
+          end
+        end
+
+        include Parents
+
+        RFC4646_FORMATS.each do |name, format|
+          define_method(name) { self[name].send(format) unless self[name].nil? }
+        end
+
+        def to_sym
+          to_s.to_sym
+        end
+
+        def to_s
+          @tag ||= to_a.compact.join("-")
+        end
+
+        def to_a
+          members.collect { |attr| self.send(attr) }
+        end
+
+        module Parser
+          PATTERN = %r{\A(?:
+            ([a-z]{2,3}(?:(?:-[a-z]{3}){0,3})?|[a-z]{4}|[a-z]{5,8}) # language
+            (?:-([a-z]{4}))?                                        # script
+            (?:-([a-z]{2}|\d{3}))?                                  # region
+            (?:-([0-9a-z]{5,8}|\d[0-9a-z]{3}))*                     # variant
+            (?:-([0-9a-wyz](?:-[0-9a-z]{2,8})+))*                   # extension
+            (?:-(x(?:-[0-9a-z]{1,8})+))?|                           # privateuse subtag
+            (x(?:-[0-9a-z]{1,8})+)|                                 # privateuse tag
+            /* ([a-z]{1,3}(?:-[0-9a-z]{2,8}){1,2}) */               # grandfathered
+            )\z}xi
+
+          class << self
+            def match(tag)
+              c = PATTERN.match(tag.to_s).captures
+              c[0..4] << (c[5].nil? ? c[6] : c[5])  << c[7] # TODO c[7] is grandfathered, throw a NotImplemented exception here?
+            rescue
+              false
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/simple.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/simple.rb
new file mode 100644
index 0000000..0fddb36
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/locale/tag/simple.rb
@@ -0,0 +1,41 @@
+# encoding: utf-8
+
+# Simple Locale tag implementation that computes subtags by simply splitting
+# the locale tag at '-' occurences.
+module I18n
+  module Locale
+    module Tag
+      class Simple
+        class << self
+          def tag(tag)
+            new(tag)
+          end
+        end
+
+        include Parents
+
+        attr_reader :tag
+
+        def initialize(*tag)
+          @tag = tag.join('-').to_sym
+        end
+
+        def subtags
+          @subtags = tag.to_s.split('-').map { |subtag| subtag.to_s }
+        end
+
+        def to_sym
+          tag
+        end
+
+        def to_s
+          tag.to_s
+        end
+
+        def to_a
+          subtags
+        end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/version.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/version.rb
new file mode 100644
index 0000000..6a59d2b
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/lib/i18n/version.rb
@@ -0,0 +1,3 @@
+module I18n
+  VERSION = "0.3.3"
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/all.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/all.rb
new file mode 100644
index 0000000..e846143
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/all.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+
+dir = File.dirname(__FILE__)
+$LOAD_PATH.unshift(dir)
+
+Dir["#{dir}/**/*_test.rb"].sort.each do |file|
+  require file.sub(/^#{dir}\/(.*)\.rb$/, '\1')
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/basics.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/basics.rb
new file mode 100644
index 0000000..4eeb363
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/basics.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Basics
+      def test_available_locales
+        store_translations('de', :foo => 'bar')
+        store_translations('en', :foo => 'foo')
+
+        assert I18n.available_locales.include?(:de)
+        assert I18n.available_locales.include?(:en)
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/defaults.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/defaults.rb
new file mode 100644
index 0000000..62462f3
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/defaults.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Defaults
+      def setup
+        super
+        store_translations(:foo => { :bar => 'bar', :baz => 'baz' })
+      end
+      
+      define_method "test defaults: given nil as a key it returns the given default" do
+        assert_equal 'default', I18n.t(nil, :default => 'default')
+      end
+      
+      define_method "test defaults: given a symbol as a default it translates the symbol" do
+        assert_equal 'bar', I18n.t(nil, :default => :'foo.bar')
+      end
+
+      define_method "test defaults: given a symbol as a default and a scope it stays inside the scope when looking up the symbol" do
+        assert_equal 'bar', I18n.t(:missing, :default => :bar, :scope => :foo)
+      end
+
+      define_method "test defaults: given an array as a default it returns the first match" do
+        assert_equal 'bar', I18n.t(:does_not_exist, :default => [:does_not_exist_2, :'foo.bar'])
+      end
+
+      define_method "test defaults: given an array of missing keys it raises a MissingTranslationData exception" do
+        assert_raises I18n::MissingTranslationData do
+          I18n.t(:does_not_exist, :default => [:does_not_exist_2, :does_not_exist_3], :raise => true)
+        end
+      end
+
+      define_method "test defaults: using a custom scope separator" do
+        # data must have been stored using the custom separator when using the ActiveRecord backend
+        I18n.backend.store_translations(:en, { :foo => { :bar => 'bar' } }, { :separator => '|' })
+        assert_equal 'bar', I18n.t(nil, :default => :'foo|bar', :separator => '|')
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/interpolation.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/interpolation.rb
new file mode 100644
index 0000000..576d2ea
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/interpolation.rb
@@ -0,0 +1,92 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Interpolation
+      def interpolate(*args)
+        options = args.last.is_a?(Hash) ? args.pop : {}
+        key = args.pop
+        I18n.backend.translate('en', key, options)
+      end
+
+      define_method "test interpolation: given no values it does not alter the string" do
+        assert_equal 'Hi {{name}}!', interpolate(:default => 'Hi {{name}}!')
+      end
+
+      define_method "test interpolation: given values it interpolates them into the string" do
+        assert_equal 'Hi David!', interpolate(:default => 'Hi {{name}}!', :name => 'David')
+      end
+
+      define_method "test interpolation: given a nil value it still interpolates it into the string" do
+        assert_equal 'Hi !', interpolate(:default => 'Hi {{name}}!', :name => nil)
+      end
+
+      define_method "test interpolation: given a lambda as a value it calls it if the string contains the key" do
+        assert_equal 'Hi David!', interpolate(:default => 'Hi {{name}}!', :name => lambda { |*args| 'David' })
+      end
+
+      define_method "test interpolation: given a lambda as a value it does not call it if the string does not contain the key" do
+        assert_nothing_raised { interpolate(:default => 'Hi!', :name => lambda { |*args| raise 'fail' }) }
+      end
+
+      define_method "test interpolation: given values but missing a key it raises I18n::MissingInterpolationArgument" do
+        assert_raises(I18n::MissingInterpolationArgument) do
+          interpolate(:default => '{{foo}}', :bar => 'bar')
+        end
+      end
+
+      define_method "test interpolation: it does not raise I18n::MissingInterpolationArgument for escaped variables" do
+        assert_nothing_raised(I18n::MissingInterpolationArgument) do
+          assert_equal 'Barr {{foo}}', interpolate(:default => '{{bar}} \{{foo}}', :bar => 'Barr')
+        end
+      end
+
+      define_method "test interpolation: it does not change the original, stored translation string" do
+        I18n.backend.store_translations(:en, :interpolate => 'Hi {{name}}!')
+        assert_equal 'Hi David!', interpolate(:interpolate, :name => 'David')
+        assert_equal 'Hi Yehuda!', interpolate(:interpolate, :name => 'Yehuda')
+      end
+
+      define_method "test interpolation: works with Ruby 1.9 syntax" do
+        assert_equal 'Hi David!', interpolate(:default => 'Hi %{name}!', :name => 'David')
+      end
+
+      define_method "test interpolation: given the translation is in utf-8 it still works" do
+        assert_equal 'Hi David!', interpolate(:default => 'Hi {{name}}!', :name => 'David')
+      end
+
+      define_method "test interpolation: given the value is in utf-8 it still works" do
+        assert_equal 'Hi !', interpolate(:default => 'Hi {{name}}!', :name => '')
+      end
+
+      define_method "test interpolation: given the translation and the value are in utf-8 it still works" do
+        assert_equal '!', interpolate(:default => '{{name}}!', :name => '')
+      end
+
+      if Kernel.const_defined?(:Encoding)
+        define_method "test interpolation: given a euc-jp translation and a utf-8 value it raises Encoding::CompatibilityError" do
+          assert_raises(Encoding::CompatibilityError) do
+            interpolate(:default => euc_jp('{{name}}!'), :name => '')
+          end
+        end
+        
+        # define_method "test interpolation: given a utf-8 translation and a euc-jp value it returns a translation in euc-jp" do
+        #   assert_equal euc_jp('Hi !'), interpolate(:default => 'Hi {{name}}!', :name => euc_jp(''))
+        # end
+        # 
+        # TODO should better explain how this relates to the test above with the simpler utf-8 default string
+        define_method "test interpolation: given a utf-8 translation and a euc-jp value it raises Encoding::CompatibilityError" do
+          assert_raises(Encoding::CompatibilityError) do
+            interpolate(:default => '{{name}}!', :name => euc_jp(''))
+          end
+        end
+      end
+
+      define_method "test interpolation: given a translations containing a reserved key it raises I18n::ReservedInterpolationKey" do
+        assert_raises(I18n::ReservedInterpolationKey) { interpolate(:default => '{{default}}',   :foo => :bar) }
+        assert_raises(I18n::ReservedInterpolationKey) { interpolate(:default => '{{scope}}',     :foo => :bar) }
+        assert_raises(I18n::ReservedInterpolationKey) { interpolate(:default => '{{separator}}', :foo => :bar) }
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/link.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/link.rb
new file mode 100644
index 0000000..534e650
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/link.rb
@@ -0,0 +1,55 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Link
+      define_method "test linked lookup: if a key resolves to a symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :link  => :linked,
+          :linked => 'linked'
+        }
+        assert_equal 'linked', I18n.backend.translate('en', :link)
+      end
+
+      define_method "test linked lookup: if a key resolves to a dot-separated symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :link => :"foo.linked",
+          :foo  => { :linked => 'linked' }
+        }
+        assert_equal('linked', I18n.backend.translate('en', :link))
+      end
+
+      define_method "test linked lookup: if a dot-separated key resolves to a symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :foo    => { :link => :linked },
+          :linked => 'linked'
+        }
+        assert_equal('linked', I18n.backend.translate('en', :'foo.link'))
+      end
+      
+      define_method "test linked lookup: if a dot-separated key resolves to a dot-separated symbol it looks up the symbol" do
+        I18n.backend.store_translations 'en', {
+          :foo => { :link   => :"bar.linked" },
+          :bar => { :linked => 'linked' }
+        }
+        assert_equal('linked', I18n.backend.translate('en', :'foo.link'))
+      end
+      
+      define_method "test linked lookup: links refer to absolute keys even if a scope was given" do
+        I18n.backend.store_translations 'en', {
+          :foo => { :link  => :linked, :linked => 'linked in foo' },
+          :linked => 'linked absolutely'
+        }
+        assert_equal 'linked absolutely', I18n.backend.translate('en', :link, :scope => :foo)
+      end
+
+      define_method "test linked lookup: a link can resolve to a namespace in the middle of a dot-separated key" do
+        I18n.backend.store_translations 'en', {
+          :activemodel  => { :errors => { :messages => { :blank => "can't be blank" } } },
+          :activerecord => { :errors => { :messages => :"activemodel.errors.messages" } }
+        }
+        assert_equal "can't be blank", I18n.t(:"activerecord.errors.messages.blank")
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date.rb
new file mode 100644
index 0000000..9454c7f
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date.rb
@@ -0,0 +1,91 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module Date
+        def setup
+          super
+          setup_date_translations
+          @date = ::Date.new(2008, 3, 1)
+        end
+        
+        define_method "test localize Date: given the short format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '01. Mar', I18n.l(@date, :format => :short, :locale => :de)
+        end
+
+        define_method "test localize Date: given the long format it uses it" do
+          assert_equal '01. Mrz 2008', I18n.l(@date, :format => :long, :locale => :de)
+        end
+
+        define_method "test localize Date: given the default format it uses it" do
+          assert_equal '01.03.2008', I18n.l(@date, :format => :default, :locale => :de)
+        end
+
+        define_method "test localize Date: given a day name format it returns the correct day name" do
+          assert_equal 'Samstag', I18n.l(@date, :format => '%A', :locale => :de)
+        end
+
+        define_method "test localize Date: given an abbreviated day name format it returns the correct abbreviated day name" do
+          assert_equal 'Sa', I18n.l(@date, :format => '%a', :locale => :de)
+        end
+
+        define_method "test localize Date: given a month name format it returns the correct month name" do
+          assert_equal 'Mrz', I18n.l(@date, :format => '%B', :locale => :de)
+        end
+
+        define_method "test localize Date: given an abbreviated month name format it returns the correct abbreviated month name" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Mar', I18n.l(@date, :format => '%b', :locale => :de)
+        end
+
+        define_method "test localize Date: given a format that resolves to a Proc it calls the Proc with the object" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '[Sat, 01 Mar 2008, {}]', I18n.l(@date, :format => :proc, :locale => :de)
+        end
+
+        # TODO fails, but something along these lines probably should pass
+        # define_method "test localize Date: given a format that resolves to a Proc it calls the Proc with the object and extra options" do
+        #   assert_equal '[Sat Mar 01 06:00:00 UTC 2008, {:foo=>"foo"}]', I18n.l(@time, :format => :proc, :foo => 'foo', :locale => :de)
+        # end
+
+        define_method "test localize Date: given an unknown format it does not fail" do
+          assert_nothing_raised { I18n.l(@date, :format => '%x') }
+        end
+
+        define_method "test localize Date: given nil it raises I18n::ArgumentError" do
+          assert_raises(I18n::ArgumentError) { I18n.l(nil) }
+        end
+
+        define_method "test localize Date: given a plain Object it raises I18n::ArgumentError" do
+          assert_raises(I18n::ArgumentError) { I18n.l(Object.new) }
+        end
+        
+        define_method "test localize Date: it does not alter the format string" do
+          assert_equal '01. Februar 2009', I18n.l(::Date.parse('2009-02-01'), :format => :long, :locale => :de)
+          assert_equal '01. Oktober 2009', I18n.l(::Date.parse('2009-10-01'), :format => :long, :locale => :de)
+        end
+
+        protected
+        
+          def setup_date_translations
+            store_translations :de, {
+              :date => {
+                :formats => {
+                  :default => "%d.%m.%Y",
+                  :short => "%d. %b",
+                  :long => "%d. %B %Y",
+                  :proc => lambda { |*args| args.inspect }
+                },
+                :day_names => %w(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag),
+                :abbr_day_names => %w(So Mo Di Mi Do Fr  Sa),
+                :month_names => %w(Januar Februar Mrz April Mai Juni Juli August September Oktober November Dezember).unshift(nil),
+                :abbr_month_names => %w(Jan Feb Mar Apr Mai Jun Jul Aug Sep Okt Nov Dez).unshift(nil)
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date_time.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date_time.rb
new file mode 100644
index 0000000..7225694
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/date_time.rb
@@ -0,0 +1,90 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module DateTime
+        def setup
+          super
+          setup_datetime_translations
+          @datetime = ::DateTime.new(2008, 3, 1, 6)
+          @other_datetime = ::DateTime.new(2008, 3, 1, 18)
+        end
+        
+        define_method "test localize DateTime: given the short format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '01. Mar 06:00', I18n.l(@datetime, :format => :short, :locale => :de)
+        end
+
+        define_method "test localize DateTime: given the long format it uses it" do
+          assert_equal '01. Mrz 2008 06:00', I18n.l(@datetime, :format => :long, :locale => :de)
+        end
+
+        define_method "test localize DateTime: given the default format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Sa, 01. Mar 2008 06:00:00 +0000', I18n.l(@datetime, :format => :default, :locale => :de)
+        end
+
+        define_method "test localize DateTime: given a day name format it returns the correct day name" do
+          assert_equal 'Samstag', I18n.l(@datetime, :format => '%A', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given an abbreviated day name format it returns the correct abbreviated day name" do
+          assert_equal 'Sa', I18n.l(@datetime, :format => '%a', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given a month name format it returns the correct month name" do
+          assert_equal 'Mrz', I18n.l(@datetime, :format => '%B', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given an abbreviated month name format it returns the correct abbreviated month name" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Mar', I18n.l(@datetime, :format => '%b', :locale => :de)
+        end
+
+        define_method "test localize DateTime: given a meridian indicator format it returns the correct meridian indicator" do
+          assert_equal 'am', I18n.l(@datetime, :format => '%p', :locale => :de)
+          assert_equal 'pm', I18n.l(@other_datetime, :format => '%p', :locale => :de)
+        end
+
+        define_method "test localize Date: given a format that resolves to a Proc it calls the Proc with the object" do
+          if can_store_procs?
+            assert_equal '[Sat, 01 Mar 2008 06:00:00 +0000, {}]', I18n.l(@datetime, :format => :proc, :locale => :de)
+          end
+        end
+
+        # TODO fails, but something along these lines probably should pass
+        # define_method "test localize DateTime: given a format that resolves to a Proc it calls the Proc with the object and extra options" do
+        #   assert_equal '1ter Mrz 2008, 06:00 Uhr', I18n.l(@datetime, :long_ordinalized)
+        # end
+
+        define_method "test localize DateTime: given an unknown format it does not fail" do
+          assert_nothing_raised { I18n.l(@datetime, :format => '%x') }
+        end
+        
+        protected
+        
+          def setup_datetime_translations
+            # time translations might have been set up in Tests::Api::Localization::Time
+            I18n.t(:'time.formats.default', :locale => :de, :raise => true)
+          rescue
+            store_translations :de, {
+              :time => {
+                :formats => {
+                  :default => "%a, %d. %b %Y %H:%M:%S %z",
+                  :short => "%d. %b %H:%M",
+                  :long => "%d. %B %Y %H:%M",
+                  :long_ordinalized => lambda { |date, options|
+                    tz = " (#{options[:timezone]})" if options[:timezone]
+                    "#{date.day}ter %B %Y, %H:%M Uhr#{tz}"
+                  }
+                },
+                :am => 'am',
+                :pm => 'pm'
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/procs.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/procs.rb
new file mode 100644
index 0000000..d7c5fd4
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/procs.rb
@@ -0,0 +1,54 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module Procs
+        define_method "test localize: using day names from lambdas" do
+          setup_time_proc_translations
+          time = ::Time.parse('2008-03-01 6:00 UTC')
+          assert_match //, I18n.l(time, :format => "%A, %d %B", :locale => :ru)
+          assert_match //, I18n.l(time, :format => "%d %B (%A)", :locale => :ru)
+        end
+
+        define_method "test localize: using month names from lambdas" do
+          setup_time_proc_translations
+          time = ::Time.parse('2008-03-01 6:00 UTC')
+          assert_match //, I18n.l(time, :format => "%d %B %Y", :locale => :ru)
+          assert_match / /, I18n.l(time, :format => "%B %Y", :locale => :ru)
+        end
+
+        define_method "test localize: using abbreviated day names from lambdas" do
+          setup_time_proc_translations
+          time = ::Time.parse('2008-03-01 6:00 UTC')
+          assert_match //, I18n.l(time, :format => "%d %b %Y", :locale => :ru)
+          assert_match / /, I18n.l(time, :format => "%b %Y", :locale => :ru)
+        end
+
+        protected
+
+          def setup_time_proc_translations
+            store_translations :ru, {
+              :date => {
+                :'day_names' => lambda { |key, options|
+                  (options[:format] =~ /^%A/) ?
+                  %w(      ) :
+                  %w(      )
+                },
+                :'month_names' => lambda { |key, options|
+                  (options[:format] =~ /(%d|%e)(\s*)?(%B)/) ?
+                  %w(           ).unshift(nil) :
+                  %w(           ).unshift(nil)
+                },
+                :'abbr_month_names' => lambda { |key, options|
+                  (options[:format] =~ /(%d|%e)(\s*)(%b)/) ?
+                  %w(. .  .    . . . . .).unshift(nil) :
+                  %w(. .  .    . . . . .).unshift(nil)
+                },
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/time.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/time.rb
new file mode 100644
index 0000000..eca2fae
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/localization/time.rb
@@ -0,0 +1,84 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Localization
+      module Time
+        def setup
+          super
+          setup_time_translations
+          @time = ::Time.parse('2008-03-01 6:00 UTC')
+          @other_time = ::Time.parse('2008-03-01 18:00 UTC')
+        end
+        
+        define_method "test localize Time: given the short format it uses it" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal '01. Mar 06:00', I18n.l(@time, :format => :short, :locale => :de)
+        end
+        
+        define_method "test localize Time: given the long format it uses it" do
+          assert_equal '01. Mrz 2008 06:00', I18n.l(@time, :format => :long, :locale => :de)
+        end
+        
+        # TODO Seems to break on Windows because ENV['TZ'] is ignored. What's a better way to do this?
+        # def test_localize_given_the_default_format_it_uses_it
+        #   assert_equal 'Sa, 01. Mar 2008 06:00:00 +0000', I18n.l(@time, :format => :default, :locale => :de)
+        # end
+        
+        define_method "test localize Time: given a day name format it returns the correct day name" do
+          assert_equal 'Samstag', I18n.l(@time, :format => '%A', :locale => :de)
+        end
+        
+        define_method "test localize Time: given an abbreviated day name format it returns the correct abbreviated day name" do
+          assert_equal 'Sa', I18n.l(@time, :format => '%a', :locale => :de)
+        end
+        
+        define_method "test localize Time: given a month name format it returns the correct month name" do
+          assert_equal 'Mrz', I18n.l(@time, :format => '%B', :locale => :de)
+        end
+        
+        define_method "test localize Time: given an abbreviated month name format it returns the correct abbreviated month name" do
+          # TODO should be Mrz, shouldn't it?
+          assert_equal 'Mar', I18n.l(@time, :format => '%b', :locale => :de)
+        end
+        
+        define_method "test localize Time: given a meridian indicator format it returns the correct meridian indicator" do
+          assert_equal 'am', I18n.l(@time, :format => '%p', :locale => :de)
+          assert_equal 'pm', I18n.l(@other_time, :format => '%p', :locale => :de)
+        end
+
+        define_method "test localize Time: given a format that resolves to a Proc it calls the Proc with the object" do
+          if can_store_procs?
+            assert_equal '[Sat, 01 Mar 2008 06:00:00 +0000, {}]', I18n.l(@datetime, :format => :proc, :locale => :de)
+          end
+        end
+        
+        # TODO fails, but something along these lines probably should pass
+        # define_method "test localize Time: given a format that resolves to a Proc it calls the Proc with the object and extra options" do
+        #   assert_equal '[Sat Mar 01 06:00:00 UTC 2008, {:foo=>"foo"}]', I18n.l(@time, :format => :proc, :foo => 'foo', :locale => :de)
+        # end
+        
+        define_method "test localize Time: given an unknown format it does not fail" do
+          assert_nothing_raised { I18n.l(@time, :format => '%x') }
+        end
+        
+        protected
+        
+          def setup_time_translations
+            store_translations :de, {
+              :time => {
+                :formats => {
+                  :default => "%a, %d. %b %Y %H:%M:%S %z",
+                  :short => "%d. %b %H:%M",
+                  :long => "%d. %B %Y %H:%M",
+                  :proc => lambda { |*args| args.inspect }
+                },
+                :am => 'am',
+                :pm => 'pm'
+              }
+            }
+          end
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/lookup.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/lookup.rb
new file mode 100644
index 0000000..ce7b488
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/lookup.rb
@@ -0,0 +1,45 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Lookup
+      def setup
+        super
+        store_translations(:foo => { :bar => 'bar', :baz => 'baz' }, :bla => false)
+      end
+
+      define_method "test lookup: given a nested key it looks up the nested hash value" do
+        assert_equal 'bar', I18n.t(:'foo.bar')
+      end
+
+      define_method "test make sure we can store a native false value as well" do
+        assert_equal false, I18n.t(:bla)
+      end
+
+      define_method "test lookup: given a missing key, no default and no raise option it returns an error message" do
+        assert_equal "translation missing: en, missing", I18n.t(:missing)
+      end
+
+      define_method "test lookup: given a missing key, no default and the raise option it raises MissingTranslationData" do
+        assert_raises(I18n::MissingTranslationData) { I18n.t(:missing, :raise => true) }
+      end
+
+      define_method "test lookup: given an array of keys it translates all of them" do
+        assert_equal %w(bar baz), I18n.t([:bar, :baz], :scope => [:foo])
+      end
+
+      define_method "test lookup: using a custom scope separator" do
+        # data must have been stored using the custom separator when using the ActiveRecord backend
+        I18n.backend.store_translations(:en, { :foo => { :bar => 'bar' } }, { :separator => '|' })
+        assert_equal 'bar', I18n.t('foo|bar', :separator => '|')
+      end
+
+      # In fact it probably *should* fail but Rails currently relies on using the default locale instead.
+      # So we'll stick to this for now until we get it fixed in Rails.
+      define_method "test lookup: given nil as a locale it does not raise but use the default locale" do
+        # assert_raises(I18n::InvalidLocale) { I18n.t(:bar, :locale => nil) }
+        assert_nothing_raised { I18n.t(:bar, :locale => nil) }
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/pluralization.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/pluralization.rb
new file mode 100644
index 0000000..36413a2
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/pluralization.rb
@@ -0,0 +1,35 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Pluralization
+      define_method "test pluralization: given 0 it returns the :zero translation if it is defined" do
+        assert_equal 'zero', I18n.t(:default => { :zero => 'zero' }, :count => 0)
+      end
+
+      define_method "test pluralization: given 0 it returns the :other translation if :zero is not defined" do
+        assert_equal 'bars', I18n.t(:default => { :other => 'bars' }, :count => 0)
+      end
+
+      define_method "test pluralization: given 1 it returns the singular translation" do
+        assert_equal 'bar', I18n.t(:default => { :one => 'bar' }, :count => 1)
+      end
+
+      define_method "test pluralization: given 2 it returns the :other translation" do
+        assert_equal 'bars', I18n.t(:default => { :other => 'bars' }, :count => 2)
+      end
+
+      define_method "test pluralization: given 3 it returns the :other translation" do
+        assert_equal 'bars', I18n.t(:default => { :other => 'bars' }, :count => 3)
+      end
+
+      define_method "test pluralization: given nil it returns the whole entry" do
+        assert_equal({ :one => 'bar' }, I18n.t(:default => { :one => 'bar' }, :count => nil))
+      end
+
+      define_method "test pluralization: given incomplete pluralization data it raises I18n::InvalidPluralizationData" do
+        assert_raises(I18n::InvalidPluralizationData) { I18n.t(:default => { :one => 'bar' }, :count => 2) }
+      end
+    end
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/procs.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/procs.rb
new file mode 100644
index 0000000..952759d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/api/procs.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+
+module Tests
+  module Api
+    module Procs
+      define_method "test lookup: given a translation is a proc it calls the proc with the key and interpolation values" do
+        store_translations(:a_lambda => lambda { |*args| args.inspect })
+        assert_equal '[:a_lambda, {:foo=>"foo"}]', I18n.t(:a_lambda, :foo => 'foo')
+      end
+
+      define_method "test defaults: given a default is a Proc it calls it with the key and interpolation values" do
+        proc = lambda { |*args| args.inspect }
+        assert_equal '[nil, {:foo=>"foo"}]', I18n.t(nil, :default => proc, :foo => 'foo')
+      end
+
+      define_method "test defaults: given a default is a key that resolves to a Proc it calls it with the key and interpolation values" do
+        store_translations(:a_lambda => lambda { |*args| args.inspect })
+        assert_equal '[:a_lambda, {:foo=>"foo"}]', I18n.t(nil, :default => :a_lambda, :foo => 'foo')
+        assert_equal '[:a_lambda, {:foo=>"foo"}]', I18n.t(nil, :default => [nil, :a_lambda], :foo => 'foo')
+      end
+
+      define_method "test interpolation: given an interpolation value is a lambda it calls it with key and values before interpolating it" do
+        proc = lambda { |*args| args.inspect }
+        assert_match %r(\[\{:foo=>#<Proc.*>\}\]), I18n.t(nil, :default => '{{foo}}', :foo => proc)
+      end
+      
+      define_method "test interpolation: given a key resolves to a Proc that returns a string then interpolation still works" do
+        proc = lambda { |*args| "{{foo}}: " + args.inspect }
+        assert_equal 'foo: [nil, {:foo=>"foo"}]', I18n.t(nil, :default => proc, :foo => 'foo')
+      end
+
+      define_method "test pluralization: given a key resolves to a Proc that returns valid data then pluralization still works" do
+        proc = lambda { |*args| { :zero => 'zero', :one => 'one', :other => 'other' } }
+        assert_equal 'zero',  I18n.t(:default => proc, :count => 0)
+        assert_equal 'one',   I18n.t(:default => proc, :count => 1)
+        assert_equal 'other', I18n.t(:default => proc, :count => 2)
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/active_record_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/active_record_test.rb
new file mode 100644
index 0000000..f886e6d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/active_record_test.rb
@@ -0,0 +1,29 @@
+# encoding: utf-8
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+setup_active_record
+
+
+class I18nActiveRecordApiTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::ActiveRecord.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs unless RUBY_VERSION >= '1.9.1'
+
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs unless RUBY_VERSION >= '1.9.1'
+
+  define_method "test: make sure we use an ActiveRecord backend" do
+    assert_equal I18n::Backend::ActiveRecord, I18n.backend.class
+  end
+end if defined?(ActiveRecord)
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/all_features_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/all_features_test.rb
new file mode 100644
index 0000000..6474ec5
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/all_features_test.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nAllFeaturesApiTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Cache
+    include I18n::Backend::Metadata
+    include I18n::Backend::Cascade
+    include I18n::Backend::Fallbacks
+    include I18n::Backend::Pluralization
+    include I18n::Backend::Fast
+    include I18n::Backend::InterpolationCompiler
+  end
+
+  def setup
+    I18n.backend = I18n::Backend::Chain.new(Backend.new, I18n::Backend::Simple.new)
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  define_method "test: make sure we use a Chain backend with an all features backend" do
+    assert_equal I18n::Backend::Chain, I18n.backend.class
+    assert_equal Backend, I18n.backend.backends.first.class
+  end
+  
+  # links: test that keys stored on one backend can link to keys stored on another backend
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/cascade_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/cascade_test.rb
new file mode 100644
index 0000000..ad33999
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/cascade_test.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nCascadeApiTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Cascade
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  define_method "test: make sure we use a backend with Cascade included" do
+    assert_equal Backend, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/chain_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/chain_test.rb
new file mode 100644
index 0000000..5b92c5d
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/chain_test.rb
@@ -0,0 +1,26 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nApiChainTest < Test::Unit::TestCase
+  def setup
+    super
+    I18n.backend = I18n::Backend::Chain.new(I18n::Backend::Simple.new, I18n.backend)
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  define_method "test: make sure we use the Chain backend" do
+    assert_equal I18n::Backend::Chain, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fallbacks_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fallbacks_test.rb
new file mode 100644
index 0000000..406e5bc
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fallbacks_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nFallbacksApiTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  define_method "test: make sure we use a backend with Fallbacks included" do
+    assert_equal Backend, I18n.backend.class
+  end
+  
+  # links: test that keys stored on one backend can link to keys stored on another backend
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fast_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fast_test.rb
new file mode 100644
index 0000000..9cc7794
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/fast_test.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nFastBackendApiTest < Test::Unit::TestCase
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+  
+  class FastBackend
+    include I18n::Backend::Base
+    include I18n::Backend::Fast
+  end
+
+  def setup
+    I18n.backend = FastBackend.new
+    super
+  end
+  
+  define_method "test: make sure we use the FastBackend backend" do
+    assert_equal FastBackend, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/pluralization_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/pluralization_test.rb
new file mode 100644
index 0000000..1d95e24
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/pluralization_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nPluralizationApiTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Pluralization
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  define_method "test: make sure we use a backend with Pluralization included" do
+    assert_equal Backend, I18n.backend.class
+  end
+  
+  # links: test that keys stored on one backend can link to keys stored on another backend
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/simple_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/simple_test.rb
new file mode 100644
index 0000000..cd4b7a5
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/api/simple_test.rb
@@ -0,0 +1,21 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nSimpleBackendApiTest < Test::Unit::TestCase
+  include Tests::Api::Basics
+  include Tests::Api::Defaults
+  include Tests::Api::Interpolation
+  include Tests::Api::Link
+  include Tests::Api::Lookup
+  include Tests::Api::Pluralization
+  include Tests::Api::Procs
+  include Tests::Api::Localization::Date
+  include Tests::Api::Localization::DateTime
+  include Tests::Api::Localization::Time
+  include Tests::Api::Localization::Procs
+
+  define_method "test: make sure we use the Simple backend" do
+    assert_equal I18n::Backend::Simple, I18n.backend.class
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record/missing_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record/missing_test.rb
new file mode 100644
index 0000000..395ae3c
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record/missing_test.rb
@@ -0,0 +1,60 @@
+# encoding: utf-8
+require File.expand_path(File.dirname(__FILE__) + '/../../../test_helper')
+
+setup_active_record
+
+class I18nActiveRecordMissingTest < Test::Unit::TestCase
+  def setup
+    store_translations(:en, :i18n => { :plural => { :keys => [:zero, :one, :other] } })
+    
+    I18n.backend = I18n::Backend::Chain.new(I18n.backend)
+    I18n.backend.meta_class.send(:include, I18n::Backend::ActiveRecord::Missing)
+    
+    I18n::Backend::ActiveRecord::Translation.delete_all
+  end
+  
+  def test_can_persist_interpolations
+    translation = I18n::Backend::ActiveRecord::Translation.new \
+      :key => 'foo', 
+      :value => 'bar', 
+      :locale => :en
+    
+    translation.interpolations = %w{ count name }
+    translation.save
+    
+    assert translation.valid?
+  end
+
+  def test_lookup_persists_key
+    I18n.t('foo.bar.baz')
+    
+    assert_equal 1, I18n::Backend::ActiveRecord::Translation.count
+  end
+
+  def test_lookup_does_not_persist_key_twice
+    2.times { I18n.t('foo.bar.baz') }
+    
+    assert_equal 1, I18n::Backend::ActiveRecord::Translation.count
+  end
+  
+  def test_persists_interpolation_keys_when_looked_up_directly
+    I18n.t('foo.bar.baz', :cow => "lucy" )  # creates stub translation.
+    
+    translation_stub = I18n::Backend::ActiveRecord::Translation.locale(:en).lookup('foo.bar.baz').first
+    assert translation_stub.interpolates?(:cow)
+  end
+
+  def test_creates_one_stub_per_pluralization
+    I18n.t('foo', :count => 999)
+    
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).find_all_by_key %w{ foo.zero foo.one foo.other }
+    assert_equal 3, translations.length
+  end
+  
+  def test_creates_no_stub_for_base_key_in_pluralization
+    I18n.t('foo', :count => 999)
+    
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).find_by_key %w{ foo.zero foo.one foo.other }
+    assert !I18n::Backend::ActiveRecord::Translation.locale(:en).find_by_key("foo")
+  end
+end if defined?(ActiveRecord)
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record_test.rb
new file mode 100644
index 0000000..32f9a1a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/active_record_test.rb
@@ -0,0 +1,52 @@
+# encoding: utf-8
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+setup_active_record
+
+
+class I18nBackendActiveRecordTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::ActiveRecord.new
+    store_translations(:en, :foo => { :bar => 'bar', :baz => 'baz' })
+  end
+
+  def teardown
+    I18n::Backend::ActiveRecord::Translation.destroy_all
+    super
+  end
+
+  def test_store_translations_does_not_allow_ambigous_keys_1
+    I18n::Backend::ActiveRecord::Translation.delete_all
+    I18n.backend.store_translations(:en, :foo => 'foo')
+    I18n.backend.store_translations(:en, :foo => { :bar => 'bar' })
+    I18n.backend.store_translations(:en, :foo => { :baz => 'baz' })
+
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).lookup('foo', '.').all
+    assert_equal %w(bar baz), translations.map(&:value)
+
+    assert_equal({ :bar => 'bar', :baz => 'baz' }, I18n.t(:foo))
+  end
+
+  def test_store_translations_does_not_allow_ambigous_keys_2
+    I18n::Backend::ActiveRecord::Translation.delete_all
+    I18n.backend.store_translations(:en, :foo => { :bar => 'bar' })
+    I18n.backend.store_translations(:en, :foo => { :baz => 'baz' })
+    I18n.backend.store_translations(:en, :foo => 'foo')
+
+    translations = I18n::Backend::ActiveRecord::Translation.locale(:en).lookup('foo', '.').all
+    assert_equal %w(foo), translations.map(&:value)
+
+    assert_equal 'foo', I18n.t(:foo)
+  end
+
+  with_mocha do
+    def test_missing_translations_table_does_not_cause_available_locales_to_error
+      I18n::Backend::ActiveRecord::Translation.expects(:available_locales).raises(::ActiveRecord::StatementInvalid)
+      assert_equal [], I18n.backend.available_locales
+    end
+  end
+
+  def test_expand_keys
+    assert_equal %w(foo foo.bar foo.bar.baz), I18n.backend.send(:expand_keys, :'foo.bar.baz')
+  end
+end if defined?(ActiveRecord)
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cache_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cache_test.rb
new file mode 100644
index 0000000..d11beef
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cache_test.rb
@@ -0,0 +1,72 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require 'i18n/backend/cache'
+
+begin
+  require 'active_support'
+rescue LoadError
+  $stderr.puts "Skipping cache tests using ActiveSupport"
+else
+
+class I18nBackendCacheTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Cache
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    super
+    I18n.cache_store = ActiveSupport::Cache.lookup_store(:memory_store)
+  end
+
+  def teardown
+    I18n.cache_store = nil
+  end
+
+  def test_uses_cache
+    assert I18n.cache_store.is_a?(ActiveSupport::Cache::MemoryStore)
+  end
+
+  with_mocha do
+    define_method "test translate hits the backend and caches the response" do
+      I18n.backend.expects(:lookup).returns('Foo')
+      assert_equal 'Foo', I18n.t(:foo)
+
+      I18n.backend.expects(:lookup).never
+      assert_equal 'Foo', I18n.t(:foo)
+
+      I18n.backend.expects(:lookup).returns('Bar')
+      assert_equal 'Bar', I18n.t(:bar)
+    end
+
+    define_method "test still raises MissingTranslationData but also caches it" do
+      I18n.backend.expects(:lookup).returns(nil)
+      assert_raises(I18n::MissingTranslationData) { I18n.t(:missing, :raise => true) }
+
+      I18n.backend.expects(:lookup).never
+      assert_raises(I18n::MissingTranslationData) { I18n.t(:missing, :raise => true) }
+    end
+  end
+
+  define_method "test uses 'i18n' as a cache key namespace by default" do
+    assert_equal 0, I18n.backend.send(:cache_key, :foo).index('i18n')
+  end
+
+  define_method "test adds a custom cache key namespace" do
+    with_cache_namespace('bar') do
+      assert_equal 0, I18n.backend.send(:cache_key, :foo).index('i18n-bar')
+    end
+  end
+
+  protected
+
+    def with_cache_namespace(namespace)
+      I18n.cache_namespace = namespace
+      yield
+      I18n.cache_namespace = nil
+    end
+end
+
+end # AS cache check
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cascade_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cascade_test.rb
new file mode 100644
index 0000000..5a29cee
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/cascade_test.rb
@@ -0,0 +1,66 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nBackendCascadeTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Cascade
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en,
+      :foo => 'foo',
+      :bar => { :baz => 'baz' }
+    )
+  end
+
+  define_method "test: still returns an existing translation as usual" do
+    assert_equal 'foo', I18n.t(:foo)
+    assert_equal 'baz', I18n.t(:'bar.baz')
+  end
+
+  define_method "test: falls back by cutting keys off the end of the scope" do
+    assert_equal 'foo', I18n.t(:'does_not_exist.foo')
+    assert_equal 'foo', I18n.t(:'does_not_exist.does_not_exist.foo')
+
+    assert_equal 'baz', I18n.t(:'bar.does_not_exist.baz')
+    assert_equal 'baz', I18n.t(:'bar.does_not_exist.does_not_exist.baz')
+  end
+
+  define_method "test: raises I18n::MissingTranslationData exception when no translation was found" do
+    assert_raises(I18n::MissingTranslationData) { I18n.t(:'foo.does_not_exist', :raise => true) }
+    assert_raises(I18n::MissingTranslationData) { I18n.t(:'bar.baz.does_not_exist', :raise => true) }
+    assert_raises(I18n::MissingTranslationData) { I18n.t(:'does_not_exist.bar.baz', :raise => true) }
+  end
+
+  define_method "test: cascades before evaluating the default" do
+    assert_equal 'foo', I18n.t(:foo, :scope => :does_not_exist, :default => 'default')
+  end
+
+  define_method "test: let's us assemble required fallbacks for ActiveRecord validation messages" do
+    store_translations(:en,
+      :errors => {
+        :reply => {
+          :title => {
+            :blank => 'blank on reply title'
+          },
+          :taken => 'taken on reply'
+        },
+        :topic => {
+          :title => {
+            :format => 'format on topic title'
+          },
+          :length => 'length on topic'
+        },
+        :odd => 'odd on errors'
+      }
+    )
+    assert_equal 'blank on reply title',  I18n.t(:'errors.reply.title.blank',  :default => :'errors.topic.title.blank')
+    assert_equal 'taken on reply',        I18n.t(:'errors.reply.title.taken',  :default => :'errors.topic.title.taken')
+    assert_equal 'format on topic title', I18n.t(:'errors.reply.title.format', :default => :'errors.topic.title.format')
+    assert_equal 'length on topic',       I18n.t(:'errors.reply.title.length', :default => :'errors.topic.title.length')
+    assert_equal 'odd on errors',         I18n.t(:'errors.reply.title.odd',    :default => :'errors.topic.title.odd')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/chain_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/chain_test.rb
new file mode 100644
index 0000000..ab8e077
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/chain_test.rb
@@ -0,0 +1,64 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require 'i18n/backend/chain'
+
+class I18nBackendChainTest < Test::Unit::TestCase
+  def setup
+    @first  = backend(:en => {
+      :foo => 'Foo', :formats => { :short => 'short' }, :plural_1 => { :one => '{{count}}' }
+    })
+    @second = backend(:en => {
+      :bar => 'Bar', :formats => { :long => 'long' }, :plural_2 => { :one => 'one' }
+    })
+    @chain  = I18n.backend = I18n::Backend::Chain.new(@first, @second)
+  end
+
+  define_method "test: looks up translations from the first chained backend" do
+    assert_equal 'Foo', @first.send(:translations)[:en][:foo]
+    assert_equal 'Foo', I18n.t(:foo)
+  end
+
+  define_method "test: looks up translations from the second chained backend" do
+    assert_equal 'Bar', @second.send(:translations)[:en][:bar]
+    assert_equal 'Bar', I18n.t(:bar)
+  end
+
+  define_method "test: defaults only apply to lookups on the last backend in the chain" do
+    assert_equal 'Foo', I18n.t(:foo, :default => 'Bah')
+    assert_equal 'Bar', I18n.t(:bar, :default => 'Bah')
+    assert_equal 'Bah', I18n.t(:bah, :default => 'Bah') # default kicks in only here
+  end
+
+  define_method "test: default" do
+    assert_equal 'Fuh',  I18n.t(:default => 'Fuh')
+    assert_equal 'Zero', I18n.t(:default => { :zero => 'Zero' }, :count => 0)
+    assert_equal({ :zero => 'Zero' }, I18n.t(:default => { :zero => 'Zero' }))
+    assert_equal 'Foo', I18n.t(:default => :foo)
+  end
+
+  define_method "test: namespace lookup collects results from all backends" do
+    assert_equal({ :short => 'short', :long => 'long' }, I18n.t(:formats))
+  end
+
+  define_method "test: namespace lookup with only the first backend returning a result" do
+    assert_equal({ :one => '{{count}}' }, I18n.t(:plural_1))
+  end
+
+  define_method "test: pluralization still works" do
+    assert_equal '1',   I18n.t(:plural_1, :count => 1)
+    assert_equal 'one', I18n.t(:plural_2, :count => 1)
+  end
+
+  define_method "test: bulk lookup collects results from all backends" do
+    assert_equal ['Foo', 'Bar'], I18n.t([:foo, :bar])
+  end
+
+  protected
+
+    def backend(translations)
+      backend = I18n::Backend::Simple.new
+      translations.each { |locale, translations| backend.store_translations(locale, translations) }
+      backend
+    end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fallbacks_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fallbacks_test.rb
new file mode 100644
index 0000000..3df6b06
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fallbacks_test.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nBackendFallbacksTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en, :foo => 'Foo in :en', :bar => 'Bar in :en', :buz => 'Buz in :en')
+    store_translations(:de, :bar => 'Bar in :de', :baz => 'Baz in :de')
+    store_translations(:'de-DE', :baz => 'Baz in :de-DE')
+  end
+
+  define_method "test: still returns an existing translation as usual" do
+    assert_equal 'Foo in :en', I18n.t(:foo, :locale => :en)
+    assert_equal 'Bar in :de', I18n.t(:bar, :locale => :de)
+    assert_equal 'Baz in :de-DE', I18n.t(:baz, :locale => :'de-DE')
+  end
+
+  define_method "test: returns the :en translation for a missing :de translation" do
+    assert_equal 'Foo in :en', I18n.t(:foo, :locale => :de)
+  end
+
+  define_method "test: returns the :de translation for a missing :'de-DE' translation" do
+    assert_equal 'Bar in :de', I18n.t(:bar, :locale => :'de-DE')
+  end
+
+  define_method "test: returns the :en translation for translation missing in both :de and :'de-De'" do
+    assert_equal 'Buz in :en', I18n.t(:buz, :locale => :'de-DE')
+  end
+
+  define_method "test: raises I18n::MissingTranslationData exception when no translation was found" do
+    assert_raises(I18n::MissingTranslationData) { I18n.t(:faa, :locale => :en, :raise => true) }
+    assert_raises(I18n::MissingTranslationData) { I18n.t(:faa, :locale => :de, :raise => true) }
+  end
+end
+
+class I18nBackendFallbacksWithChainTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Fallbacks
+  end
+
+  def setup
+    backend = Backend.new
+    backend.store_translations(:de, :foo => 'FOO')
+    I18n.backend = I18n::Backend::Chain.new(I18n::Backend::Simple.new, backend)
+  end
+
+  define_method "test: falls back from de-DE to de when there is no translation for de-DE available" do
+    assert_equal 'FOO', I18n.t(:foo, :locale => :'de-DE')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fast_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fast_test.rb
new file mode 100644
index 0000000..5768857
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/fast_test.rb
@@ -0,0 +1,50 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require File.expand_path(File.dirname(__FILE__) + '/simple_test')
+
+class I18nBackendFastTest < I18nBackendSimpleTest
+  class FastBackend
+    include I18n::Backend::Base
+    include I18n::Backend::Fast
+  end
+  
+  def setup
+    super
+    I18n.backend = FastBackend.new
+  end
+end
+
+class I18nBackendFastSpecificTest < Test::Unit::TestCase
+  class FastBackend
+    include I18n::Backend::Base
+    include I18n::Backend::Fast
+  end
+  
+  def setup
+    @backend = FastBackend.new
+  end
+
+  def assert_flattens(expected, nested)
+    assert_equal expected, @backend.send(:flatten_hash, nested)
+  end
+
+  def test_hash_flattening_works
+    assert_flattens(
+      {:a=>'a', :b=>{:c=>'c', :d=>'d', :f=>{:x=>'x'}}, :"b.f" => {:x=>"x"}, :"b.c"=>"c", :"b.f.x"=>"x", :"b.d"=>"d"},
+      {:a=>'a', :b=>{:c=>'c', :d=>'d', :f=>{:x=>'x'}}}
+    )
+    assert_flattens({:a=>{:b =>['a', 'b']}, :"a.b"=>['a', 'b']}, {:a=>{:b =>['a', 'b']}})
+  end
+
+  def test_pluralization_logic_and_lookup_works
+    counts_hash = {:zero => 'zero', :one => 'one', :other => 'other'}
+    @backend.store_translations :en, {:a => counts_hash}
+    assert_equal 'one', @backend.translate(:en, :a, :count => 1)
+  end
+
+  def test_translation_subtree_retrieval
+    @backend.store_translations :en, :a => {:foo => 'bar'}
+    assert_equal({:foo => 'bar'}, @backend.translate(:en, :a))
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/helpers_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/helpers_test.rb
new file mode 100644
index 0000000..e8d427f
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/helpers_test.rb
@@ -0,0 +1,26 @@
+# encoding: utf-8
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nBackendHelpersTest < Test::Unit::TestCase
+  def setup
+    @backend = I18n::Backend::Simple.new
+  end
+  
+  def test_wind_keys
+    hash = { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}
+    expected = { :"a.b.c" => "d", :"a.b.e" => "f", :"a.g" => "h", :"i" => "j" }
+    assert_equal expected, @backend.wind_keys(hash)
+  end
+
+  def test_unwind_keys
+    hash = { "a.b.c" => "d", :"a.b.e" => "f", :"a.g" => "h", "i" => "j" }
+    expected = { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}
+    assert_equal expected, @backend.unwind_keys(hash)
+  end
+
+  def test_deep_symbolize_keys
+    result = @backend.deep_symbolize_keys('foo' => { 'bar' => { 'baz' => 'bar' } })
+    expected = {:foo => {:bar => {:baz => 'bar'}}}
+    assert_equal expected, result
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/interpolation_compiler_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/interpolation_compiler_test.rb
new file mode 100644
index 0000000..38d272e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/interpolation_compiler_test.rb
@@ -0,0 +1,107 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class InterpolationCompilerTest < Test::Unit::TestCase
+  Compiler = I18n::Backend::InterpolationCompiler::Compiler
+
+  def compile_and_interpolate(str, values = {})
+    Compiler.compile_if_an_interpolation(str).i18n_interpolate(values)
+  end
+
+  def assert_escapes_interpolation_key(expected, malicious_str)
+    assert_equal(expected, Compiler.send(:escape_key_sym, malicious_str))
+  end
+
+  def test_escape_key_properly_escapes
+    assert_escapes_interpolation_key ':"\""',       '"'
+    assert_escapes_interpolation_key ':"\\\\"',     '\\'
+    assert_escapes_interpolation_key ':"\\\\\""',   '\\"'
+    assert_escapes_interpolation_key ':"\#{}"',     '#{}'
+    assert_escapes_interpolation_key ':"\\\\\#{}"', '\#{}'
+  end
+
+  def assert_escapes_plain_string(expected, plain_str)
+    assert_equal expected, Compiler.send(:escape_plain_str, plain_str)
+  end
+
+  def test_escape_plain_string_properly_escapes
+    assert_escapes_plain_string '\\"',    '"'
+    assert_escapes_plain_string '\'',     '\''
+    assert_escapes_plain_string '\\#',    '#'
+    assert_escapes_plain_string '\\#{}',  '#{}'
+    assert_escapes_plain_string '\\\\\\"','\\"'
+  end
+
+  def test_non_interpolated_strings_or_arrays_dont_get_compiled
+    ['abc', '\\{a}}', '{a}}', []].each do |obj|
+      Compiler.compile_if_an_interpolation(obj)
+      assert_equal false, obj.respond_to?(:i18n_interpolate)
+    end
+  end
+
+  def test_interpolated_string_gets_compiled
+    assert_equal '-A-', compile_and_interpolate('-{{a}}-', :a => 'A')
+  end
+
+  def assert_handles_key(str, key)
+    assert_equal 'A', compile_and_interpolate(str, key => 'A')
+  end
+
+  def test_compiles_fancy_keys
+    assert_handles_key('{{\}}',      :'\\'    )
+    assert_handles_key('{{#}}',      :'#'     )
+    assert_handles_key('{{#{}}',     :'#{'    )
+    assert_handles_key('{{#$SAFE}}', :'#$SAFE')
+    assert_handles_key('{{\000}}',   :'\000'  )
+    assert_handles_key('{{\'}}',     :'\''    )
+    assert_handles_key('{{\'\'}}',   :'\'\''  )
+    assert_handles_key('{{a.b}}',    :'a.b'   )
+    assert_handles_key('{{ }}',      :' '     )
+    assert_handles_key('{{:}}',      :':'     )
+    assert_handles_key("{{:''}}",    :":''"   )
+    assert_handles_key('{{:"}}',     :':"'    )
+  end
+
+  def test_str_containing_only_escaped_interpolation_is_handled_correctly
+    assert_equal 'abc {{x}}', compile_and_interpolate('abc \\{{x}}')
+  end
+
+  def test_handles_weired_strings
+    assert_equal '#{} a',         compile_and_interpolate('#{} {{a}}',        :a    => 'a')
+    assert_equal '"#{abc}"',      compile_and_interpolate('"#{ab{{a}}c}"',    :a    => '' )
+    assert_equal 'a}',            compile_and_interpolate('{{{a}}}',          :'{a' => 'a')
+    assert_equal '"',             compile_and_interpolate('"{{a}}',           :a    => '' )
+    assert_equal 'a{{a}}',        compile_and_interpolate('{{a}}\\{{a}}',     :a    => 'a')
+    assert_equal '\\{{a}}',       compile_and_interpolate('\\\\{{a}}')
+    assert_equal '\";eval("a")',  compile_and_interpolate('\";eval("{{a}}")', :a    => 'a')
+    assert_equal '\";eval("a")',  compile_and_interpolate('\";eval("a"){{a}}',:a    => '' )
+    assert_equal "\na",           compile_and_interpolate("\n{{a}}",          :a    => 'a')
+  end
+end
+
+class I18nBackendInterpolationCompilerTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::InterpolationCompiler
+  end
+  
+  include Tests::Api::Interpolation
+
+  def setup
+    I18n.backend = Backend.new
+    super
+  end
+  
+  # pre-compile default strings to make sure we are testing I18n::Backend::InterpolationCompiler
+  def interpolate(*args)
+    options = args.last.kind_of?(Hash) ? args.last : {}
+    if default_str = options[:default]
+      I18n::Backend::InterpolationCompiler::Compiler.compile_if_an_interpolation(default_str)
+    end
+    super
+  end
+  
+  # I kinda don't think this really is a correct behavior
+  undef :'test interpolation: given no values it does not alter the string'
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/metadata_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/metadata_test.rb
new file mode 100644
index 0000000..fd53969
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/metadata_test.rb
@@ -0,0 +1,67 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require 'i18n/backend/metadata'
+
+class I18nBackendMetadataTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Metadata
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    store_translations(:en, :foo => 'Hi {{name}}')
+  end
+
+  define_method "test: translation strings carry metadata" do
+    translation = I18n.t(:foo)
+    assert translation.respond_to?(:translation_metadata)
+    assert translation.translation_metadata.is_a?(Hash)
+  end
+
+  define_method "test: translate preserves metadata stored on original Strings" do
+    store_metadata(:foo, :bar, 'bar')
+    assert_equal 'bar', I18n.t(:foo).translation_metadata[:bar]
+  end
+
+  define_method "test: translate preserves metadata stored on original Strings (when interpolated)" do
+    store_metadata(:foo, :bar, 'bar')
+    assert_equal 'bar', I18n.t(:foo, :name => 'David').translation_metadata[:bar]
+  end
+
+  define_method "test: translate adds the locale to metadata on Strings" do
+    assert_equal :en, I18n.t(:foo, :locale => :en).translation_metadata[:locale]
+  end
+
+  define_method "test: translate adds the key to metadata on Strings" do
+    assert_equal :foo, I18n.t(:foo).translation_metadata[:key]
+  end
+
+  define_method "test: translate adds the default to metadata on Strings" do
+    assert_equal 'bar', I18n.t(:foo, :default => 'bar', :name => '').translation_metadata[:default]
+  end
+
+  define_method "test: translation adds the interpolation values to metadata on Strings" do
+    assert_equal({:name => 'David'}, I18n.t(:foo, :name => 'David').translation_metadata[:values])
+  end
+
+  define_method "test: interpolation adds the original string to metadata on Strings" do
+    assert_equal('Hi {{name}}', I18n.t(:foo, :name => 'David').translation_metadata[:original])
+  end
+
+  define_method "test: pluralizatoin adds the count to metadata on Strings" do
+    assert_equal(1, I18n.t(:missing, :count => 1, :default => { :one => 'foo' }).translation_metadata[:count])
+  end
+  
+  protected
+  
+    def translations
+      I18n.backend.instance_variable_get(:@translations)
+    end
+
+    def store_metadata(key, name, value)
+      translations[:en][key].translation_metadata[name] = value
+    end
+end
+
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/pluralization_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/pluralization_test.rb
new file mode 100644
index 0000000..f0bf4b7
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/pluralization_test.rb
@@ -0,0 +1,43 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require 'i18n/backend/pluralization'
+
+class I18nBackendPluralizationTest < Test::Unit::TestCase
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Pluralization
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    @rule = lambda { |n| n == 1 ? :one : n == 0 || (2..10).include?(n % 100) ? :few : (11..19).include?(n % 100) ? :many : :other }
+    store_translations(:foo, :i18n => { :plural => { :rule => @rule } })
+    @entry = { :zero => 'zero', :one => 'one', :few => 'few', :many => 'many', :other => 'other' }
+  end
+
+  define_method "test: pluralization picks a pluralizer from :'i18n.pluralize'" do
+    assert_equal @rule, I18n.backend.send(:pluralizer, :foo)
+  end
+
+  define_method "test: pluralization picks :one for 1" do
+    assert_equal 'one', I18n.t(:count => 1, :default => @entry, :locale => :foo)
+  end
+
+  define_method "test: pluralization picks :few for 2" do
+    assert_equal 'few', I18n.t(:count => 2, :default => @entry, :locale => :foo)
+  end
+
+  define_method "test: pluralization picks :many for 11" do
+    assert_equal 'many', I18n.t(:count => 11, :default => @entry, :locale => :foo)
+  end
+
+  define_method "test: pluralization picks zero for 0 if the key is contained in the data" do
+    assert_equal 'zero', I18n.t(:count => 0, :default => @entry, :locale => :foo)
+  end
+
+  define_method "test: pluralization picks few for 0 if the key is not contained in the data" do
+    @entry.delete(:zero)
+    assert_equal 'few', I18n.t(:count => 0, :default => @entry, :locale => :foo)
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/simple_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/simple_test.rb
new file mode 100644
index 0000000..c9a0324
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/backend/simple_test.rb
@@ -0,0 +1,77 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+class I18nBackendSimpleTest < Test::Unit::TestCase
+  def setup
+    I18n.backend = I18n::Backend::Simple.new
+    I18n.load_path = [locales_dir + '/en.yml']
+  end
+
+  # useful because this way we can use the backend with no key for interpolation/pluralization
+  define_method "test simple backend lookup: given nil as a key it returns nil" do
+    assert_nil I18n.backend.send(:lookup, :en, nil)
+  end
+  
+  # loading translations
+      
+  define_method "test simple load_translations: given an unknown file type it raises I18n::UnknownFileType" do
+    assert_raises(I18n::UnknownFileType) { I18n.backend.load_translations("#{locales_dir}/en.xml") }
+  end
+  
+  define_method "test simple load_translations: given a Ruby file name it does not raise anything" do
+    assert_nothing_raised { I18n.backend.load_translations("#{locales_dir}/en.rb") }
+  end
+  
+  define_method "test simple load_rb: loads data from a Ruby file" do
+    data = I18n.backend.send(:load_rb, "#{locales_dir}/en.rb")
+    assert_equal({ :en => { :fuh => { :bah => 'bas' } } }, data)
+  end
+
+  define_method "test simple load_yml: loads data from a YAML file" do
+    data = I18n.backend.send(:load_yml, "#{locales_dir}/en.yml")
+    assert_equal({ 'en' => { 'foo' => { 'bar' => 'baz' } } }, data)
+  end
+
+  define_method "test simple load_translations: loads data from known file formats" do
+    I18n.backend = I18n::Backend::Simple.new
+    I18n.backend.load_translations("#{locales_dir}/en.rb", "#{locales_dir}/en.yml")
+    expected = { :en => { :fuh => { :bah => "bas" }, :foo => { :bar => "baz" } } }
+    assert_equal expected, translations
+  end
+  
+  # storing translations
+
+  define_method "test simple store_translations: stores translations, ... no, really :-)" do
+    I18n.backend.store_translations :'en', :foo => 'bar'
+    assert_equal Hash[:'en', {:foo => 'bar'}], translations
+  end
+
+  define_method "test simple store_translations: deep_merges with existing translations" do
+    I18n.backend.store_translations :'en', :foo => {:bar => 'bar'}
+    I18n.backend.store_translations :'en', :foo => {:baz => 'baz'}
+    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], translations
+  end
+
+  define_method "test simple store_translations: converts the given locale to a Symbol" do
+    I18n.backend.store_translations 'en', :foo => 'bar'
+    assert_equal Hash[:'en', {:foo => 'bar'}], translations
+  end
+
+  define_method "test simple store_translations: converts keys to Symbols" do
+    I18n.backend.store_translations 'en', 'foo' => {'bar' => 'bar', 'baz' => 'baz'}
+    assert_equal Hash[:'en', {:foo => {:bar => 'bar', :baz => 'baz'}}], translations
+  end
+  
+  # reloading translations
+
+  define_method "test simple reload_translations: unloads translations" do
+    I18n.backend.reload!
+    assert_nil translations
+  end
+
+  define_method "test simple reload_translations: uninitializes the backend" do
+    I18n.backend.reload!
+    assert_equal I18n.backend.initialized?, false
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/core_ext/string/interpolate_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/core_ext/string/interpolate_test.rb
new file mode 100644
index 0000000..0906307
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/core_ext/string/interpolate_test.rb
@@ -0,0 +1,94 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../../test_helper')
+
+# thanks to Masao's String extensions these should work the same in
+# Ruby 1.8 (patched) and Ruby 1.9 (native)
+# some tests taken from Masao's tests
+# http://github.com/mutoh/gettext/blob/edbbe1fa8238fa12c7f26f2418403015f0270e47/test/test_string.rb
+
+class I18nCoreExtStringInterpolationTest < Test::Unit::TestCase
+  define_method "test: String interpolates a single argument" do
+    assert_equal "Masao", "%s" % "Masao"
+  end
+
+  define_method "test: String interpolates an array argument" do
+    assert_equal "1 message", "%d %s" % [1, 'message']
+  end
+
+  define_method "test: String interpolates a hash argument w/ named placeholders" do
+    assert_equal "Masao Mutoh", "%{first} %{last}" % { :first => 'Masao', :last => 'Mutoh' }
+  end
+
+  define_method "test: String interpolates a hash argument w/ named placeholders (reverse order)" do
+    assert_equal "Mutoh, Masao", "%{last}, %{first}" % { :first => 'Masao', :last => 'Mutoh' }
+  end
+
+  define_method "test: String interpolates named placeholders with sprintf syntax" do
+    assert_equal "10, 43.4", "%<integer>d, %<float>.1f" % {:integer => 10, :float => 43.4}
+  end
+
+  define_method "test: String interpolates named placeholders with sprintf syntax, does not recurse" do
+    assert_equal "%<not_translated>s", "%{msg}" % { :msg => '%<not_translated>s', :not_translated => 'should not happen' }
+  end
+
+  define_method "test: String interpolation does not replace anything when no placeholders are given" do
+    assert_equal("aaa", "aaa" % {:num => 1})
+    assert_equal("bbb", "bbb" % [1])
+  end
+
+  define_method "test: String interpolation sprintf behaviour equals Ruby 1.9 behaviour" do
+    assert_equal("1", "%<num>d" % {:num => 1})
+    assert_equal("0b1", "%<num>#b" % {:num => 1})
+    assert_equal("foo", "%<msg>s" % {:msg => "foo"})
+    assert_equal("1.000000", "%<num>f" % {:num => 1.0})
+    assert_equal("  1", "%<num>3.0f" % {:num => 1.0})
+    assert_equal("100.00", "%<num>2.2f" % {:num => 100.0})
+    assert_equal("0x64", "%<num>#x" % {:num => 100.0})
+    assert_raise(ArgumentError) { "%<num>,d" % {:num => 100} }
+    assert_raise(ArgumentError) { "%<num>/d" % {:num => 100} }
+  end
+
+  define_method "test: String interpolation old-style sprintf still works" do
+    assert_equal("foo 1.000000", "%s %f" % ["foo", 1.0])
+  end
+
+  define_method "test: String interpolation raises an ArgumentError when the string has extra placeholders (Array)" do
+    assert_raises(ArgumentError) do # Ruby 1.9 msg: "too few arguments"
+      "%s %s" % %w(Masao)
+    end
+  end
+
+  define_method "test: String interpolation raises a KeyError when the string has extra placeholders (Hash)" do
+    assert_raises(KeyError) do # Ruby 1.9 msg: "key not found"
+      "%{first} %{last}" % { :first => 'Masao' }
+    end
+  end
+
+  define_method "test: String interpolation does not raise when passed extra values (Array)" do
+    assert_nothing_raised do
+      assert_equal "Masao", "%s" % %w(Masao Mutoh)
+    end
+  end
+
+  define_method "test: String interpolation does not raise when passed extra values (Hash)" do
+    assert_nothing_raised do
+      assert_equal "Masao Mutoh", "%{first} %{last}" % { :first => 'Masao', :last => 'Mutoh', :salutation => 'Mr.' }
+    end
+  end
+
+  define_method "test: % acts as escape character in String interpolation" do
+    assert_equal "%{first}", "%%{first}" % { :first => 'Masao' }
+    assert_equal("% 1", "%% %<num>d" % {:num => 1.0})
+    assert_equal("%{num} %<num>d", "%%{num} %%<num>d" % {:num => 1})
+  end
+
+  def test_sprintf_mix_unformatted_and_formatted_named_placeholders
+    assert_equal("foo 1.000000", "%{name} %<num>f" % {:name => "foo", :num => 1.0})
+  end
+  
+  def test_string_interpolation_raises_an_argument_error_when_mixing_named_and_unnamed_placeholders
+    assert_raises(ArgumentError) { "%{name} %f" % [1.0] }
+    assert_raises(ArgumentError) { "%{name} %f" % [1.0, 2.0] }
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/api_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/api_test.rb
new file mode 100644
index 0000000..b9c724e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/api_test.rb
@@ -0,0 +1,201 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require 'i18n/backend/gettext'
+require 'i18n/helpers/gettext'
+
+include I18n::Helpers::Gettext
+
+class I18nGettextApiTest < Test::Unit::TestCase
+  def setup
+    I18n.locale = :en
+    I18n.backend.store_translations :de, {
+      'Hi Gettext!' => 'Hallo Gettext!',
+      'Sentence 1. Sentence 2.' => 'Satz 1. Satz 2.',
+      "An apple" => { :one => 'Ein Apfel', :other => '{{count}} pfel' },
+      :special => { "A special apple" => { :one => 'Ein spezieller Apfel', :other => '{{count}} spezielle pfel' } },
+      :foo => { :bar => 'bar-de' }
+    }
+  end
+
+  # gettext
+  def test_gettext_uses_msg_as_default
+    assert_equal 'Hi Gettext!', _('Hi Gettext!')
+  end
+
+  def test_gettext_uses_msg_as_key
+    I18n.locale = :de
+    assert_equal 'Hallo Gettext!', gettext('Hi Gettext!')
+    assert_equal 'Hallo Gettext!', _('Hi Gettext!')
+  end
+
+  def test_gettext_uses_msg_containing_dots_as_default
+    assert_equal 'Sentence 1. Sentence 2.', gettext('Sentence 1. Sentence 2.')
+    assert_equal 'Sentence 1. Sentence 2.', _('Sentence 1. Sentence 2.')
+  end
+
+  def test_gettext_uses_msg_containing_dots_as_key
+    I18n.locale = :de
+    assert_equal 'Satz 1. Satz 2.', gettext('Sentence 1. Sentence 2.')
+    assert_equal 'Satz 1. Satz 2.', _('Sentence 1. Sentence 2.')
+  end
+
+  # sgettext
+  def test_sgettext_defaults_to_the_last_token_of_a_scoped_msgid
+    assert_equal 'bar', sgettext('foo|bar')
+    assert_equal 'bar', s_('foo|bar')
+  end
+
+  def test_sgettext_looks_up_a_scoped_translation
+    I18n.locale = :de
+    assert_equal 'bar-de', sgettext('foo|bar')
+    assert_equal 'bar-de', s_('foo|bar')
+  end
+
+  # pgettext
+  def test_pgettext_defaults_to_msgid
+    assert_equal 'bar', pgettext('foo', 'bar')
+    assert_equal 'bar', p_('foo', 'bar')
+  end
+
+  def test_pgettext_looks_up_a_scoped_translation
+    I18n.locale = :de
+    assert_equal 'bar-de', pgettext('foo', 'bar')
+    assert_equal 'bar-de', p_('foo', 'bar')
+  end
+
+  # ngettext
+  def test_ngettext_looks_up_msg_id_as_default_singular
+    assert_equal 'An apple', ngettext('An apple', '{{count}} apples', 1)
+    assert_equal 'An apple', n_('An apple', '{{count}} apples', 1)
+  end
+
+  def test_ngettext_looks_up_msg_id_plural_as_default_plural
+    assert_equal '2 apples', ngettext('An apple', '{{count}} apples', 2)
+    assert_equal '2 apples', n_('An apple', '{{count}} apples', 2)
+  end
+
+  def test_ngettext_looks_up_a_singular
+    I18n.locale = :de
+    assert_equal 'Ein Apfel', ngettext('An apple', '{{count}} apples', 1)
+    assert_equal 'Ein Apfel', n_('An apple', '{{count}} apples', 1)
+  end
+
+  def test_ngettext_looks_up_a_plural
+    I18n.locale = :de
+    assert_equal '2 pfel', ngettext('An apple', '{{count}} apples', 2)
+    assert_equal '2 pfel', n_('An apple', '{{count}} apples', 2)
+  end
+
+  def test_ngettext_looks_up_msg_id_as_default_singular_with_alternative_syntax
+    assert_equal 'An apple', ngettext(['An apple', '{{count}} apples'], 1)
+    assert_equal 'An apple', n_(['An apple', '{{count}} apples'], 1)
+  end
+
+  def test_ngettext_looks_up_msg_id_plural_as_default_plural_with_alternative_syntax
+    assert_equal '2 apples', ngettext(['An apple', '{{count}} apples'], 2)
+    assert_equal '2 apples', n_(['An apple', '{{count}} apples'], 2)
+  end
+
+  def test_ngettext_looks_up_a_singular_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Ein Apfel', ngettext(['An apple', '{{count}} apples'], 1)
+    assert_equal 'Ein Apfel', n_(['An apple', '{{count}} apples'], 1)
+  end
+
+  def test_ngettext_looks_up_a_plural_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal '2 pfel', ngettext(['An apple', '{{count}} apples'], 2)
+    assert_equal '2 pfel', n_(['An apple', '{{count}} apples'], 2)
+  end
+
+  # nsgettext
+  def test_nsgettext_looks_up_msg_id_as_default_singular
+    assert_equal 'A special apple', nsgettext('special|A special apple', '{{count}} special apples', 1)
+    assert_equal 'A special apple', ns_('special|A special apple', '{{count}} special apples', 1)
+  end
+
+  def test_nsgettext_looks_up_msg_id_plural_as_default_plural
+    assert_equal '2 special apples', nsgettext('special|A special apple', '{{count}} special apples', 2)
+    assert_equal '2 special apples', ns_('special|A special apple', '{{count}} special apples', 2)
+  end
+
+  def test_nsgettext_looks_up_a_singular
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', nsgettext('special|A special apple', '{{count}} special apples', 1)
+    assert_equal 'Ein spezieller Apfel', ns_('special|A special apple', '{{count}} special apples', 1)
+  end
+
+  def test_nsgettext_looks_up_a_plural
+    I18n.locale = :de
+    assert_equal '2 spezielle pfel', nsgettext('special|A special apple', '{{count}} special apples', 2)
+    assert_equal '2 spezielle pfel', ns_('special|A special apple', '{{count}} special apples', 2)
+  end
+
+  def test_nsgettext_looks_up_msg_id_as_default_singular_with_alternative_syntax
+    assert_equal 'A special apple', nsgettext(['special|A special apple', '{{count}} special apples'], 1)
+    assert_equal 'A special apple', ns_(['special|A special apple', '{{count}} special apples'], 1)
+  end
+
+  def test_nsgettext_looks_up_msg_id_plural_as_default_plural_with_alternative_syntax
+    assert_equal '2 special apples', nsgettext(['special|A special apple', '{{count}} special apples'], 2)
+    assert_equal '2 special apples', ns_(['special|A special apple', '{{count}} special apples'], 2)
+  end
+
+  def test_nsgettext_looks_up_a_singular_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', nsgettext(['special|A special apple', '{{count}} special apples'], 1)
+    assert_equal 'Ein spezieller Apfel', ns_(['special|A special apple', '{{count}} special apples'], 1)
+  end
+
+  def test_nsgettext_looks_up_a_plural_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal '2 spezielle pfel', nsgettext(['special|A special apple', '{{count}} special apples'], 2)
+    assert_equal '2 spezielle pfel', ns_(['special|A special apple', '{{count}} special apples'], 2)
+  end
+
+  # npgettext
+  def test_npgettext_looks_up_msg_id_as_default_singular
+    assert_equal 'A special apple', npgettext('special', 'A special apple', '{{count}} special apples', 1)
+    assert_equal 'A special apple', np_('special', 'A special apple', '{{count}} special apples', 1)
+  end
+
+  def test_npgettext_looks_up_msg_id_plural_as_default_plural
+    assert_equal '2 special apples', npgettext('special', 'A special apple', '{{count}} special apples', 2)
+    assert_equal '2 special apples', np_('special', 'A special apple', '{{count}} special apples', 2)
+  end
+
+  def test_npgettext_looks_up_a_singular
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', npgettext('special', 'A special apple', '{{count}} special apples', 1)
+    assert_equal 'Ein spezieller Apfel', np_('special', 'A special apple', '{{count}} special apples', 1)
+  end
+
+  def test_npgettext_looks_up_a_plural
+    I18n.locale = :de
+    assert_equal '2 spezielle pfel', npgettext('special', 'A special apple', '{{count}} special apples', 2)
+    assert_equal '2 spezielle pfel', np_('special', 'A special apple', '{{count}} special apples', 2)
+  end
+
+  def test_npgettext_looks_up_msg_id_as_default_singular_with_alternative_syntax
+    assert_equal 'A special apple', npgettext('special', ['A special apple', '{{count}} special apples'], 1)
+    assert_equal 'A special apple', np_('special', ['A special apple', '{{count}} special apples'], 1)
+  end
+
+  def test_npgettext_looks_up_msg_id_plural_as_default_plural_with_alternative_syntax
+    assert_equal '2 special apples', npgettext('special', ['A special apple', '{{count}} special apples'], 2)
+    assert_equal '2 special apples', np_('special', ['A special apple', '{{count}} special apples'], 2)
+  end
+
+  def test_npgettext_looks_up_a_singular_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Ein spezieller Apfel', npgettext('special', ['A special apple', '{{count}} special apples'], 1)
+    assert_equal 'Ein spezieller Apfel', np_('special', ['A special apple', '{{count}} special apples'], 1)
+  end
+
+  def test_npgettext_looks_up_a_plural_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal '2 spezielle pfel', npgettext('special', ['A special apple', '{{count}} special apples'], 2)
+    assert_equal '2 spezielle pfel', np_('special', ['A special apple', '{{count}} special apples'], 2)
+  end
+end
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/backend_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/backend_test.rb
new file mode 100644
index 0000000..cf61b4e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/gettext/backend_test.rb
@@ -0,0 +1,91 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+require 'i18n/backend/gettext'
+require 'i18n/helpers/gettext'
+
+class I18nGettextBackendTest < Test::Unit::TestCase
+  include I18n::Helpers::Gettext
+
+  class Backend
+    include I18n::Backend::Base
+    include I18n::Backend::Gettext
+  end
+
+  def setup
+    I18n.backend = Backend.new
+    I18n.locale = :en
+    I18n.load_path = ["#{locales_dir}/de.po"]
+  end
+
+  def teardown
+    I18n.load_path = nil
+    I18n.backend = nil
+  end
+
+  def test_backend_loads_po_file
+    I18n.backend.send(:init_translations)
+    assert I18n.backend.send(:translations)[:de][:"Axis"]
+  end
+
+  def test_looks_up_a_translation
+    I18n.locale = :de
+    assert_equal 'Auto', gettext('car')
+  end
+
+  def test_uses_default_translation
+    assert_equal 'car', gettext('car')
+  end
+
+  def test_looks_up_a_namespaced_translation
+    I18n.locale = :de
+    assert_equal 'Rderzahl', sgettext('Car|Wheels count')
+    assert_equal 'Rderzahl', pgettext('Car', 'Wheels count')
+  end
+
+  def test_uses_namespaced_default_translation
+    assert_equal 'Wheels count', sgettext('Car|Wheels count')
+    assert_equal 'Wheels count', pgettext('Car', 'Wheels count')
+  end
+
+  def test_pluralizes_entry
+    I18n.locale = :de
+    assert_equal 'Achse', ngettext('Axis', 'Axis', 1)
+    assert_equal 'Achsen', ngettext('Axis', 'Axis', 2)
+  end
+
+  def test_pluralizes_default_entry
+    assert_equal 'Axis', ngettext('Axis', 'Axis', 1)
+    assert_equal 'Axis', ngettext('Axis', 'Axis', 2)
+  end
+
+  def test_pluralizes_namespaced_entry
+    I18n.locale = :de
+    assert_equal 'Rad',   nsgettext('Car|wheel', 'wheels', 1)
+    assert_equal 'Rder', nsgettext('Car|wheel', 'wheels', 2)
+    assert_equal 'Rad',   npgettext('Car', 'wheel', 'wheels', 1)
+    assert_equal 'Rder', npgettext('Car', 'wheel', 'wheels', 2)
+  end
+
+  def test_pluralizes_namespaced_default_entry
+    assert_equal 'wheel',  nsgettext('Car|wheel', 'wheels', 1)
+    assert_equal 'wheels', nsgettext('Car|wheel', 'wheels', 2)
+    assert_equal 'wheel',  npgettext('Car', 'wheel', 'wheels', 1)
+    assert_equal 'wheels', npgettext('Car', 'wheel', 'wheels', 2)
+  end
+
+  def test_pluralizes_namespaced_entry_with_alternative_syntax
+    I18n.locale = :de
+    assert_equal 'Rad',   nsgettext(['Car|wheel', 'wheels'], 1)
+    assert_equal 'Rder', nsgettext(['Car|wheel', 'wheels'], 2)
+    assert_equal 'Rad',   npgettext('Car', ['wheel', 'wheels'], 1)
+    assert_equal 'Rder', npgettext('Car', ['wheel', 'wheels'], 2)
+  end
+  
+  def test_ngettextpluralizes_entry_with_dots
+    I18n.locale = :de
+    assert_equal 'Auf 1 Achse.', n_("On %{count} wheel.", "On %{count} wheels.", 1)
+    assert_equal 'Auf 2 Achsen.', n_("On %{count} wheel.", "On %{count} wheels.", 2)
+  end
+  
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_exceptions_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_exceptions_test.rb
new file mode 100644
index 0000000..e492520
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_exceptions_test.rb
@@ -0,0 +1,97 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../test_helper')
+
+class I18nExceptionsTest < Test::Unit::TestCase
+  def test_invalid_locale_stores_locale
+    force_invalid_locale
+  rescue I18n::ArgumentError => e
+    assert_nil e.locale
+  end
+
+  def test_invalid_locale_message
+    force_invalid_locale
+  rescue I18n::ArgumentError => e
+    assert_equal 'nil is not a valid locale', e.message
+  end
+
+  def test_missing_translation_data_stores_locale_key_and_options
+    force_missing_translation_data
+  rescue I18n::ArgumentError => e
+    options = {:scope => :bar}
+    assert_equal 'de', e.locale
+    assert_equal :foo, e.key
+    assert_equal options, e.options
+  end
+
+  def test_missing_translation_data_message
+    force_missing_translation_data
+  rescue I18n::ArgumentError => e
+    assert_equal 'translation missing: de, bar, foo', e.message
+  end
+
+  def test_invalid_pluralization_data_stores_entry_and_count
+    force_invalid_pluralization_data
+  rescue I18n::ArgumentError => e
+    assert_equal [:bar], e.entry
+    assert_equal 1, e.count
+  end
+
+  def test_invalid_pluralization_data_message
+    force_invalid_pluralization_data
+  rescue I18n::ArgumentError => e
+    assert_equal 'translation data [:bar] can not be used with :count => 1', e.message
+  end
+
+  def test_missing_interpolation_argument_stores_key_and_string
+    assert_raises(I18n::MissingInterpolationArgument) { force_missing_interpolation_argument } 
+    force_missing_interpolation_argument
+  rescue I18n::ArgumentError => e
+    # assert_equal :bar, e.key
+    assert_equal "{{bar}}", e.string
+  end
+
+  def test_missing_interpolation_argument_message
+    force_missing_interpolation_argument
+  rescue I18n::ArgumentError => e
+    assert_equal 'missing interpolation argument in "{{bar}}" ({:baz=>"baz"} given)', e.message
+  end
+
+  def test_reserved_interpolation_key_stores_key_and_string
+    force_reserved_interpolation_key
+  rescue I18n::ArgumentError => e
+    assert_equal :scope, e.key
+    assert_equal "{{scope}}", e.string
+  end
+
+  def test_reserved_interpolation_key_message
+    force_reserved_interpolation_key
+  rescue I18n::ArgumentError => e
+    assert_equal 'reserved key :scope used in "{{scope}}"', e.message
+  end
+
+  private
+    def force_invalid_locale
+      I18n.backend.translate nil, :foo
+    end
+
+    def force_missing_translation_data
+      I18n.backend.store_translations 'de', :bar => nil
+      I18n.backend.translate 'de', :foo, :scope => :bar
+    end
+
+    def force_invalid_pluralization_data
+      I18n.backend.store_translations 'de', :foo => [:bar]
+      I18n.backend.translate 'de', :foo, :count => 1
+    end
+
+    def force_missing_interpolation_argument
+      I18n.backend.store_translations 'de', :foo => "{{bar}}"
+      I18n.backend.translate 'de', :foo, :baz => 'baz'
+    end
+
+    def force_reserved_interpolation_key
+      I18n.backend.store_translations 'de', :foo => "{{scope}}"
+      I18n.backend.translate 'de', :foo, :baz => 'baz'
+    end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_load_path_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_load_path_test.rb
new file mode 100644
index 0000000..3b92528
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_load_path_test.rb
@@ -0,0 +1,23 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../test_helper')
+
+class I18nLoadPathTest < Test::Unit::TestCase
+  # include Tests::Backend::Simple::Setup::Base
+  
+  def setup
+    I18n.locale = :en
+    I18n.backend = I18n::Backend::Simple.new
+    store_translations(:en, :foo => {:bar => 'bar', :baz => 'baz'})
+  end
+
+  def test_nested_load_paths_do_not_break_locale_loading
+    I18n.load_path = [[locales_dir + '/en.yml']]
+    assert_equal "baz", I18n.t(:'foo.bar')
+  end
+
+  def test_adding_arrays_of_filenames_to_load_path_do_not_break_locale_loading
+    I18n.load_path << Dir[locales_dir + '/*.{rb,yml}']
+    assert_equal "baz", I18n.t(:'foo.bar')
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_test.rb
new file mode 100644
index 0000000..2594837
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/i18n_test.rb
@@ -0,0 +1,172 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../test_helper')
+
+class I18nTest < Test::Unit::TestCase
+  def setup
+    I18n.backend.store_translations :'en', {
+      :currency => {
+        :format => {
+          :separator => '.',
+          :delimiter => ',',
+        }
+      }
+    }
+  end
+
+  def test_uses_simple_backend_set_by_default
+    assert I18n.backend.is_a?(I18n::Backend::Simple)
+  end
+
+  def test_can_set_backend
+    assert_nothing_raised { I18n.backend = self }
+    assert_equal self, I18n.backend
+    I18n.backend = I18n::Backend::Simple.new
+  end
+
+  def test_uses_en_us_as_default_locale_by_default
+    assert_equal :en, I18n.default_locale
+  end
+
+  def test_can_set_default_locale
+    assert_nothing_raised { I18n.default_locale = 'de' }
+    assert_equal :de, I18n.default_locale
+    I18n.default_locale = :en
+  end
+
+  def test_uses_default_locale_as_locale_by_default
+    assert_equal I18n.default_locale, I18n.locale
+  end
+
+  def test_can_set_locale_to_thread_current
+    assert_nothing_raised { I18n.locale = 'de' }
+    assert_equal :de, I18n.locale
+    assert_equal :de, Thread.current[:locale]
+    I18n.locale = :en
+  end
+
+  def test_defaults_to_dot_as_separator
+    assert_equal '.', I18n.default_separator
+  end
+
+  def test_can_set_default_separator
+    assert_nothing_raised { I18n.default_separator = "\001" }
+    I18n.default_separator = '.' # revert it
+  end
+
+  def test_normalize_keys
+    assert_equal [:en, :foo, :bar], I18n.send(:normalize_translation_keys, :en, :bar, :foo)
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, :'baz.buz', :'foo.bar')
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, 'baz.buz', 'foo.bar')
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, %w(baz buz), %w(foo bar))
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, [:baz, :buz], [:foo, :bar])
+  end
+
+  def test_normalize_keys_should_not_attempt_to_sym_on_empty_string
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, :'baz.buz', :'foo..bar')
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, :'baz.buz', :'foo......bar')
+  end
+
+  def test_uses_passed_separator_to_normalize_keys
+    assert_equal [:en, :foo, :bar, :baz, :buz], I18n.send(:normalize_translation_keys, :en, :'baz|buz', :'foo|bar', '|')
+  end
+
+  def test_can_set_exception_handler
+    assert_nothing_raised { I18n.exception_handler = :custom_exception_handler }
+    I18n.exception_handler = :default_exception_handler # revert it
+  end
+
+  with_mocha do
+    def test_uses_custom_exception_handler
+      I18n.exception_handler = :custom_exception_handler
+      I18n.expects(:custom_exception_handler)
+      I18n.translate :bogus
+      I18n.exception_handler = :default_exception_handler # revert it
+    end
+
+    def test_delegates_translate_to_backend
+      I18n.backend.expects(:translate).with 'de', :foo, {}
+      I18n.translate :foo, :locale => 'de'
+    end
+
+    def test_delegates_localize_to_backend
+      I18n.backend.expects(:localize).with 'de', :whatever, :default
+      I18n.localize :whatever, :locale => 'de'
+    end
+
+    def test_translate_given_no_locale_uses_i18n_locale
+      I18n.backend.expects(:translate).with :en, :foo, {}
+      I18n.translate :foo
+    end
+  end
+
+  def test_translate_on_nested_symbol_keys_works
+    assert_equal ".", I18n.t(:'currency.format.separator')
+  end
+
+  def test_translate_with_nested_string_keys_works
+    assert_equal ".", I18n.t('currency.format.separator')
+  end
+
+  def test_translate_with_array_as_scope_works
+    assert_equal ".", I18n.t(:separator, :scope => %w(currency format))
+  end
+
+  def test_translate_with_array_containing_dot_separated_strings_as_scope_works
+    assert_equal ".", I18n.t(:separator, :scope => ['currency.format'])
+  end
+
+  def test_translate_with_key_array_and_dot_separated_scope_works
+    assert_equal [".", ","], I18n.t(%w(separator delimiter), :scope => 'currency.format')
+  end
+
+  def test_translate_with_dot_separated_key_array_and_scope_works
+    assert_equal [".", ","], I18n.t(%w(format.separator format.delimiter), :scope => 'currency')
+  end
+
+  with_mocha do
+    def test_translate_with_options_using_scope_works
+      I18n.backend.expects(:translate).with('de', :precision, :scope => :"currency.format")
+      I18n.with_options :locale => 'de', :scope => :'currency.format' do |locale|
+        locale.t :precision
+      end
+    end
+  end
+
+  # def test_translate_given_no_args_raises_missing_translation_data
+  #   assert_equal "translation missing: en, no key", I18n.t
+  # end
+
+  def test_translate_given_a_bogus_key_raises_missing_translation_data
+    assert_equal "translation missing: en, bogus", I18n.t(:bogus)
+  end
+
+  def test_localize_nil_raises_argument_error
+    assert_raises(I18n::ArgumentError) { I18n.l nil }
+  end
+
+  def test_localize_object_raises_argument_error
+    assert_raises(I18n::ArgumentError) { I18n.l Object.new }
+  end
+
+  def test_proc_exception_handler
+    I18n.exception_handler = Proc.new { |exception, locale, key, options|
+      "No exception here! [Proc handler]"
+    }
+    assert_equal "No exception here! [Proc handler]", I18n.translate(:test_proc_handler)
+  ensure
+    I18n.exception_handler = :default_exception_handler
+  end
+
+  def test_class_exception_handler
+    I18n.exception_handler = Class.new do
+      def call(exception, locale, key, options)
+        "No exception here! [Class handler]"
+      end
+    end.new
+    assert_equal "No exception here! [Class handler]", I18n.translate(:test_class_handler)
+  ensure
+    I18n.exception_handler = :default_exception_handler
+  end
+
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/fallbacks_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/fallbacks_test.rb
new file mode 100644
index 0000000..573b524
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/fallbacks_test.rb
@@ -0,0 +1,126 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../test_helper')
+
+include I18n::Locale
+
+class I18nFallbacksDefaultsTest < Test::Unit::TestCase
+  def teardown
+    I18n.default_locale = :en
+  end
+
+  test "defaults reflect the I18n.default_locale if no default has been set manually" do
+    I18n.default_locale = :'en-US'
+    fallbacks = Fallbacks.new
+    assert_equal [:'en-US', :en], fallbacks.defaults
+  end
+
+  test "defaults reflect a manually passed default locale if any" do
+    fallbacks = Fallbacks.new(:'fi-FI')
+    assert_equal [:'fi-FI', :fi], fallbacks.defaults
+    I18n.default_locale = :'de-DE'
+    assert_equal [:'fi-FI', :fi], fallbacks.defaults
+  end
+
+  test "defaults allows to set multiple defaults" do
+    fallbacks = Fallbacks.new(:'fi-FI', :'se-FI')
+    assert_equal [:'fi-FI', :fi, :'se-FI', :se], fallbacks.defaults
+  end
+end
+
+class I18nFallbacksComputationTest < Test::Unit::TestCase
+  def setup
+    @fallbacks = Fallbacks.new(:'en-US')
+  end
+
+  test "with no mappings defined it returns [:es, :en-US] for :es" do
+    assert_equal [:es, :"en-US", :en], @fallbacks[:es]
+  end
+
+  test "with no mappings defined it returns [:es-ES, :es, :en-US] for :es-ES" do
+    assert_equal [:"es-ES", :es, :"en-US", :en], @fallbacks[:"es-ES"]
+  end
+
+  test "with no mappings defined it returns [:es-MX, :es, :en-US] for :es-MX" do
+    assert_equal [:"es-MX", :es, :"en-US", :en], @fallbacks[:"es-MX"]
+  end
+
+  test "with no mappings defined it returns [:es-Latn-ES, :es-Latn, :es, :en-US] for :es-Latn-ES" do
+    assert_equal [:"es-Latn-ES", :"es-Latn", :es, :"en-US", :en], @fallbacks[:'es-Latn-ES']
+  end
+
+  test "with no mappings defined it returns [:en, :en-US] for :en" do
+    assert_equal [:en, :"en-US"], @fallbacks[:en]
+  end
+
+  test "with no mappings defined it returns [:en-US, :en] for :en-US (special case: locale == default)" do
+    assert_equal [:"en-US", :en], @fallbacks[:"en-US"]
+  end
+
+  # Most people who speak Catalan also live in Spain, so it is safe to assume
+  # that they also speak Spanish as spoken in Spain.
+  test "with a Catalan mapping defined it returns [:ca, :es-ES, :es, :en-US] for :ca" do
+    @fallbacks.map(:ca => :"es-ES")
+    assert_equal [:ca, :"es-ES", :es, :"en-US", :en], @fallbacks[:ca]
+  end
+
+  test "with a Catalan mapping defined it returns [:ca-ES, :ca, :es-ES, :es, :en-US] for :ca-ES" do
+    @fallbacks.map(:ca => :"es-ES")
+    assert_equal [:"ca-ES", :ca, :"es-ES", :es, :"en-US", :en], @fallbacks[:"ca-ES"]
+  end
+
+  # People who speak Arabic as spoken in Palestine often times also speak
+  # Hebrew as spoken in Israel. However it is in no way safe to assume that
+  # everybody who speaks Arabic also speaks Hebrew.
+
+  test "with a Hebrew mapping defined it returns [:ar, :en-US] for :ar" do
+    @fallbacks.map(:"ar-PS" => :"he-IL")
+    assert_equal [:ar, :"en-US", :en], @fallbacks[:ar]
+  end
+
+  test "with a Hebrew mapping defined it returns [:ar-EG, :ar, :en-US] for :ar-EG" do
+    @fallbacks.map(:"ar-PS" => :"he-IL")
+    assert_equal [:"ar-EG", :ar, :"en-US", :en], @fallbacks[:"ar-EG"]
+  end
+
+  test "with a Hebrew mapping defined it returns [:ar-PS, :ar, :he-IL, :he, :en-US] for :ar-PS" do
+    @fallbacks.map(:"ar-PS" => :"he-IL")
+    assert_equal [:"ar-PS", :ar, :"he-IL", :he, :"en-US", :en], @fallbacks[:"ar-PS"]
+  end
+
+  # Sami people live in several scandinavian countries. In Finnland many people
+  # know Swedish and Finnish. Thus, it can be assumed that Sami living in
+  # Finnland also speak Swedish and Finnish.
+
+  test "with a Sami mapping defined it returns [:sms-FI, :sms, :se-FI, :se, :fi-FI, :fi, :en-US] for :sms-FI" do
+    @fallbacks.map(:sms => [:"se-FI", :"fi-FI"])
+    assert_equal [:"sms-FI", :sms, :"se-FI", :se, :"fi-FI", :fi, :"en-US", :en], @fallbacks[:"sms-FI"]
+  end
+
+  # Austrian people understand German as spoken in Germany
+
+  test "with a German mapping defined it returns [:de, :en-US] for de" do
+    @fallbacks.map(:"de-AT" => :"de-DE")
+    assert_equal [:de, :"en-US", :en], @fallbacks[:"de"]
+  end
+
+  test "with a German mapping defined it returns [:de-DE, :de, :en-US] for de-DE" do
+    @fallbacks.map(:"de-AT" => :"de-DE")
+    assert_equal [:"de-DE", :de, :"en-US", :en], @fallbacks[:"de-DE"]
+  end
+
+  test "with a German mapping defined it returns [:de-AT, :de, :de-DE, :en-US] for de-AT" do
+    @fallbacks.map(:"de-AT" => :"de-DE")
+    assert_equal [:"de-AT", :de, :"de-DE", :"en-US", :en], @fallbacks[:"de-AT"]
+  end
+
+  # Mapping :de => :en, :he => :en
+
+  test "with a mapping :de => :en, :he => :en defined it returns [:de, :en] for :de" do
+    assert_equal [:de, :"en-US", :en], @fallbacks[:de]
+  end
+
+  test "with a mapping :de => :en, :he => :en defined it [:he, :en] for :de" do
+    assert_equal [:he, :"en-US", :en], @fallbacks[:he]
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/rfc4646_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/rfc4646_test.rb
new file mode 100644
index 0000000..3eae4dd
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/rfc4646_test.rb
@@ -0,0 +1,143 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../../test_helper')
+
+class I18nLocaleTagRfc4646ParserTest < Test::Unit::TestCase
+  include I18n::Locale
+
+  test "Rfc4646::Parser given a valid tag 'de' returns an array of subtags" do
+    assert_equal ['de', nil, nil, nil, nil, nil, nil], Tag::Rfc4646::Parser.match('de')
+  end
+
+  test "Rfc4646::Parser given a valid tag 'de' returns an array of subtags" do
+    assert_equal ['de', nil, 'DE', nil, nil, nil, nil], Tag::Rfc4646::Parser.match('de-DE')
+  end
+
+  test "Rfc4646::Parser given a valid lowercase tag 'de-latn-de-variant-x-phonebk' returns an array of subtags" do
+    assert_equal ['de', 'latn', 'de', 'variant', nil, 'x-phonebk', nil], Tag::Rfc4646::Parser.match('de-latn-de-variant-x-phonebk')
+  end
+
+  test "Rfc4646::Parser given a valid uppercase tag 'DE-LATN-DE-VARIANT-X-PHONEBK' returns an array of subtags" do
+    assert_equal ['DE', 'LATN', 'DE', 'VARIANT', nil, 'X-PHONEBK', nil], Tag::Rfc4646::Parser.match('DE-LATN-DE-VARIANT-X-PHONEBK')
+  end
+
+  test "Rfc4646::Parser given an invalid tag 'a-DE' it returns false" do
+    assert_equal false, Tag::Rfc4646::Parser.match('a-DE')
+  end
+
+  test "Rfc4646::Parser given an invalid tag 'de-419-DE' it returns false" do
+    assert_equal false, Tag::Rfc4646::Parser.match('de-419-DE')
+  end
+end
+
+# Tag for the locale 'de-Latn-DE-Variant-a-ext-x-phonebk-i-klingon'
+
+class I18nLocaleTagSubtagsTest < Test::Unit::TestCase
+  include I18n::Locale
+
+  def setup
+    subtags = %w(de Latn DE variant a-ext x-phonebk i-klingon)
+    @tag = Tag::Rfc4646.new *subtags
+  end
+
+  test "returns 'de' as the language subtag in lowercase" do
+    assert_equal 'de', @tag.language
+  end
+
+  test "returns 'Latn' as the script subtag in titlecase" do
+    assert_equal 'Latn', @tag.script
+  end
+
+  test "returns 'DE' as the region subtag in uppercase" do
+    assert_equal 'DE', @tag.region
+  end
+
+  test "returns 'variant' as the variant subtag in lowercase" do
+    assert_equal 'variant', @tag.variant
+  end
+
+  test "returns 'a-ext' as the extension subtag" do
+    assert_equal 'a-ext', @tag.extension
+  end
+
+  test "returns 'x-phonebk' as the privateuse subtag" do
+    assert_equal 'x-phonebk', @tag.privateuse
+  end
+
+  test "returns 'i-klingon' as the grandfathered subtag" do
+    assert_equal 'i-klingon', @tag.grandfathered
+  end
+
+  test "returns a formatted tag string from #to_s" do
+    assert_equal 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon', @tag.to_s
+  end
+
+  test "returns an array containing the formatted subtags from #to_a" do
+    assert_equal %w(de Latn DE variant a-ext x-phonebk i-klingon), @tag.to_a
+  end
+end
+
+# Tag inheritance
+
+class I18nLocaleTagSubtagsTest < Test::Unit::TestCase
+  test "#parent returns 'de-Latn-DE-variant-a-ext-x-phonebk' as the parent of 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk i-klingon)
+    assert_equal 'de-Latn-DE-variant-a-ext-x-phonebk', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn-DE-variant-a-ext' as the parent of 'de-Latn-DE-variant-a-ext-x-phonebk'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk)
+    assert_equal 'de-Latn-DE-variant-a-ext', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn-DE-variant' as the parent of 'de-Latn-DE-variant-a-ext'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext)
+    assert_equal 'de-Latn-DE-variant', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn-DE' as the parent of 'de-Latn-DE-variant'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant)
+    assert_equal 'de-Latn-DE', tag.parent.to_s
+  end
+
+  test "#parent returns 'de-Latn' as the parent of 'de-Latn-DE'" do
+    tag = Tag::Rfc4646.new *%w(de Latn DE)
+    assert_equal 'de-Latn', tag.parent.to_s
+  end
+
+  test "#parent returns 'de' as the parent of 'de-Latn'" do
+    tag = Tag::Rfc4646.new *%w(de Latn)
+    assert_equal 'de', tag.parent.to_s
+  end
+
+  # TODO RFC4647 says: "If no language tag matches the request, the "default" value is returned."
+  # where should we set the default language?
+  # test "#parent returns '' as the parent of 'de'" do
+  #   tag = Tag::Rfc4646.new *%w(de)
+  #   assert_equal '', tag.parent.to_s
+  # end
+
+  test "#parent returns an array of 5 parents for 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon'" do
+    parents = %w(de-Latn-DE-variant-a-ext-x-phonebk-i-klingon
+                 de-Latn-DE-variant-a-ext-x-phonebk
+                 de-Latn-DE-variant-a-ext
+                 de-Latn-DE-variant
+                 de-Latn-DE
+                 de-Latn
+                 de)
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk i-klingon)
+    assert_equal parents, tag.self_and_parents.map{|tag| tag.to_s}
+  end
+
+  test "returns an array of 5 parents for 'de-Latn-DE-variant-a-ext-x-phonebk-i-klingon'" do
+    parents = %w(de-Latn-DE-variant-a-ext-x-phonebk-i-klingon
+                 de-Latn-DE-variant-a-ext-x-phonebk
+                 de-Latn-DE-variant-a-ext
+                 de-Latn-DE-variant
+                 de-Latn-DE
+                 de-Latn
+                 de)
+    tag = Tag::Rfc4646.new *%w(de Latn DE variant a-ext x-phonebk i-klingon)
+    assert_equal parents, tag.self_and_parents.map{|tag| tag.to_s}
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/simple_test.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/simple_test.rb
new file mode 100644
index 0000000..b84febe
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/cases/locale/tag/simple_test.rb
@@ -0,0 +1,33 @@
+# encoding: utf-8
+
+require File.expand_path(File.dirname(__FILE__) + '/../../../test_helper')
+
+class I18nLocaleTagSimpleTest < Test::Unit::TestCase
+  include I18n::Locale
+
+  test "returns 'de' as the language subtag in lowercase" do
+    assert_equal %w(de Latn DE), Tag::Simple.new('de-Latn-DE').subtags
+  end
+
+  test "returns a formatted tag string from #to_s" do
+    assert_equal 'de-Latn-DE', Tag::Simple.new('de-Latn-DE').to_s
+  end
+
+  test "returns an array containing the formatted subtags from #to_a" do
+    assert_equal %w(de Latn DE), Tag::Simple.new('de-Latn-DE').to_a
+  end
+
+  # Tag inheritance
+
+  test "#parent returns 'de-Latn' as the parent of 'de-Latn-DE'" do
+    assert_equal 'de-Latn', Tag::Simple.new('de-Latn-DE').parent.to_s
+  end
+
+  test "#parent returns 'de' as the parent of 'de-Latn'" do
+    assert_equal 'de', Tag::Simple.new('de-Latn').parent.to_s
+  end
+
+  test "#self_and_parents returns an array of 3 tags for 'de-Latn-DE'" do
+    assert_equal %w(de-Latn-DE de-Latn de), Tag::Simple.new('de-Latn-DE').self_and_parents.map { |tag| tag.to_s}
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/de.po b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/de.po
new file mode 100644
index 0000000..c162e87
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/de.po
@@ -0,0 +1,72 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: version 0.0.1\n"
+"POT-Creation-Date: 2009-02-26 19:50+0100\n"
+"PO-Revision-Date: 2009-02-18 14:53+0100\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
+
+# #: app/helpers/translation_helper.rb:3
+# msgid "%{relative_time} ago"
+# msgstr "vor %{relative_time}"
+
+#: app/views/cars/show.html.erb:5
+msgid "Axis"
+msgid_plural "Axis"
+msgstr[0] "Achse"
+msgstr[1] "Achsen"
+
+#: app/controllers/cars_controller.rb:47
+msgid "Car was successfully created."
+msgstr "Auto wurde erfolgreich gespeichert"
+
+#: app/controllers/cars_controller.rb:64
+msgid "Car was successfully updated."
+msgstr "Auto wurde erfolgreich aktualisiert"
+
+#: app/views/cars/show.html.erb:1 locale/model_attributes.rb:3
+msgid "Car|Model"
+msgstr "Modell"
+
+#: app/views/cars/show.html.erb:3 locale/model_attributes.rb:4
+msgid "Car|Wheels count"
+msgstr "Rderzahl"
+
+#: app/views/cars/show.html.erb:7
+msgid "Created"
+msgstr "Erstellt"
+
+#: app/views/cars/show.html.erb:9
+msgid "Month"
+msgstr "Monat"
+
+#: locale/model_attributes.rb:2
+msgid "car"
+msgstr "Auto"
+
+#: locale/testlog_phrases.rb:2
+msgid "this is a dynamic translation which was found thorugh gettext_test_log!"
+msgstr ""
+"Dies ist eine dynamische bersetzung, die durch gettext_test_log "
+"gefunden wurde!"
+
+#: app/views/cars/nowhere_really
+msgid "Car|wheel"
+msgid_plural "Car|wheels"
+msgstr[0] "Rad"
+msgstr[1] "Rder"
+
+msgid "On %{count} wheel."
+msgid_plural "On %{count} wheels."
+msgstr[0] "Auf %{count} Achse."
+msgstr[1] "Auf %{count} Achsen."
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.rb
new file mode 100644
index 0000000..e847d10
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.rb
@@ -0,0 +1,3 @@
+# encoding: utf-8
+
+{ :en => { :fuh => { :bah => "bas" } } }
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.yml b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.yml
new file mode 100644
index 0000000..25f5bb6
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/en.yml
@@ -0,0 +1,3 @@
+en:
+  foo:
+    bar: baz
\ No newline at end of file
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/plurals.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/plurals.rb
new file mode 100644
index 0000000..d1ea34e
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/fixtures/locales/plurals.rb
@@ -0,0 +1,113 @@
+# encoding: utf-8
+
+{
+  :af => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :am => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :ar => { :i18n => { :plural => { :keys => [:zero, :one, :two, :few, :many, :other], :rule => lambda { |n| n == 0 ? :zero : n == 1 ? :one : n == 2 ? :two : [3, 4, 5, 6, 7, 8, 9, 10].include?(n % 100) ? :few : [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99].include?(n % 100) ? :many : :other } } } },
+  :az => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :be => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :bg => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :bh => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :bn => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :bo => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :bs => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :ca => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :cs => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : [2, 3, 4].include?(n) ? :few : :other } } } },
+  :cy => { :i18n => { :plural => { :keys => [:one, :two, :many, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : n == 8 || n == 11 ? :many : :other } } } },
+  :da => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :de => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :dz => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :el => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :en => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :eo => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :es => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :et => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :eu => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fa => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :fi => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fil => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :fo => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fr => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n && n != 2 ? :one : :other } } } },
+  :fur => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :fy => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ga => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :gl => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :gu => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :guw => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :ha => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :he => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :hi => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :hr => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :hu => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :id => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :is => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :it => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :iw => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ja => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :jv => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ka => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :km => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :kn => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ko => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ku => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :lb => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ln => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :lt => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n % 10 == 1 && ![11, 12, 13, 14, 15, 16, 17, 18, 19].include?(n % 100) ? :one : [2, 3, 4, 5, 6, 7, 8, 9].include?(n % 10) && ![11, 12, 13, 14, 15, 16, 17, 18, 19].include?(n % 100) ? :few : :other } } } },
+  :lv => { :i18n => { :plural => { :keys => [:zero, :one, :other], :rule => lambda { |n| n == 0 ? :zero : n % 10 == 1 && n % 100 != 11 ? :one : :other } } } },
+  :mg => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :mk => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n % 10 == 1 ? :one : :other } } } },
+  :ml => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :mn => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :mo => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : n == 0 ? :few : :other } } } },
+  :mr => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ms => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :mt => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n == 1 ? :one : n == 0 || [2, 3, 4, 5, 6, 7, 8, 9, 10].include?(n % 100) ? :few : [11, 12, 13, 14, 15, 16, 17, 18, 19].include?(n % 100) ? :many : :other } } } },
+  :my => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :nah => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nb => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ne => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nl => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nn => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :no => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :nso => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :om => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :or => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pa => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pap => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pl => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) && ![22, 23, 24].include?(n % 100) ? :few : :other } } } },
+  :ps => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :pt => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :"pt-PT" => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ro => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : n == 0 ? :few : :other } } } },
+  :ru => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :se => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :sh => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :sk => { :i18n => { :plural => { :keys => [:one, :few, :other], :rule => lambda { |n| n == 1 ? :one : [2, 3, 4].include?(n) ? :few : :other } } } },
+  :sl => { :i18n => { :plural => { :keys => [:one, :two, :few, :other], :rule => lambda { |n| n % 100 == 1 ? :one : n % 100 == 2 ? :two : [3, 4].include?(n % 100) ? :few : :other } } } },
+  :sma => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :smi => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :smj => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :smn => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :sms => { :i18n => { :plural => { :keys => [:one, :two, :other], :rule => lambda { |n| n == 1 ? :one : n == 2 ? :two : :other } } } },
+  :so => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :sq => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :sr => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :sv => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :sw => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :ta => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :te => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :th => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :ti => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :tk => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :tl => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :to => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :tr => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :uk => { :i18n => { :plural => { :keys => [:one, :few, :many, :other], :rule => lambda { |n| n % 10 == 1 && n % 100 != 11 ? :one : [2, 3, 4].include?(n % 10) && ![12, 13, 14].include?(n % 100) ? :few : n % 10 == 0 || [5, 6, 7, 8, 9].include?(n % 10) || [11, 12, 13, 14].include?(n % 100) ? :many : :other } } } },
+  :ur => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } },
+  :vi => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :wa => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| [0, 1].include?(n) ? :one : :other } } } },
+  :yo => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :zh => { :i18n => { :plural => { :keys => [:other], :rule => lambda { |n| :other } } } },
+  :zu => { :i18n => { :plural => { :keys => [:one, :other], :rule => lambda { |n| n == 1 ? :one : :other } } } }
+}
+
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/test/test_helper.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/test_helper.rb
new file mode 100644
index 0000000..91abe67
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/test/test_helper.rb
@@ -0,0 +1,100 @@
+# encoding: utf-8
+
+$:.unshift File.expand_path("../lib", File.dirname(__FILE__))
+$:.unshift File.expand_path(File.dirname(__FILE__))
+
+require 'i18n'
+require 'i18n/core_ext/object/meta_class'
+
+require 'rubygems'
+require 'test/unit'
+require 'time'
+require 'yaml'
+
+begin
+  require 'mocha'
+rescue LoadError
+  puts "skipping tests using mocha as mocha can't be found"
+end
+
+
+Dir[File.dirname(__FILE__) + '/api/**/*.rb'].each do |filename|
+  require filename
+end
+
+$KCODE = 'u' unless RUBY_VERSION >= '1.9'
+
+# wtf is wrong with this, why's there Kernel#test?
+# class Module
+#   def self.test(name, &block)
+#     define_method("test: " + name, &block)
+#   end
+# end
+
+class Test::Unit::TestCase
+  def self.test(name, &block)
+    define_method("test: " + name, &block)
+  end
+
+  def self.with_mocha
+    yield if Object.respond_to?(:expects)
+  end
+
+  def teardown
+    I18n.locale = nil
+    I18n.default_locale = :en
+    I18n.load_path = []
+    I18n.available_locales = nil
+    I18n.backend = nil
+  end
+
+  def translations
+    I18n.backend.instance_variable_get(:@translations)
+  end
+
+  def store_translations(*args)
+    data   = args.pop
+    locale = args.pop || :en
+    I18n.backend.store_translations(locale, data)
+  end
+
+  def locales_dir
+    File.dirname(__FILE__) + '/fixtures/locales'
+  end
+
+  def euc_jp(string)
+    string.encode!(Encoding::EUC_JP)
+  end
+
+  def can_store_procs?
+    I18n::Backend::ActiveRecord === I18n.backend and
+    I18n::Backend::ActiveRecord.included_modules.include?(I18n::Backend::ActiveRecord::StoreProcs)
+  end
+end
+
+def setup_active_record
+  begin
+    require 'activerecord'
+    require 'i18n/backend/active_record'
+    require 'i18n/backend/active_record/store_procs'
+
+    if I18n::Backend::Simple.method_defined?(:interpolate_with_deprecated_syntax)
+      I18n::Backend::Simple.send(:remove_method, :interpolate) rescue NameError
+    end
+
+    ActiveRecord::Base.establish_connection(:adapter => "sqlite3", :database => ":memory:")
+    ActiveRecord::Migration.verbose = false
+    ActiveRecord::Schema.define(:version => 1) do
+      create_table :translations do |t|
+        t.string :locale
+        t.string :key
+        t.string :value
+        t.string :interpolations
+        t.boolean :is_proc, :default => false
+      end
+    end
+
+  rescue LoadError
+    puts "skipping tests using activerecord as activerecord can't be found"
+  end
+end
diff --git a/activesupport/lib/active_support/vendor/i18n-0.3.3/vendor/po_parser.rb b/activesupport/lib/active_support/vendor/i18n-0.3.3/vendor/po_parser.rb
new file mode 100644
index 0000000..547df6a
--- /dev/null
+++ b/activesupport/lib/active_support/vendor/i18n-0.3.3/vendor/po_parser.rb
@@ -0,0 +1,329 @@
+=begin
+  poparser.rb - Generate a .mo
+
+  Copyright (C) 2003-2009 Masao Mutoh <mutoh at highway.ne.jp>
+
+  You may redistribute it and/or modify it under the same
+  license terms as Ruby.
+=end
+
+#MODIFIED
+# removed include GetText etc
+# added stub translation method _(x)
+require 'racc/parser'
+
+module GetText
+
+  class PoParser < Racc::Parser
+
+    def _(x)
+      x
+    end
+
+module_eval <<'..end src/poparser.ry modeval..id7a99570e05', 'src/poparser.ry', 108
+  def unescape(orig)
+    ret = orig.gsub(/\\n/, "\n")
+    ret.gsub!(/\\t/, "\t")
+    ret.gsub!(/\\r/, "\r")
+    ret.gsub!(/\\"/, "\"")
+    ret
+  end
+  
+  def parse(str, data, ignore_fuzzy = true)
+    @comments = []
+    @data = data
+    @fuzzy = false
+    @msgctxt = ""
+    $ignore_fuzzy = ignore_fuzzy
+
+    str.strip!
+    @q = []
+    until str.empty? do
+      case str
+      when /\A\s+/
+	str = $'
+      when /\Amsgctxt/
+	@q.push [:MSGCTXT, $&]
+	str = $'
+      when /\Amsgid_plural/
+	@q.push [:MSGID_PLURAL, $&]
+	str = $'
+      when /\Amsgid/
+	@q.push [:MSGID, $&]
+	str = $'
+      when /\Amsgstr/
+	@q.push [:MSGSTR, $&]
+	str = $'
+      when /\A\[(\d+)\]/
+	@q.push [:PLURAL_NUM, $1]
+	str = $'
+      when /\A\#~(.*)/
+	$stderr.print _("Warning: obsolete msgid exists.\n")
+	$stderr.print "         #{$&}\n"
+	@q.push [:COMMENT, $&]
+	str = $'
+      when /\A\#(.*)/
+	@q.push [:COMMENT, $&]
+	str = $'      
+      when /\A\"(.*)\"/
+	@q.push [:STRING, $1]
+	str = $'
+      else
+	#c = str[0,1]
+	#@q.push [:STRING, c]
+	str = str[1..-1]
+      end
+    end 
+    @q.push [false, '$end']
+    if $DEBUG
+      @q.each do |a,b|
+      puts "[#{a}, #{b}]"
+      end
+    end
+    @yydebug = true if $DEBUG
+    do_parse
+
+    if @comments.size > 0
+      @data.set_comment(:last, @comments.join("\n"))
+    end
+    @data
+  end
+  
+  def next_token
+    @q.shift
+  end
+
+  def on_message(msgid, msgstr)
+    if msgstr.size > 0
+      @data[msgid] = msgstr
+      @data.set_comment(msgid, @comments.join("\n"))
+    end
+    @comments.clear
+    @msgctxt = ""
+  end
+      
+  def on_comment(comment)
+    @fuzzy = true if (/fuzzy/ =~ comment)
+    @comments << comment
+  end 
+
+
+..end src/poparser.ry modeval..id7a99570e05
+
+##### racc 1.4.5 generates ###
+
+racc_reduce_table = [
+ 0, 0, :racc_error,
+ 0, 10, :_reduce_none,
+ 2, 10, :_reduce_none,
+ 2, 10, :_reduce_none,
+ 2, 10, :_reduce_none,
+ 2, 12, :_reduce_5,
+ 1, 13, :_reduce_none,
+ 1, 13, :_reduce_none,
+ 4, 15, :_reduce_8,
+ 5, 16, :_reduce_9,
+ 2, 17, :_reduce_10,
+ 1, 17, :_reduce_none,
+ 3, 18, :_reduce_12,
+ 1, 11, :_reduce_13,
+ 2, 14, :_reduce_14,
+ 1, 14, :_reduce_15 ]
+
+racc_reduce_n = 16
+
+racc_shift_n = 26
+
+racc_action_table = [
+     3,    13,     5,     7,     9,    15,    16,    17,    20,    17,
+    13,    17,    13,    13,    11,    17,    23,    20,    13,    17 ]
+
+racc_action_check = [
+     1,    16,     1,     1,     1,    12,    12,    12,    18,    18,
+     7,    14,    15,     9,     3,    19,    20,    21,    23,    25 ]
+
+racc_action_pointer = [
+   nil,     0,   nil,    14,   nil,   nil,   nil,     3,   nil,     6,
+   nil,   nil,     0,   nil,     4,     5,    -6,   nil,     2,     8,
+     8,    11,   nil,    11,   nil,    12 ]
+
+racc_action_default = [
+    -1,   -16,    -2,   -16,    -3,   -13,    -4,   -16,    -6,   -16,
+    -7,    26,   -16,   -15,    -5,   -16,   -16,   -14,   -16,    -8,
+   -16,    -9,   -11,   -16,   -10,   -12 ]
+
+racc_goto_table = [
+    12,    22,    14,     4,    24,     6,     2,     8,    18,    19,
+    10,    21,     1,   nil,   nil,   nil,    25 ]
+
+racc_goto_check = [
+     5,     9,     5,     3,     9,     4,     2,     6,     5,     5,
+     7,     8,     1,   nil,   nil,   nil,     5 ]
+
+racc_goto_pointer = [
+   nil,    12,     5,     2,     4,    -7,     6,     9,    -7,   -17 ]
+
+racc_goto_default = [
+   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil ]
+
+racc_token_table = {
+ false => 0,
+ Object.new => 1,
+ :COMMENT => 2,
+ :MSGID => 3,
+ :MSGCTXT => 4,
+ :MSGID_PLURAL => 5,
+ :MSGSTR => 6,
+ :STRING => 7,
+ :PLURAL_NUM => 8 }
+
+racc_use_result_var = true
+
+racc_nt_base = 9
+
+Racc_arg = [
+ racc_action_table,
+ racc_action_check,
+ racc_action_default,
+ racc_action_pointer,
+ racc_goto_table,
+ racc_goto_check,
+ racc_goto_default,
+ racc_goto_pointer,
+ racc_nt_base,
+ racc_reduce_table,
+ racc_token_table,
+ racc_shift_n,
+ racc_reduce_n,
+ racc_use_result_var ]
+
+Racc_token_to_s_table = [
+'$end',
+'error',
+'COMMENT',
+'MSGID',
+'MSGCTXT',
+'MSGID_PLURAL',
+'MSGSTR',
+'STRING',
+'PLURAL_NUM',
+'$start',
+'msgfmt',
+'comment',
+'msgctxt',
+'message',
+'string_list',
+'single_message',
+'plural_message',
+'msgstr_plural',
+'msgstr_plural_line']
+
+Racc_debug_parser = true
+
+##### racc system variables end #####
+
+ # reduce 0 omitted
+
+ # reduce 1 omitted
+
+ # reduce 2 omitted
+
+ # reduce 3 omitted
+
+ # reduce 4 omitted
+
+module_eval <<'.,.,', 'src/poparser.ry', 25
+  def _reduce_5( val, _values, result )
+    @msgctxt = unescape(val[1]) + "\004"
+   result
+  end
+.,.,
+
+ # reduce 6 omitted
+
+ # reduce 7 omitted
+
+module_eval <<'.,.,', 'src/poparser.ry', 48
+  def _reduce_8( val, _values, result )
+    if @fuzzy and $ignore_fuzzy 
+      if val[1] != ""
+        $stderr.print _("Warning: fuzzy message was ignored.\n")
+        $stderr.print "         msgid '#{val[1]}'\n"
+      else
+        on_message('', unescape(val[3]))
+      end
+      @fuzzy = false
+    else
+      on_message(@msgctxt + unescape(val[1]), unescape(val[3]))
+    end
+    result = ""
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 65
+  def _reduce_9( val, _values, result )
+    if @fuzzy and $ignore_fuzzy
+      if val[1] != ""
+        $stderr.print _("Warning: fuzzy message was ignored.\n")
+        $stderr.print "msgid = '#{val[1]}\n"
+      else
+        on_message('', unescape(val[3]))
+      end
+      @fuzzy = false
+    else
+      on_message(@msgctxt + unescape(val[1]) + "\000" + unescape(val[3]), unescape(val[4]))
+    end
+    result = ""
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 76
+  def _reduce_10( val, _values, result )
+    if val[0].size > 0
+      result = val[0] + "\000" + val[1]
+    else
+      result = ""
+    end
+   result
+  end
+.,.,
+
+ # reduce 11 omitted
+
+module_eval <<'.,.,', 'src/poparser.ry', 84
+  def _reduce_12( val, _values, result )
+    result = val[2]
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 91
+  def _reduce_13( val, _values, result )
+    on_comment(val[0])
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 99
+  def _reduce_14( val, _values, result )
+    result = val.delete_if{|item| item == ""}.join
+   result
+  end
+.,.,
+
+module_eval <<'.,.,', 'src/poparser.ry', 103
+  def _reduce_15( val, _values, result )
+    result = val[0]
+   result
+  end
+.,.,
+
+ def _reduce_none( val, _values, result )
+  result
+ end
+
+  end   # class PoParser
+
+end   # module GetText
-- 
1.6.4.2

