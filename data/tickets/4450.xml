<?xml version="1.0" encoding="UTF-8"?>
<ticket>
  <assigned-user-id type="integer">12714</assigned-user-id>
  <attachments-count type="integer">1</attachments-count>
  <closed type="boolean">true</closed>
  <created-at type="datetime">2011-01-13T06:52:10+00:00</created-at>
  <creator-id type="integer">23069</creator-id>
  <milestone-due-on type="datetime" nil="true"></milestone-due-on>
  <milestone-id type="integer" nil="true"></milestone-id>
  <number type="integer">4450</number>
  <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
  <priority type="integer">3</priority>
  <project-id type="integer">8994</project-id>
  <raw-data type="binary" nil="true" encoding="base64"></raw-data>
  <state>duplicate</state>
  <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
  <title>'expire_after' option on session forces session creation on each and every action</title>
  <updated-at type="datetime">2011-01-13T06:52:10+00:00</updated-at>
  <user-id type="integer">8551</user-id>
  <version type="integer">10</version>
  <user-name>Fjan</user-name>
  <creator-name>Olek Poplavsky</creator-name>
  <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
  <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
  <priority-name>Low</priority-name>
  <original-body>First of all, this bug was found in rails 2.3.5.

As we all know, sessions in rails 2.x are loaded/created when they are first referenced.

Therefore, if some action is to be hit many times by 'first time users' that we have no interest in tracking, one have to be just very vigilant about never referencing 'session' and junk session objects are not going to be created in database (yes, there are still some of us using active record session store, and not willing to switch to cookie based session store).

If somebody knows of a less fragile approach to creating session-less actions, please do let me know. Personally, I liked the old pre-2.0 behavior of sessions being always loaded, except in pre-configured cases. It was easy and foolproof approach that guaranteed that sessions are not going to be loaded/created for some actions, no matter what.

So, this fragile approach worked for us OK until I started to use new (and great) feature in rails, specifying ':expire_after =&gt; 2.weeks'.

Core functionality works great, cookies are indeed marked to expire in 2 weeks. But the side effect is that session object is CREATED in database for every request now, including those 'session-less' actions. In our case, it leads to ultra-fast bloat of sessions table with obvious performance implications.

For some strange reason this bug may be difficult to reproduce. It does not happen on my development machine (mac os x), but it does happen in our testing/staging/production environments (Ubuntu Hardy, a lot of servers). I do not understand why, those environments are very similar (we use bundler and package all our gems in the project).

I found a workaround, that hopefully will benefit somebody else in same situation.

It involves NOT setting expire_after in session initializer, but doing that in application controller, and doing that conditionally, only when it makes sense to have sessions.

@@@ ruby
  before_filter :change_session_expiration_time

  protected

  def change_session_expiration_time
    if session_allowed? # implement your own
      request.session_options = request.session_options.dup
      request.session_options[:expire_after] = 5.days
    end
  end
@@@</original-body>
  <latest-body>First of all, this bug was found in rails 2.3.5.

As we all know, sessions in rails 2.x are loaded/created when they are first referenced.

Therefore, if some action is to be hit many times by 'first time users' that we have no interest in tracking, one have to be just very vigilant about never referencing 'session' and junk session objects are not going to be created in database (yes, there are still some of us using active record session store, and not willing to switch to cookie based session store).

If somebody knows of a less fragile approach to creating session-less actions, please do let me know. Personally, I liked the old pre-2.0 behavior of sessions being always loaded, except in pre-configured cases. It was easy and foolproof approach that guaranteed that sessions are not going to be loaded/created for some actions, no matter what.

So, this fragile approach worked for us OK until I started to use new (and great) feature in rails, specifying ':expire_after =&gt; 2.weeks'.

Core functionality works great, cookies are indeed marked to expire in 2 weeks. But the side effect is that session object is CREATED in database for every request now, including those 'session-less' actions. In our case, it leads to ultra-fast bloat of sessions table with obvious performance implications.

For some strange reason this bug may be difficult to reproduce. It does not happen on my development machine (mac os x), but it does happen in our testing/staging/production environments (Ubuntu Hardy, a lot of servers). I do not understand why, those environments are very similar (we use bundler and package all our gems in the project).

I found a workaround, that hopefully will benefit somebody else in same situation.

It involves NOT setting expire_after in session initializer, but doing that in application controller, and doing that conditionally, only when it makes sense to have sessions.

@@@ ruby
  before_filter :change_session_expiration_time

  protected

  def change_session_expiration_time
    if session_allowed? # implement your own
      request.session_options = request.session_options.dup
      request.session_options[:expire_after] = 5.days
    end
  end
@@@</latest-body>
  <original-body-html>&lt;div&gt;&lt;p&gt;First of all, this bug was found in rails 2.3.5.&lt;/p&gt;
&lt;p&gt;As we all know, sessions in rails 2.x are loaded/created when
they are first referenced.&lt;/p&gt;
&lt;p&gt;Therefore, if some action is to be hit many times by 'first time
users' that we have no interest in tracking, one have to be just
very vigilant about never referencing 'session' and junk session
objects are not going to be created in database (yes, there are
still some of us using active record session store, and not willing
to switch to cookie based session store).&lt;/p&gt;
&lt;p&gt;If somebody knows of a less fragile approach to creating
session-less actions, please do let me know. Personally, I liked
the old pre-2.0 behavior of sessions being always loaded, except in
pre-configured cases. It was easy and foolproof approach that
guaranteed that sessions are not going to be loaded/created for
some actions, no matter what.&lt;/p&gt;
&lt;p&gt;So, this fragile approach worked for us OK until I started to
use new (and great) feature in rails, specifying ':expire_after
=&amp;gt; 2.weeks'.&lt;/p&gt;
&lt;p&gt;Core functionality works great, cookies are indeed marked to
expire in 2 weeks. But the side effect is that session object is
CREATED in database for every request now, including those
'session-less' actions. In our case, it leads to ultra-fast bloat
of sessions table with obvious performance implications.&lt;/p&gt;
&lt;p&gt;For some strange reason this bug may be difficult to reproduce.
It does not happen on my development machine (mac os x), but it
does happen in our testing/staging/production environments (Ubuntu
Hardy, a lot of servers). I do not understand why, those
environments are very similar (we use bundler and package all our
gems in the project).&lt;/p&gt;
&lt;p&gt;I found a workaround, that hopefully will benefit somebody else
in same situation.&lt;/p&gt;
&lt;p&gt;It involves NOT setting expire_after in session initializer, but
doing that in application controller, and doing that conditionally,
only when it makes sense to have sessions.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;  before_filter :change_session_expiration_time

  protected

  def change_session_expiration_time
    if session_allowed? # implement your own
      request.session_options = request.session_options.dup
      request.session_options[:expire_after] = 5.days
    end
  end&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</original-body-html>
  <versions type="array">
    <version type="Ticket::Version">
      <assigned-user-id type="integer" nil="true"></assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>First of all, this bug was found in rails 2.3.5.

As we all know, sessions in rails 2.x are loaded/created when they are first referenced.

Therefore, if some action is to be hit many times by 'first time users' that we have no interest in tracking, one have to be just very vigilant about never referencing 'session' and junk session objects are not going to be created in database (yes, there are still some of us using active record session store, and not willing to switch to cookie based session store).

If somebody knows of a less fragile approach to creating session-less actions, please do let me know. Personally, I liked the old pre-2.0 behavior of sessions being always loaded, except in pre-configured cases. It was easy and foolproof approach that guaranteed that sessions are not going to be loaded/created for some actions, no matter what.

So, this fragile approach worked for us OK until I started to use new (and great) feature in rails, specifying ':expire_after =&gt; 2.weeks'.

Core functionality works great, cookies are indeed marked to expire in 2 weeks. But the side effect is that session object is CREATED in database for every request now, including those 'session-less' actions. In our case, it leads to ultra-fast bloat of sessions table with obvious performance implications.

For some strange reason this bug may be difficult to reproduce. It does not happen on my development machine (mac os x), but it does happen in our testing/staging/production environments (Ubuntu Hardy, a lot of servers). I do not understand why, those environments are very similar (we use bundler and package all our gems in the project).

I found a workaround, that hopefully will benefit somebody else in same situation.

It involves NOT setting expire_after in session initializer, but doing that in application controller, and doing that conditionally, only when it makes sense to have sessions.

@@@ ruby
  before_filter :change_session_expiration_time

  protected

  def change_session_expiration_time
    if session_allowed? # implement your own
      request.session_options = request.session_options.dup
      request.session_options[:expire_after] = 5.days
    end
  end
@@@</body>
      <body-html>&lt;div&gt;&lt;p&gt;First of all, this bug was found in rails 2.3.5.&lt;/p&gt;
&lt;p&gt;As we all know, sessions in rails 2.x are loaded/created when
they are first referenced.&lt;/p&gt;
&lt;p&gt;Therefore, if some action is to be hit many times by 'first time
users' that we have no interest in tracking, one have to be just
very vigilant about never referencing 'session' and junk session
objects are not going to be created in database (yes, there are
still some of us using active record session store, and not willing
to switch to cookie based session store).&lt;/p&gt;
&lt;p&gt;If somebody knows of a less fragile approach to creating
session-less actions, please do let me know. Personally, I liked
the old pre-2.0 behavior of sessions being always loaded, except in
pre-configured cases. It was easy and foolproof approach that
guaranteed that sessions are not going to be loaded/created for
some actions, no matter what.&lt;/p&gt;
&lt;p&gt;So, this fragile approach worked for us OK until I started to
use new (and great) feature in rails, specifying ':expire_after
=&amp;gt; 2.weeks'.&lt;/p&gt;
&lt;p&gt;Core functionality works great, cookies are indeed marked to
expire in 2 weeks. But the side effect is that session object is
CREATED in database for every request now, including those
'session-less' actions. In our case, it leads to ultra-fast bloat
of sessions table with obvious performance implications.&lt;/p&gt;
&lt;p&gt;For some strange reason this bug may be difficult to reproduce.
It does not happen on my development machine (mac os x), but it
does happen in our testing/staging/production environments (Ubuntu
Hardy, a lot of servers). I do not understand why, those
environments are very similar (we use bundler and package all our
gems in the project).&lt;/p&gt;
&lt;p&gt;I found a workaround, that hopefully will benefit somebody else
in same situation.&lt;/p&gt;
&lt;p&gt;It involves NOT setting expire_after in session initializer, but
doing that in application controller, and doing that conditionally,
only when it makes sense to have sessions.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;ruby&quot;&gt;  before_filter :change_session_expiration_time

  protected

  def change_session_expiration_time
    if session_allowed? # implement your own
      request.session_options = request.session_options.dup
      request.session_options[:expire_after] = 5.days
    end
  end&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-04-21T16:29:37+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>&quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-04-21T16:29:42+01:00</updated-at>
      <user-id type="integer">23069</user-id>
      <version type="integer">1</version>
      <user-name>Olek Poplavsky</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name nil="true"></assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-05-26T18:48:23+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- 
:assigned_user: 
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>&quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-05-26T18:48:26+01:00</updated-at>
      <user-id type="integer">46189</user-id>
      <version type="integer">2</version>
      <user-name>Surendra Singhi</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I think this issue is fixed by #4938.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I think this issue is fixed by &lt;a href=
&quot;/projects/8994/tickets/4938&quot; title=&quot;Ticket #4938&quot;&gt;#4938&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">false</closed>
      <created-at type="datetime">2010-06-28T23:19:49+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">0</priority>
      <project-id type="integer">8994</project-id>
      <state>new</state>
      <tag>&quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-06-28T23:22:34+01:00</updated-at>
      <user-id type="integer">20509</user-id>
      <version type="integer">3</version>
      <user-name>Michael Lovitt</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name nil="true"></priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-06-28T23:30:07+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- 
:state: new
:priority: 0
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>&quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-06-28T23:30:19+01:00</updated-at>
      <user-id type="integer">85</user-id>
      <version type="integer">4</version>
      <user-name>Jeremy Kemper</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>I can't see how the latest patch attached to #4938 (even tho a great work) is going to solve this issue.

If :expire_after is given a value then on AbstractStore#call the session will be loaded. Perhaps this bug is invalid since by defining :expire_after then cookies must be send for every request (due to the very nature of &quot;expire_after&quot;).

Still there are requests that you want to explicitly turn-off sessions no matter what.
IMHO removing session :off was a bad idea. Please bring back the option to turn-off sessions!</body>
      <body-html>&lt;div&gt;&lt;p&gt;I can't see how the latest patch attached to &lt;a href=
&quot;/projects/8994/tickets/4938&quot; title=&quot;Ticket #4938&quot;&gt;#4938&lt;/a&gt; (even
tho a great work) is going to solve this issue.&lt;/p&gt;
&lt;p&gt;If :expire_after is given a value then on AbstractStore#call the
session will be loaded. Perhaps this bug is invalid since by
defining :expire_after then cookies must be send for every request
(due to the very nature of &quot;expire_after&quot;).&lt;/p&gt;
&lt;p&gt;Still there are requests that you want to explicitly turn-off
sessions no matter what.&lt;br&gt;
IMHO removing session :off was a bad idea. Please bring back the
option to turn-off sessions!&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-07-12T00:55:45+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>&quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-07-12T00:55:49+01:00</updated-at>
      <user-id type="integer">106793</user-id>
      <version type="integer">5</version>
      <user-name>Fotos Georgiadis</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body>Fotos is correct; the fix for #4938 does not resolve this issue. 

Let me see if I can sum up the current situation, which I believe has grown out of two conflicting goals:

1) We want to load session data from the session store only when the session is accessed.
2) When we're using the :expire_after option, we want to keep the user's session cookie expiration date fresh -- so, for example, if we've set session cookies to :expire_after =&gt; 2.weeks, then every time the user requests a page in our app, we want to reset the expiration date on the cookie to 2 weeks from right now. 

We attempt to accomplish the first goal with lazy-loaded sessions, but we undermine ourselves on the second goal, by loading the session on every request when the expire_after option is set. That is, when the expire_after option is set, sessions are created/loaded all the time, and lazy loaded sessions are effectively disabled. So, as it stands, our desire to keep the session cookie expiration date fresh is overriding our desire to load session data only when we need it.

This lazy-loading-thwarting expire_after behavior was introduced in commit &lt;a href=&quot;http://github.com/rails/rails/commit/2ae8d307&quot;&gt;2ae8d307&lt;/a&gt;, and, honestly, I would like to see it removed, such that sessions are always loaded lazily, and the cookie expiration date is only freshened when the session is accessed. I think this behavior would be reasonable and expected -- expire_after sets a date in the future after which an unused session effectively expires. If the session has not been accessed, then it has not been used, and so there's no reason to reset its expiration date. 

Since this is a relatively straightforward change to make and test, I went ahead and did so. The patch (for master) is attached. If folks agree with it, then I would be happy to see it applied.

(Alternatively, we could try to be more clever -- for instance, perhaps we treat the cookie store differently than the other stores, since it is less costly with the cookie store to create and load sessions. Or maybe we only load the session and reset the expiration date for an existing session (where we assume a session exists if a session cookie was included in the request) but not for a nonexistent session. And in the existing session case, we could conceivably reset the expiration date without loading anything from the server-side store, by simply sending back in the response exactly the cookie that was sent in the request, only with a new expiration date. This doesn't seem too weird, and I would not mind exploring this approach if others think the extra effort and complexity would be worthwhile. But the simple change I've submitted seems good to me.)</body>
      <body-html>&lt;div&gt;&lt;p&gt;Fotos is correct; the fix for &lt;a href=
&quot;/projects/8994/tickets/4938&quot; title=&quot;Ticket #4938&quot;&gt;#4938&lt;/a&gt; does
not resolve this issue.&lt;/p&gt;
&lt;p&gt;Let me see if I can sum up the current situation, which I
believe has grown out of two conflicting goals:&lt;/p&gt;
&lt;p&gt;1) We want to load session data from the session store only when
the session is accessed.&lt;br&gt;
2) When we're using the :expire_after option, we want to keep the
user's session cookie expiration date fresh -- so, for example, if
we've set session cookies to :expire_after =&amp;gt; 2.weeks, then
every time the user requests a page in our app, we want to reset
the expiration date on the cookie to 2 weeks from right now.&lt;/p&gt;
&lt;p&gt;We attempt to accomplish the first goal with lazy-loaded
sessions, but we undermine ourselves on the second goal, by loading
the session on every request when the expire_after option is set.
That is, when the expire_after option is set, sessions are
created/loaded all the time, and lazy loaded sessions are
effectively disabled. So, as it stands, our desire to keep the
session cookie expiration date fresh is overriding our desire to
load session data only when we need it.&lt;/p&gt;
&lt;p&gt;This lazy-loading-thwarting expire_after behavior was introduced
in commit &lt;a href=
&quot;http://github.com/rails/rails/commit/2ae8d307&quot;&gt;2ae8d307&lt;/a&gt;, and,
honestly, I would like to see it removed, such that sessions are
always loaded lazily, and the cookie expiration date is only
freshened when the session is accessed. I think this behavior would
be reasonable and expected -- expire_after sets a date in the
future after which an unused session effectively expires. If the
session has not been accessed, then it has not been used, and so
there's no reason to reset its expiration date.&lt;/p&gt;
&lt;p&gt;Since this is a relatively straightforward change to make and
test, I went ahead and did so. The patch (for master) is attached.
If folks agree with it, then I would be happy to see it
applied.&lt;/p&gt;
&lt;p&gt;(Alternatively, we could try to be more clever -- for instance,
perhaps we treat the cookie store differently than the other
stores, since it is less costly with the cookie store to create and
load sessions. Or maybe we only load the session and reset the
expiration date for an existing session (where we assume a session
exists if a session cookie was included in the request) but not for
a nonexistent session. And in the existing session case, we could
conceivably reset the expiration date without loading anything from
the server-side store, by simply sending back in the response
exactly the cookie that was sent in the request, only with a new
expiration date. This doesn't seem too weird, and I would not mind
exploring this approach if others think the extra effort and
complexity would be worthwhile. But the simple change I've
submitted seems good to me.)&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-07-14T05:01:18+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- 
:tag: &quot;\&quot;rails 2.3.5\&quot; sessions&quot;
</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-07-14T05:01:23+01:00</updated-at>
      <user-id type="integer">20509</user-id>
      <version type="integer">6</version>
      <user-name>Michael Lovitt</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">0</attachments-count>
      <body></body>
      <body-html></body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-07-14T05:12:22+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-07-14T05:12:24+01:00</updated-at>
      <user-id type="integer">20509</user-id>
      <version type="integer">7</version>
      <user-name>Michael Lovitt</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I agree that resetting cookie expiration date only when session is accessed is much better than forcing it every single time, like it happens right now. That kind of fits the 'principle of least surprise' (at the very least for me).</body>
      <body-html>&lt;div&gt;&lt;p&gt;I agree that resetting cookie expiration date only when session
is accessed is much better than forcing it every single time, like
it happens right now. That kind of fits the 'principle of least
surprise' (at the very least for me).&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-07-14T15:32:26+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-07-14T15:32:29+01:00</updated-at>
      <user-id type="integer">23069</user-id>
      <version type="integer">8</version>
      <user-name>Olek Poplavsky</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>Spot on description Michael. Couldn't have said that better!

I second this patch as well. Would be nice to see this in 2.3 as well.

The other approach described (&quot;if a cookie was send with the request and if the session hasn't been accessed then just send back the same cookie but with an updated expiration date only&quot;) seems to the be expected way things should work. That was the initial impression I had given the option name (:expire_after).

Keep in mind that cookies persist, after closing the browser, only if they have an expiration date set.
So this is kinda important to get working correctly if you want to track^H *ahem* remember users.

But even with this small fix I'm good.</body>
      <body-html>&lt;div&gt;&lt;p&gt;Spot on description Michael. Couldn't have said that better!&lt;/p&gt;
&lt;p&gt;I second this patch as well. Would be nice to see this in 2.3 as
well.&lt;/p&gt;
&lt;p&gt;The other approach described (&quot;if a cookie was send with the
request and if the session hasn't been accessed then just send back
the same cookie but with an updated expiration date only&quot;) seems to
the be expected way things should work. That was the initial
impression I had given the option name (:expire_after).&lt;/p&gt;
&lt;p&gt;Keep in mind that cookies persist, after closing the browser,
only if they have an expiration date set.&lt;br&gt;
So this is kinda important to get working correctly if you want to
track^H &lt;em&gt;ahem&lt;/em&gt; remember users.&lt;/p&gt;
&lt;p&gt;But even with this small fix I'm good.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-07-14T21:13:55+01:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-07-14T21:13:59+01:00</updated-at>
      <user-id type="integer">106793</user-id>
      <version type="integer">9</version>
      <user-name>Fotos Georgiadis</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>I agree that this patch is a good idea but I think we should go one step further and only update the session if it has both been accessed AND been changed, see [6111](https://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/6111-sessions-should-not-be-saved-unless-dirty-patch) for an explanation + patch.</body>
      <body-html>&lt;div&gt;&lt;p&gt;I agree that this patch is a good idea but I think we should go
one step further and only update the session if it has both been
accessed AND been changed, see &lt;a href=
&quot;https://rails.lighthouseapp.com/projects/8994-ruby-on-rails/tickets/6111-sessions-should-not-be-saved-unless-dirty-patch&quot;&gt;
6111&lt;/a&gt; for an explanation + patch.&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-12-03T13:04:52+00:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2010-12-03T13:05:09+00:00</updated-at>
      <user-id type="integer">8551</user-id>
      <version type="integer">10</version>
      <user-name>Fjan</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
    <version type="Ticket::Version">
      <assigned-user-id type="integer">12714</assigned-user-id>
      <attachments-count type="integer">1</attachments-count>
      <body>&lt;a href=&quot;http://www.mp4converter.jp/dvd-creator-mac.html&quot;&gt;DVD&#20316;&#25104;Mac &lt;/a&gt;
&lt;a href=&quot;http://www.mp4converter.jp/dvd-ripper-mac.html&quot;&gt;DVD&#12522;&#12483;&#12500;&#12531;&#12464;Mac&lt;/a&gt;
&lt;a href=&quot;http://www.mp4converter.jp/dvd-copy-mac.html&quot;&gt; DVD&#12467;&#12500;&#12540;Mac &lt;/a&gt;
&lt;a href=&quot;http://www.mp4converter.jp/avi-to-dvd-converter-mac.html&quot;&gt;AVI DVD&#22793;&#25563; Mac&lt;/a&gt;
&lt;a href=&quot;http://www.mp4converter.jp/video-to-dvd-converter-mac.html&quot;&gt;&#21205;&#30011; DVD&#22793;&#25563; Mac &lt;/a&gt;
&lt;a href=&quot;http://www.mp4converter.jp/dvd-audio-ripper-mac.html&quot;&gt;DVD&#38899;&#22768;&#12522;&#12483;&#12500;&#12531;&#12464; Mac&lt;/a&gt;</body>
      <body-html>&lt;div&gt;&lt;p&gt;&lt;a href=
&quot;http://www.mp4converter.jp/dvd-creator-mac.html&quot;&gt;DVD&amp;#20316;&amp;#25104;Mac&lt;/a&gt;&lt;br&gt;
&lt;a href=
&quot;http://www.mp4converter.jp/dvd-ripper-mac.html&quot;&gt;DVD&amp;#12522;&amp;#12483;&amp;#12500;&amp;#12531;&amp;#12464;Mac&lt;/a&gt;&lt;br&gt;
&lt;a href=
&quot;http://www.mp4converter.jp/dvd-copy-mac.html&quot;&gt;DVD&amp;#12467;&amp;#12500;&amp;#12540;Mac&lt;/a&gt;&lt;br&gt;
&lt;a href=
&quot;http://www.mp4converter.jp/avi-to-dvd-converter-mac.html&quot;&gt;AVI
DVD&amp;#22793;&amp;#25563; Mac&lt;/a&gt;&lt;br&gt;
&lt;a href=
&quot;http://www.mp4converter.jp/video-to-dvd-converter-mac.html&quot;&gt;&amp;#21205;&amp;#30011;
DVD&amp;#22793;&amp;#25563; Mac&lt;/a&gt;&lt;br&gt;
&lt;a href=
&quot;http://www.mp4converter.jp/dvd-audio-ripper-mac.html&quot;&gt;DVD&amp;#38899;&amp;#22768;&amp;#12522;&amp;#12483;&amp;#12500;&amp;#12531;&amp;#12464;
Mac&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</body-html>
      <closed type="boolean">true</closed>
      <created-at type="datetime">2010-12-06T06:33:11+00:00</created-at>
      <creator-id type="integer">23069</creator-id>
      <diffable-attributes type="yaml">--- {}

</diffable-attributes>
      <milestone-id type="integer" nil="true"></milestone-id>
      <number type="integer">4450</number>
      <permalink>expire_after-option-on-session-forces-session-creation-on-each-and-every-action</permalink>
      <priority type="integer">3</priority>
      <project-id type="integer">8994</project-id>
      <state>duplicate</state>
      <tag>3.x &quot;rails 2.3.5&quot; sessions</tag>
      <title>'expire_after' option on session forces session creation on each and every action</title>
      <updated-at type="datetime">2011-01-13T06:52:10+00:00</updated-at>
      <user-id type="integer">127909</user-id>
      <version type="integer">11</version>
      <user-name>xiangxiang</user-name>
      <creator-name>Olek Poplavsky</creator-name>
      <assigned-user-name>Yehuda Katz (wycats)</assigned-user-name>
      <url>http://rails.lighthouseapp.com/projects/8994/tickets/4450</url>
      <priority-name>Low</priority-name>
    </version>
  </versions>
  <attachments type="array">
    <attachment type="Attachment">
      <code>527c8a215a401ed62dc0249ac2780f8e31638ed3</code>
      <content-type>text/plain</content-type>
      <created-at type="datetime">2010-07-14T05:12:22+01:00</created-at>
      <filename>expire_after_fix.diff</filename>
      <height type="integer" nil="true"></height>
      <id type="integer">592695</id>
      <size type="integer">3574</size>
      <uploader-id type="integer">20509</uploader-id>
      <width type="integer" nil="true"></width>
      <url>http://rails.lighthouseapp.com/attachments/592695/expire_after_fix.diff</url>
    </attachment>
  </attachments>
</ticket>
